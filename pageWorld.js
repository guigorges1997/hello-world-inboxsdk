/******/ (() => { // webpackBootstrap
var __webpack_exports__ = {};
/*!**************************************************!*\
  !*** ./node_modules/@inboxsdk/core/pageWorld.js ***!
  \**************************************************/
/*!
 * InboxSDK
 * https://www.inboxsdk.com/
 *
 * The use of InboxSDK is governed by the Terms of Services located at
 * https://www.inboxsdk.com/terms


 *  __    __            _     _          _                _                      ___                 _ _ ___
 * / / /\ \ \__ _ _ __ | |_  | |_ ___   | |__   __ _  ___| | __   ___  _ __     / _ \_ __ ___   __ _(_) / _ \
 * \ \/  \/ / _` | '_ \| __| | __/ _ \  | '_ \ / _` |/ __| |/ /  / _ \| '_ \   / /_\/ '_ ` _ \ / _` | | \// /
 *  \  /\  / (_| | | | | |_  | || (_) | | | | | (_| | (__|   <  | (_) | | | | / /_\\| | | | | | (_| | | | \/
 *   \/  \/ \__,_|_| |_|\__|  \__\___/  |_| |_|\__,_|\___|_|\_\  \___/|_| |_| \____/|_| |_| |_|\__,_|_|_| ()
 *
 * Like complex reverse engineering? Want to make Gmail and Inbox a hackable platform?
 *
 * Join us at: www.streak.com/careers?source=sdk
 */

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3758:
/***/ ((module) => {


module.exports = function newArray(start, end) {
    var n0 = typeof start === 'number',
        n1 = typeof end === 'number'

    if (n0 && !n1) {
        end = start
        start = 0
    } else if (!n0 && !n1) {
        start = 0
        end = 0
    }

    start = start|0
    end = end|0
    var len = end-start
    if (len<0)
        throw new Error('array length must be positive')
    
    var a = new Array(len)
    for (var i=0, c=start; i<len; i++, c++)
        a[i] = c
    return a
}

/***/ }),

/***/ 5408:
/***/ ((module, exports, __nested_webpack_require_1507__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = autoHtml;

var _escape = _interopRequireDefault(__nested_webpack_require_1507__(1675));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function autoHtml(templateParts) {
  var parts = new Array(templateParts.length * 2 - 1);
  parts[0] = templateParts[0];

  for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; i++) {
    var value = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    parts[2 * i + 1] = value && Object.prototype.hasOwnProperty.call(value, '__html') ? value.__html : (0, _escape.default)(value);
    parts[2 * i + 2] = templateParts[i + 1];
  }

  return parts.join('');
}

module.exports = exports.default;
module.exports["default"] = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJhdXRvSHRtbCIsInRlbXBsYXRlUGFydHMiLCJwYXJ0cyIsIkFycmF5IiwibGVuZ3RoIiwiaSIsImxlbiIsInZhbHVlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19odG1sIiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBOzs7O0FBSWUsU0FBU0EsUUFBVCxDQUFrQkMsYUFBbEIsRUFBdUU7QUFDcEYsTUFBTUMsS0FBZSxHQUFHLElBQUlDLEtBQUosQ0FBVUYsYUFBYSxDQUFDRyxNQUFkLEdBQXFCLENBQXJCLEdBQXVCLENBQWpDLENBQXhCO0FBQ0FGLEVBQUFBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV0QsYUFBYSxDQUFDLENBQUQsQ0FBeEI7O0FBQ0EsT0FBSyxJQUFJSSxDQUFDLEdBQUMsQ0FBTixFQUFTQyxHQUFHLG1EQUFqQixFQUFpQ0QsQ0FBQyxHQUFDQyxHQUFuQyxFQUF3Q0QsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxRQUFNRSxLQUFLLEdBQVVGLENBQVYsZ0NBQVVBLENBQVYsNkJBQVVBLENBQVYsS0FBWDtBQUNBSCxJQUFBQSxLQUFLLENBQUMsSUFBRUcsQ0FBRixHQUFJLENBQUwsQ0FBTCxHQUFlRSxLQUFLLElBQUlDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDSixLQUFyQyxFQUE0QyxRQUE1QyxDQUFULEdBQWtFQSxLQUFELENBQVlLLE1BQTdFLEdBQXNGLHFCQUFPTCxLQUFQLENBQXJHO0FBQ0FMLElBQUFBLEtBQUssQ0FBQyxJQUFFRyxDQUFGLEdBQUksQ0FBTCxDQUFMLEdBQWVKLGFBQWEsQ0FBQ0ksQ0FBQyxHQUFDLENBQUgsQ0FBNUI7QUFDRDs7QUFDRCxTQUFPSCxLQUFLLENBQUNXLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbmltcG9ydCBlc2NhcGUgZnJvbSAnbG9kYXNoL2VzY2FwZSc7XG5cbmV4cG9ydCB0eXBlIFZhbHVlID0gc3RyaW5nIHwge19faHRtbDogc3RyaW5nfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0h0bWwodGVtcGxhdGVQYXJ0czogc3RyaW5nW10sIC4uLnZhbHVlczogVmFsdWVbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IG5ldyBBcnJheSh0ZW1wbGF0ZVBhcnRzLmxlbmd0aCoyLTEpO1xuICBwYXJ0c1swXSA9IHRlbXBsYXRlUGFydHNbMF07XG4gIGZvciAobGV0IGk9MCwgbGVuPXZhbHVlcy5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBwYXJ0c1syKmkrMV0gPSB2YWx1ZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX2h0bWwnKSA/ICh2YWx1ZTphbnkpLl9faHRtbCA6IGVzY2FwZSh2YWx1ZSk7XG4gICAgcGFydHNbMippKzJdID0gdGVtcGxhdGVQYXJ0c1tpKzFdO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cbiJdfQ==

/***/ }),

/***/ 7036:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_4487__) => {

"use strict";

// EXPORTS
__nested_webpack_require_4487__.d(__nested_webpack_exports__, {
  "Z": () => (/* binding */ ajax)
});

// EXTERNAL MODULE: ./node_modules/querystring-es3/index.js
var querystring_es3 = __nested_webpack_require_4487__(7735);
// EXTERNAL MODULE: ./node_modules/pdelay/js/index.js
var js = __nested_webpack_require_4487__(443);
;// CONCATENATED MODULE: ./src/common/cachebust-url.ts
const r = /([?&])_=[^&]*/;
let nonce = Date.now() + Math.floor(Math.random() * Math.pow(2, 32));
function cachebustUrl(url) {
  if (r.test(url)) {
    return url.replace(r, '$1_=' + nonce++);
  } else {
    return url + (/\?/.test(url) ? '&' : '?') + '_=' + nonce++;
  }
}
;// CONCATENATED MODULE: ./src/common/ajax.ts



const MAX_TIMEOUT = 64 * 1000; //64 seconds
const MAX_RETRIES = 5;
const serversToIgnore = {};

// Simple ajax helper.
// opts:
// * url
// * [method]
// * [cachebust] - boolean
// * [headers] - object
// * [xhrFields] - object
// * [data]
function ajax(opts) {
  if (!opts || typeof opts.url !== 'string') {
    throw new Error('URL must be given');
  }
  return new Promise(function (resolve, reject) {
    const method = opts.method ? opts.method : 'GET';
    let url = opts.url;
    let stringData = null;
    if (opts.data) {
      stringData = typeof opts.data === 'string' ? opts.data : querystring_es3.stringify(opts.data);
      if (method === 'GET' || method === 'HEAD') {
        url += (/\?/.test(url) ? '&' : '?') + stringData;
        stringData = null;
      }
    }
    const canRetry = opts.canRetry != null ? opts.canRetry : method === 'GET' || method === 'HEAD';
    const match = url.match(/(?:(?:[a-z]+:)?\/\/)?([^/]*)\//);
    if (!match) {
      throw new Error('Failed to match url');
    }
    const server = match[1];
    if (Object.prototype.hasOwnProperty.call(serversToIgnore, server)) {
      reject(new Error(`Server at ${url} has told us to stop connecting`));
      return;
    }
    if (opts.cachebust) {
      url = cachebustUrl(url);
    }
    const XMLHttpRequest = opts.XMLHttpRequest || window.XMLHttpRequest;
    const xhr = new XMLHttpRequest();
    Object.assign(xhr, opts.xhrFields);
    xhr.onerror = function (event) {
      if ((opts.retryNum || 0) < MAX_RETRIES) {
        if (xhr.status === 502 || (xhr.status === 0 || xhr.status >= 500) && canRetry) {
          resolve(_retry(opts));
          return;
        }
      }
      const err = Object.assign(new Error(`Failed to load ${url}`), {
        event,
        xhr,
        status: xhr.status
      });

      // give a way for a server to tell us to go away for now. Good fallback
      // in case a bug ever causes clients to spam a server with requests.
      if (xhr.status == 490) {
        serversToIgnore[server] = true;
      }
      reject(err);
    };
    xhr.onload = function (event) {
      if (xhr.status === 200) {
        resolve({
          xhr,
          text: xhr.responseText
        });
      } else {
        xhr.onerror(event);
      }
    };
    xhr.open(method, url, true);
    if (opts.headers) {
      const {
        headers
      } = opts;
      Object.keys(headers).forEach(name => {
        const value = headers[name];
        xhr.setRequestHeader(name, value);
      });
    }
    xhr.send(stringData);
  });
}
function _retry(opts) {
  const retryNum = (opts.retryNum || 0) + 1;

  // 2000 4000 8000...
  const retryTimeout = Math.min(Math.pow(2, retryNum) * 1000, MAX_TIMEOUT);
  return (0,js/* default */.Z)(retryTimeout).then(() => ajax(Object.assign({}, opts, {
    retryNum
  })));
}

/***/ }),

/***/ 9817:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_8102__) => {

"use strict";
/* harmony export */ __nested_webpack_require_8102__.d(__nested_webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ assert)
/* harmony export */ });
/* unused harmony export AssertionError */
class AssertionError extends Error {
  name = 'AssertionError';
  constructor(message) {
    super(message ?? 'assertion failed');
  }
}
function assert(condition, message) {
  // eslint-disable-next-line no-extra-boolean-cast -- this is to mimic Node's assert behavior
  if (!!condition) {
    // ok
  } else {
    throw new AssertionError(message);
  }
}

/***/ }),

/***/ 9865:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_8769__) => {

"use strict";
/* harmony export */ __nested_webpack_require_8769__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ htmlToText)
/* harmony export */ });
// Quick function for converting HTML with entities into text without
// introducing an XSS vulnerability.
function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html.replace(/<[^>]*>?/g, '');
  return div.textContent;
}

/***/ }),

/***/ 8751:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_9280__) => {

"use strict";
/* harmony export */ __nested_webpack_require_9280__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_escape__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_9280__(1675);
/* harmony import */ var lodash_escape__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_9280__.n(lodash_escape__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var auto_html__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_9280__(5408);
/* harmony import */ var auto_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_9280__.n(auto_html__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ud__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_9280__(1010);
/* harmony import */ var _common_html_to_text__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_9280__(9865);
/* harmony import */ var _platform_implementation_js_dom_driver_gmail_gmail_response_processor__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_9280__(6139);
/* module decorator */ module = __nested_webpack_require_9280__.hmd(module);






// This is the type that the user provides.

// These ids are part of the object constructed by the SDK used to refer to a
// suggestion to the injected script.
/*
Notes about the Gmail suggestions response:
The response may be made up of multiple sections. Each section can specify
results. There are three types of results: search terms/contacts, drive files,
and emails. Each section may only contain one type of result. The sections can
be in any order, though Gmail appears to always put the search terms/contacts
section first.

Some fields of a section:
0: The constant "aso.srp"
1: The user's search query
3: Array of search term/contact suggestions.
4: Array of email suggestions.
5: Array of drive suggestions.
6-9: Constants signifying type of section(?)
  search terms/contacts: 1,0,0,1
  drive:                 0,0,1,3
  email:                 0,1,0,2
11: Timestamp in microseconds. Each section should have the same timestamp.
12: Typing autocomplete value or empty array.
13: The length of the user's search query times 4 then cast to a string.

Currently modifySuggestions modifies the first section and adds the
app-provided suggestions into the search term/contact suggestions array.
*/

function modifySuggestions(responseText, modifications) {
  const {
    value: parsed,
    options
  } = _platform_implementation_js_dom_driver_gmail_gmail_response_processor__WEBPACK_IMPORTED_MODULE_1__/* .deserialize */ .vB(responseText);
  const query = parsed[0][1];
  for (const modification of modifications) {
    let name, nameHTML;
    if (typeof modification.name === 'string') {
      name = modification.name;
      nameHTML = lodash_escape__WEBPACK_IMPORTED_MODULE_0___default()(name);
    } else if (typeof modification.nameHTML === 'string') {
      nameHTML = modification.nameHTML;
      name = (0,_common_html_to_text__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(nameHTML);
    }
    if (name == null || nameHTML == null) {
      throw new Error('name or nameHTML must be provided');
    }
    let description, descriptionHTML;
    if (typeof modification.description === 'string') {
      description = modification.description;
      descriptionHTML = lodash_escape__WEBPACK_IMPORTED_MODULE_0___default()(description);
    } else if (typeof modification.descriptionHTML === 'string') {
      descriptionHTML = modification.descriptionHTML;
      description = (0,_common_html_to_text__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(descriptionHTML);
    }
    const data = {
      id: modification.id,
      routeName: modification.routeName,
      routeParams: modification.routeParams,
      externalURL: modification.externalURL
    };
    nameHTML += (auto_html__WEBPACK_IMPORTED_MODULE_3___default())` <span style="display:none" data-inboxsdk-suggestion="${JSON.stringify(data)}"></span>`;
    if (modification.iconHTML != null) {
      nameHTML = `<div class="inboxsdk__custom_suggestion_iconHTML">${modification.iconHTML}</div>${nameHTML}`;
    }
    const newItem = ['aso.sug', modification.searchTerm || query, nameHTML, null, [],
    // screen height estimate. Currently Gmail bugs out if the screen height
    // estimates add up to above the screen height, so let's avoid making the
    // issue more likely by telling it our entries are zero-height.
    0, null, 'asor inboxsdk__custom_suggestion ' + modification.providerId + ' ' + (modification.iconClass || ''), 0];
    if (descriptionHTML != null) {
      newItem[3] = ['aso.eme', description, name, descriptionHTML, nameHTML];
    }

    // Allow iconHtml to be passed, and ignore iconUrl if iconHtml is presents
    if (modification.iconHTML != null) {
      // set empty image
      newItem[6] = ['aso.thn', 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='];
      newItem[7] += ' inboxsdk__no_bg';
    } else if (modification.iconUrl) {
      newItem[6] = ['aso.thn', modification.iconUrl];
      newItem[7] += ' inboxsdk__no_bg';
    } else {
      newItem[7] += ' asor_i4';
    }
    parsed[0][3].push(newItem);
  }
  return _platform_implementation_js_dom_driver_gmail_gmail_response_processor__WEBPACK_IMPORTED_MODULE_1__/* .serialize */ .qC(parsed, options);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,ud__WEBPACK_IMPORTED_MODULE_4__.defn)(module, modifySuggestions));

/***/ }),

/***/ 1513:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_14798__) => {

"use strict";

// EXPORTS
__nested_webpack_require_14798__.d(__nested_webpack_exports__, {
  "Z": () => (/* binding */ setupGmailInterceptor)
});

// UNUSED EXPORTS: setupGmailInterceptorOnFrames

// EXTERNAL MODULE: ./node_modules/lodash/clone.js
var clone = __nested_webpack_require_14798__(6678);
var clone_default = /*#__PURE__*/__nested_webpack_require_14798__.n(clone);
// EXTERNAL MODULE: ./node_modules/lodash/flatten.js
var flatten = __nested_webpack_require_14798__(5564);
var flatten_default = /*#__PURE__*/__nested_webpack_require_14798__.n(flatten);
// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __nested_webpack_require_14798__(3311);
var find_default = /*#__PURE__*/__nested_webpack_require_14798__.n(find);
// EXTERNAL MODULE: ./node_modules/lodash/intersection.js
var intersection = __nested_webpack_require_14798__(5325);
var intersection_default = /*#__PURE__*/__nested_webpack_require_14798__.n(intersection);
// EXTERNAL MODULE: ./node_modules/lodash/includes.js
var includes = __nested_webpack_require_14798__(4721);
var includes_default = /*#__PURE__*/__nested_webpack_require_14798__.n(includes);
// EXTERNAL MODULE: ./node_modules/bignumber.js/bignumber.js
var bignumber = __nested_webpack_require_14798__(4431);
var bignumber_default = /*#__PURE__*/__nested_webpack_require_14798__.n(bignumber);
// EXTERNAL MODULE: ./node_modules/kefir/dist/kefir.esm.js
var kefir_esm = __nested_webpack_require_14798__(6609);
// EXTERNAL MODULE: ./src/injected-js/injected-logger.ts
var injected_logger = __nested_webpack_require_14798__(5895);
// EXTERNAL MODULE: ./node_modules/lodash/has.js
var has = __nested_webpack_require_14798__(8721);
var has_default = /*#__PURE__*/__nested_webpack_require_14798__.n(has);
// EXTERNAL MODULE: ./node_modules/lodash/noop.js
var noop = __nested_webpack_require_14798__(308);
var noop_default = /*#__PURE__*/__nested_webpack_require_14798__.n(noop);
// EXTERNAL MODULE: ./node_modules/lodash/each.js
var each = __nested_webpack_require_14798__(6073);
var each_default = /*#__PURE__*/__nested_webpack_require_14798__.n(each);
// EXTERNAL MODULE: ./node_modules/lodash/filter.js
var filter = __nested_webpack_require_14798__(3105);
var filter_default = /*#__PURE__*/__nested_webpack_require_14798__.n(filter);
// EXTERNAL MODULE: ./node_modules/lodash/once.js
var once = __nested_webpack_require_14798__(1463);
var once_default = /*#__PURE__*/__nested_webpack_require_14798__.n(once);
// EXTERNAL MODULE: ./src/common/assert.ts
var assert = __nested_webpack_require_14798__(9817);
// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __nested_webpack_require_14798__(7187);
var events_default = /*#__PURE__*/__nested_webpack_require_14798__.n(events);
// EXTERNAL MODULE: ./node_modules/querystring-es3/index.js
var querystring_es3 = __nested_webpack_require_14798__(7735);
;// CONCATENATED MODULE: ./src/injected-js/xhr-proxy-factory.ts
/* eslint-disable prefer-rest-params */









const WARNING_TIMEOUT = 60 * 1000;

/**
 * Object with information about the connection in progress. Its fields are
 * populated as the connection goes on. The object is passed as the first
 * argument to all of the wrappers. The object is mutable so the wrappers can
 * add properties to it.
 *
 * @typedef {Object} XHRProxyConnectionDetails
 * @property {string} method
 * @property {string} url
 * @property {Object} params - parameters decoded from the URL
 * @property {Object} headers - request headers set on the XHR
 * @property {string} responseType
 * @property {string} originalSendBody - data passed to send method
 * @property {number} status - HTTP response status
 * @property {string} [originalResponseText] - Is not set if responseType is set
 *  to a value besides 'text'.
 * @property {string} [modifiedResponseText]
 */

/**
 * Thing
 *
 * @callback XHRProxyWrapperCallback
 * @param {XHRProxyConnectionDetails} connection
 */

/**
 * Wrapper object contains optional callbacks that get run for completed
 * requests, and a required isRelevantTo method that filters what types of
 * requests the methods should be called for. All methods are passed an object
 * with details about the connection as the first argument. Some methods are
 * called with a relevant second argument (which is also present within the
 * connection argument).
 *
 * @typedef {Object} XHRProxyWrapper
 * @property {XHRProxyWrapperCallback} isRelevantTo - returns true if wrapper should be used
 *  for request.
 * @property {XHRProxyWrapperCallback} [originalSendBodyLogger] - called with value passed to
 *  send.
 * @property {XHRProxyWrapperCallback} [requestChanger] - Allows the protocol, URL, and body
 *  to be changed together before the connection is opened and sent.
 * @property {XHRProxyWrapperCallback} [originalResponseTextLogger] - called with the responseText as
 *  given by the server. Is not called if responseType is set to a value besides 'text'.
 * @property {XHRProxyWrapperCallback} [responseTextChanger] - called with the responseText as given
 *  by the server and returns new responseText value. Is not called if responseType
 * is set to a value besides 'text'.
 * @property {XHRProxyWrapperCallback} [finalResponseTextLogger] - called with the responseText as
 *  delivered to application code. Is not called if responseType is set to a value besides 'text'.
 * @property {XHRProxyWrapperCallback} [afterListeners] - called after all event listeners
 *  for readystatechange have run
 */

/**
 * Creates a drop-in replacement for the XMLHttpRequest constructor that can
 * have wrappers which may log or modify server responses. See
 * test/xhrproxy.js for usage examples and tests.
 * @function XHRProxyFactory
 * @param {function} XHR - original XMLHttpRequest constructor to wrap
 * @param {XHRProxyWrapper[]} wrappers - mutable array
 * @param {Object} [opts] - Can specify a logError function
 * @returns {function} wrapped XMLHttpRequest-like constructor
 */

function XHRProxyFactory(XHR, wrappers, opts) {
  const logError = opts && opts.logError || function (error) {
    setTimeout(function () {
      // let window.onerror log this
      throw error;
    }, 1);
  };
  function transformEvent(oldTarget, newTarget, event) {
    const newEvent = {};
    Object.keys(event).concat(['bubbles', 'cancelBubble', 'cancelable', 'defaultPrevented', 'preventDefault', 'stopPropagation', 'stopImmediatePropagation', 'lengthComputable', 'loaded', 'total', 'type', 'currentTarget', 'target', 'srcElement', 'NONE', 'CAPTURING_PHASE', 'AT_TARGET', 'BUBBLING_PHASE', 'eventPhase']).filter(name => name in event).forEach(name => {
      const value = event[name];
      if (value === oldTarget) {
        newEvent[name] = newTarget;
      } else if (typeof value === 'function') {
        newEvent[name] = value.bind(event);
      } else {
        newEvent[name] = value;
      }
    });
    return newEvent;
  }
  function wrapEventListener(oldTarget, newTarget, listener) {
    return function (event) {
      return listener.call(newTarget, transformEvent(oldTarget, newTarget, event));
    };
  }
  function findApplicableWrappers(wrappers, connection) {
    return filter_default()(wrappers, function (wrapper) {
      try {
        return wrapper.isRelevantTo(connection);
      } catch (e) {
        logError(e);
      }
    });
  }
  function XHRProxy() {
    this._wrappers = wrappers;
    this._listeners = {};
    this._boundListeners = {};
    this._events = new (events_default())(); // used for internal stuff, not user-visible events

    this.responseText = '';
    this._openState = false;
    if (XHR.bind && XHR.bind.apply) {
      // call constructor with variable number of arguments
      this._realxhr = new (XHR.bind.apply(XHR, [null].concat(arguments)))();
    } else {
      // Safari's XMLHttpRequest lacks a bind method, but its constructor
      // doesn't support extra arguments anyway, so don't bother logging an
      // error here.
      this._realxhr = new XHR();
    }
    const self = this;
    const triggerEventListeners = (name, event) => {
      if (this['on' + name]) {
        try {
          wrapEventListener(this._realxhr, this, this['on' + name]).call(this, event);
        } catch (e) {
          logError(e, 'XMLHttpRequest event listener error');
        }
      }
      each_default()(this._boundListeners[name], boundListener => {
        try {
          boundListener(event);
        } catch (e) {
          logError(e, 'XMLHttpRequest event listener error');
        }
      });
    };
    const runRscListeners = event => {
      triggerEventListeners('readystatechange', event);
    };
    this._fakeRscEvent = function () {
      runRscListeners(Object.freeze({
        bubbles: false,
        cancelBubble: false,
        cancelable: false,
        defaultPrevented: false,
        preventDefault: (noop_default()),
        stopPropagation: (noop_default()),
        stopImmediatePropagation: (noop_default()),
        type: 'readystatechange',
        currentTarget: this,
        target: this,
        srcElement: this,
        NONE: 0,
        CAPTURING_PHASE: 1,
        AT_TARGET: 2,
        BUBBLING_PHASE: 3,
        eventPhase: 0
      }));
    };
    const deliverFinalRsc = event => {
      this.readyState = 4;
      // Remember the status now before any event handlers are called, just in
      // case one aborts the request.
      var wasSuccess = this.status == 200;
      var progressEvent = Object.assign({}, transformEvent(this._realxhr, this, event), {
        lengthComputable: false,
        loaded: 0,
        total: 0
      });
      var supportsResponseText = !this._realxhr.responseType || this._realxhr.responseType == 'text';
      if (supportsResponseText) {
        each_default()(this._activeWrappers, wrapper => {
          if (wrapper.finalResponseTextLogger) {
            try {
              wrapper.finalResponseTextLogger(this._connection, this.responseText);
            } catch (e) {
              logError(e);
            }
          }
        });
      }
      runRscListeners(event);
      if (wasSuccess) {
        triggerEventListeners('load', progressEvent);
      } else {
        triggerEventListeners('error', progressEvent);
      }
      triggerEventListeners('loadend', progressEvent);
      each_default()(this._activeWrappers, wrapper => {
        if (wrapper.afterListeners) {
          try {
            wrapper.afterListeners(this._connection);
          } catch (e) {
            logError(e);
          }
        }
      });
    };
    this._realxhr.addEventListener('readystatechange', event => {
      if (!this._connection) {
        return;
      }
      if (this._realxhr.readyState >= 2) {
        this._connection.status = this._realxhr.status;
      }
      const supportsResponseText = !this._realxhr.responseType || this._realxhr.responseType == 'text';

      // Process the response text.
      if (this._realxhr.readyState == 4) {
        if (supportsResponseText) {
          Object.defineProperty(this._connection, 'originalResponseText', {
            enumerable: true,
            writable: false,
            configurable: false,
            value: self._realxhr.responseText
          });
          each_default()(this._activeWrappers, wrapper => {
            if (wrapper.originalResponseTextLogger) {
              try {
                wrapper.originalResponseTextLogger(this._connection, this._connection.originalResponseText);
              } catch (e) {
                logError(e);
              }
            }
          });
          const finish = once_default()(deliverFinalRsc.bind(null, event));
          if (this._connection.async) {
            // If the XHR object is re-used for another connection, then we need
            // to make sure that our upcoming async calls here do nothing.
            // Remember the current connection object, and do nothing in our async
            // calls if it no longer matches.
            const startConnection = this._connection;
            (async () => {
              let modifiedResponseText = startConnection.originalResponseText;
              startConnection.modifiedResponseText = modifiedResponseText;
              for (const responseTextChanger of this._responseTextChangers) {
                const longRunWarningTimer = setTimeout(() => {
                  console.warn('responseTextChanger is taking too long', responseTextChanger, startConnection);
                }, WARNING_TIMEOUT);
                try {
                  modifiedResponseText = await responseTextChanger(startConnection, modifiedResponseText);
                } finally {
                  clearTimeout(longRunWarningTimer);
                }
                if (typeof modifiedResponseText !== 'string') {
                  throw new Error('responseTextChanger returned non-string value ' + modifiedResponseText);
                }
                startConnection.modifiedResponseText = modifiedResponseText;
                if (startConnection !== this._connection) break;
              }
              return modifiedResponseText;
            })().then(modifiedResponseText => {
              if (startConnection === self._connection) {
                this.responseText = modifiedResponseText;
                finish();
              }
            }, err => {
              logError(err);
              if (startConnection === this._connection) {
                this.responseText = this._realxhr.responseText;
                finish();
              }
            }).catch(logError);
            return;
          } else {
            self.responseText = self._realxhr.responseText;
          }
        } else {
          self.responseText = '';
        }
        deliverFinalRsc(event);
      } else {
        if (self._realxhr.readyState == 1 && self.readyState == 1) {
          // Delayed open+send just happened. We already delivered an event
          // for this, so drop this event.
          return;
        } else if (self._realxhr.readyState >= 3 && supportsResponseText) {
          if (self._responseTextChangers.length) {
            // If we're going to transform the final response, then we don't
            // want to expose any partial untransformed responses and we don't
            // want to bother trying to transform partial responses. Only show
            // an empty string as the loaded response until the connection is
            // done.
            self.responseText = '';
          } else {
            self.responseText = self._realxhr.responseText;
          }
        } else {
          self.responseText = '';
        }
        self.readyState = self._realxhr.readyState;
        runRscListeners(event);
      }
    }, false);
    ['dispatchEvent', 'getAllResponseHeaders', 'getResponseHeader', 'overrideMimeType', 'responseType', 'responseXML', 'responseURL', 'status', 'statusText', 'timeout', 'ontimeout', 'onloadstart', 'onprogress', 'onabort', 'upload', 'withCredentials'].forEach(function (prop) {
      Object.defineProperty(self, prop, {
        enumerable: true,
        configurable: false,
        get: function () {
          // If we give the original native methods directly, they'll be called
          // with `this` as the XHRProxy object, which they aren't made for.
          if (typeof self._realxhr[prop] == 'function') {
            return self._realxhr[prop].bind(self._realxhr);
          }
          return self._realxhr[prop];
        },
        set: function (v) {
          if (typeof v == 'function') {
            v = wrapEventListener(this._realxhr, this, v);
          }
          self._realxhr[prop] = v;
        }
      });
    });
    Object.defineProperty(self, 'response', {
      enumerable: true,
      configurable: false,
      get: function () {
        if (!this._realxhr.responseType || this._realxhr.responseType == 'text') {
          return this.responseText;
        } else {
          // We're not trying to transform non-text responses currently.
          return this._realxhr.response;
        }
      }
    });
    self.readyState = self._realxhr.readyState;
  }
  XHRProxy.prototype.abort = function () {
    // Important: If the request has already been sent, the XHR will change
    // its readyState to 4 after abort. However, we sometimes asynchronously
    // delay send calls. If the application has already called send but we
    // haven't sent off the real call yet, then we need to hurry up and send
    // something before the abort so that the readyState change happens.
    if (this._clientStartedSend && !this._realStartedSend) {
      if (this.readyState != 0 && this._realxhr.readyState == 0) {
        this._realxhr.open(this._connection.method, this._connection.url);
      }
      this._realStartedSend = true;
      this._realxhr.send();
    }
    this._realxhr.abort();
  };
  XHRProxy.prototype.setRequestHeader = function (name, value) {
    var self = this;
    if (this.readyState != 1) {
      console.warn('setRequestHeader improperly called at readyState ' + this.readyState);
    }
    if (!this._openState) {
      throw new Error('Can only set headers after open and before send');
    }
    this._connection.headers[name] = value;
    if (this._connection.async && this._requestChangers.length) {
      this._events.once('realOpen', function () {
        self._realxhr.setRequestHeader(name, value);
      });
    } else {
      this._realxhr.setRequestHeader(name, value);
    }
  };
  XHRProxy.prototype.addEventListener = function (name, listener) {
    if (!this._listeners[name]) {
      this._listeners[name] = [];
      this._boundListeners[name] = [];
    }
    if (!includes_default()(this._listeners[name], listener)) {
      var boundListener = wrapEventListener(this._realxhr, this, listener);
      this._listeners[name].push(listener);
      this._boundListeners[name].push(boundListener);
      if (!includes_default()(['readystatechange', 'load', 'error', 'loadend'], name)) {
        // certain listeners are called manually so that the final
        // call (when readyState==4) can be delayed.
        this._realxhr.addEventListener(name, boundListener, false);
      }
    }
  };
  XHRProxy.prototype.removeEventListener = function (name, listener) {
    if (!this._listeners[name]) {
      return;
    }
    var i = this._listeners[name].indexOf(listener);
    if (i == -1) {
      return;
    }
    this._listeners[name].splice(i, 1);
    var boundListener = this._boundListeners[name].splice(i, 1)[0];
    if (name != 'readystatechange') {
      this._realxhr.removeEventListener(name, boundListener, false);
    }
  };
  XHRProxy.prototype.open = function (method, url, async) {
    // Work around MailTrack issue
    if (!(this instanceof XHRProxy)) {
      return XHR.prototype.open.apply(this, arguments);
    }
    var self = this;
    this._connection = {
      method: method,
      url: url,
      params: (0,querystring_es3.parse)(url.split('?')[1] || ''),
      headers: {},
      async: arguments.length < 3 || !!async
    };
    this._clientStartedSend = false;
    this._realStartedSend = false;
    this._activeWrappers = findApplicableWrappers(this._wrappers, this._connection);
    this._responseTextChangers = this._activeWrappers.map(function (wrapper) {
      return wrapper.responseTextChanger && wrapper.responseTextChanger.bind(wrapper);
    }).filter(Boolean);
    this.responseText = '';
    this._openState = true;
    function finish(method, url) {
      return self._realxhr.open(method, url, self._connection.async);
    }
    if (this._connection.async) {
      this._requestChangers = this._activeWrappers.map(function (wrapper) {
        return wrapper.requestChanger && wrapper.requestChanger.bind(wrapper);
      }).filter(Boolean);
      if (this._requestChangers.length) {
        if (this.readyState != 1) {
          this.readyState = 1;
          this._fakeRscEvent();
        }
      } else {
        finish(method, url);
      }
    } else {
      finish(method, url);
    }
  };
  XHRProxy.prototype.send = function (body) {
    var self = this;
    this._clientStartedSend = true;
    this._openState = false;
    Object.defineProperty(this._connection, 'originalSendBody', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: body
    });
    this._connection.responseType = this._realxhr.responseType || 'text';
    each_default()(self._activeWrappers, function (wrapper) {
      if (wrapper.originalSendBodyLogger) {
        try {
          wrapper.originalSendBodyLogger(self._connection, body);
        } catch (e) {
          logError(e);
        }
      }
    });
    function finish(body) {
      self._realStartedSend = true;
      self._realxhr.send(body);
    }
    if (this._connection.async && this._requestChangers.length) {
      // If the XHR object is re-used for another connection, then we need
      // to make sure that our upcoming async calls here do nothing.
      // Remember the current connection object, and do nothing in our async
      // calls if it no longer matches. Also check for aborts.
      const startConnection = this._connection;
      const request = {
        method: this._connection.method,
        url: this._connection.url,
        body: body
      };
      (async () => {
        let modifiedRequest = request;
        for (const requestChanger of this._requestChangers) {
          const longRunWarningTimer = setTimeout(() => {
            console.warn('requestChanger is taking too long', requestChanger, startConnection);
          }, WARNING_TIMEOUT);
          try {
            modifiedRequest = await requestChanger(this._connection, Object.freeze(modifiedRequest));
          } finally {
            clearTimeout(longRunWarningTimer);
          }
          (0,assert/* assert */.h)(has_default()(modifiedRequest, 'method'), 'modifiedRequest has method');
          (0,assert/* assert */.h)(has_default()(modifiedRequest, 'url'), 'modifiedRequest has url');
          (0,assert/* assert */.h)(has_default()(modifiedRequest, 'body'), 'modifiedRequest has body');
          if (startConnection !== this._connection || this._realStartedSend) break;
        }
        return modifiedRequest;
      })().catch(err => {
        logError(err);
        return request;
      }).then(modifiedRequest => {
        if (startConnection === this._connection && !this._realStartedSend) {
          this._realxhr.open(modifiedRequest.method, modifiedRequest.url);
          this._events.emit('realOpen');
          finish(modifiedRequest.body);
        }
      });
    } else {
      finish(body);
    }
  };
  [XHRProxy, XHRProxy.prototype].forEach(function (obj) {
    Object.assign(obj, {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    });
  });
  return XHRProxy;
}
// EXTERNAL MODULE: ./src/platform-implementation-js/dom-driver/gmail/gmail-response-processor.ts
var gmail_response_processor = __nested_webpack_require_14798__(6139);
;// CONCATENATED MODULE: ./src/injected-js/gmail/thread-identifier/thread-row-parser.ts




/**
 * Ads in the Promotions tab aren't included with other thread row data.
 */
const ThreadRowAd = Symbol(`ThreadRowAd`);
function extractMetadataFromThreadRow(threadRow) {
  var timeSpan, subjectSpan, peopleDiv;
  (0,assert/* assert */.h)(threadRow.hasAttribute('id'), 'check element is main thread row');
  var errors = [];
  var threadRowIsVertical = intersection_default()(Array.from(threadRow.classList), ['zA', 'apv']).length === 2;
  const isThreadRowAd = threadRow.querySelector('.am0,.bvA');
  if (isThreadRowAd) {
    return ThreadRowAd;
  } else if (threadRowIsVertical) {
    var threadRow2 = threadRow.nextElementSibling;
    if (!threadRow2) {
      errors.push('failed to find threadRow2');
    } else {
      var threadRow3 = threadRow2.nextElementSibling;
      if (!threadRow3 || !threadRow3.classList.contains('apw')) {
        threadRow3 = null;
      }
      timeSpan = threadRow.querySelector('td.apt > div.apm > span[title]');
      subjectSpan = threadRow2.querySelector('td div.xS div.xT div.y6 > span');
      peopleDiv = threadRow.querySelector('td.apy > div.yW, td.apx > div.yW');
    }
  } else {
    timeSpan = threadRow.querySelector('td.xW > span[title]');
    var subjectAreaDiv = threadRow.querySelector('td.a4W div[role=link] div.y6');
    if (subjectAreaDiv && subjectAreaDiv.children.length >= 1) {
      subjectSpan = subjectAreaDiv.children[0]; // body snippet is not always present.
      //var bodySnippetSpan = subjectAreaDiv.children[1];
    }

    peopleDiv = threadRow.querySelector('td.yX > div.yW');
  }
  if (!timeSpan) {
    errors.push('failed to find timeSpan');
  }
  if (!subjectSpan) {
    errors.push('failed to find subjectSpan');
  }
  if (!peopleDiv) {
    errors.push('failed to find peopleDiv');
  }
  if (errors.length) {
    injected_logger.error(new Error('Errors in thread row parsing'), {
      errors
    });
  }
  return {
    timeString: timeSpan ? timeSpan.getAttribute('title') || '' : '',
    subject: subjectSpan ? subjectSpan.textContent : '',
    peopleHtml: peopleDiv ? (0,gmail_response_processor/* cleanupPeopleLine */.E3)(peopleDiv.innerHTML) : ''
  };
}
// EXTERNAL MODULE: ./node_modules/lodash/constant.js
var constant = __nested_webpack_require_14798__(5703);
var constant_default = /*#__PURE__*/__nested_webpack_require_14798__.n(constant);
;// CONCATENATED MODULE: ./src/injected-js/gmail/thread-identifier/click-and-get-popup-url.ts



const ignoreErrors = constant_default()(true);
function getIfOwn(object, prop) {
  if (Object.prototype.hasOwnProperty.call(object, prop)) {
    return object[prop];
  }
  return null;
} // Simulates a control+meta click on an element, intercepts the call to
// window.open, and returns the attempted popup's URL.

function clickAndGetPopupUrl(element) {
  const event = document.createEvent('MouseEvents');
  const options = {
    bubbles: true,
    cancelable: true,
    button: 0,
    pointerX: 0,
    pointerY: 0,
    ctrlKey: true,
    altKey: false,
    shiftKey: false,
    metaKey: true
  };
  event.initMouseEvent('click', options.bubbles, options.cancelable, document.defaultView, options.button, options.pointerX, options.pointerY, options.pointerX, options.pointerY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, null);
  let url;
  const oldWindowOpen = window.open,
    oldWindowOnerror = window.onerror,
    oldFocus = getIfOwn(window.HTMLElement.prototype, 'focus'),
    oldBlur = getIfOwn(window.HTMLElement.prototype, 'blur');
  try {
    window.HTMLElement.prototype.focus = (noop_default());
    window.HTMLElement.prototype.blur = (noop_default());
    window.onerror = ignoreErrors;
    const newOpen = function (_url, _title, _options) {
      url = _url;
      // Gmail checks the returned object for these two values specifically.
      const newWin = {
        closed: false,
        focus: (noop_default())
      };
      setTimeout(function () {
        newWin.closed = true;
      }, 5);
      return newWin;
    };
    window.open = newOpen;

    // If another extension created a setter on window.open, then setting it
    // could have failed. Log to see if this is a thing that ever happens, and
    // avoid letting windows be opened.
    if (window.open !== newOpen) {
      injected_logger.error(new Error('Failed to override window.open'));
      return null;
    }
    element.dispatchEvent(event);
  } finally {
    if (oldFocus) {
      window.HTMLElement.prototype.focus = oldFocus;
    } else {
      delete window.HTMLElement.prototype.focus;
    }
    if (oldBlur) {
      window.HTMLElement.prototype.blur = oldBlur;
    } else {
      delete window.HTMLElement.prototype.blur;
    }
    window.onerror = oldWindowOnerror;
    window.open = oldWindowOpen;
  }
  return url;
}
;// CONCATENATED MODULE: ./src/common/find-parent.ts
/**
 * @deprecated Use @see Element.closest instead.
 */
function findParent(el, cb) {
  let candidate = el.parentElement;
  while (candidate) {
    if (cb(candidate)) {
      return candidate;
    }
    candidate = candidate.parentElement;
  }
  return null;
}
;// CONCATENATED MODULE: ./src/platform-implementation-js/lib/dom/custom-events.ts
var CustomDomEvent = {
  tellMeThisThreadIdByDatabase: "inboxSDKtellMeThisThreadIdByDatabase",
  tellMeThisThreadIdByClick: "inboxSDKtellMeThisThreadIdByClick"
};
;// CONCATENATED MODULE: ./src/injected-js/gmail/thread-identifier/index.ts








function setup() {
  try {
    processPreloadedThreads();
  } catch (err) {
    injected_logger.error(err, 'Failed to process preloaded thread identifiers');
  }
  document.addEventListener(CustomDomEvent.tellMeThisThreadIdByDatabase, function (event) {
    try {
      if (!(event.target instanceof HTMLElement)) {
        throw new Error('event.target is not an HTMLElement');
      }
      const threadId = getGmailThreadIdForThreadRowByDatabase(event.target);
      if (threadId) {
        event.target.setAttribute('data-inboxsdk-threadid', threadId);
      }
    } catch (err) {
      injected_logger.error(err, 'Error in inboxSDKtellMeThisThreadIdByDatabase');
    }
  });
  document.addEventListener(CustomDomEvent.tellMeThisThreadIdByClick, function (event) {
    try {
      if (!(event.target instanceof HTMLElement)) {
        throw new Error('event.target is not an HTMLElement');
      }
      const threadId = getGmailThreadIdForThreadRowByClick(event.target);
      if (threadId) {
        event.target.setAttribute('data-inboxsdk-threadid', threadId);
      }
    } catch (err) {
      injected_logger.error(err, 'Error in inboxSDKtellMeThisThreadIdByClick');
    }
  });
}
function processThreadListResponse(threadListResponse) {
  processThreads(gmail_response_processor/* extractThreads */.MA(threadListResponse));
}
function processThreads(threads) {
  threads.forEach(storeThreadMetadata);
}
const AMBIGUOUS = {
  name: 'AMBIGUOUS'
};
const threadIdsByKey = new Map();
function storeThreadMetadata(threadMetadata) {
  var key = threadMetadataKey(threadMetadata);
  if (threadIdsByKey.has(key)) {
    if (threadIdsByKey.get(key) !== threadMetadata.gmailThreadId) {
      threadIdsByKey.set(key, AMBIGUOUS);
    }
  } else {
    threadIdsByKey.set(key, threadMetadata.gmailThreadId);
  }
}
function threadMetadataKey(threadRowMetadata) {
  return threadRowMetadata.subject.trim() + ':' + threadRowMetadata.timeString.trim() + ':' + threadRowMetadata.peopleHtml.trim();
}
function processPreloadedThreads() {
  const preloadScript = find_default()(document.querySelectorAll('script:not([src])'), script => script.text && script.text.slice(0, 500).indexOf('var VIEW_DATA=[[') > -1);
  if (!preloadScript) {
    // preloadScript is not available in gmail v2, so let's stop logging an error
    return;
  } else {
    const firstBracket = preloadScript.text.indexOf('[');
    const lastBracket = preloadScript.text.lastIndexOf(']');
    const viewDataString = preloadScript.text.slice(firstBracket, lastBracket + 1);
    processThreads(gmail_response_processor/* extractThreadsFromDeserialized */.Ae([gmail_response_processor/* deserializeArray */.GE(viewDataString)]));
  }
}
function getThreadIdFromUrl(url) {
  var tid = (0,querystring_es3.parse)(url).th;
  if (!tid) {
    // drafts in sync world can have weird urls that kind of
    // look like old style urls, and get handled properly here
    var urlHashMatch = url.match(/#(.*)/);
    if (urlHashMatch) {
      // drafts have the hash in them without the th=
      url = decodeURIComponent(decodeURIComponent(urlHashMatch[1]));
      tid = (0,querystring_es3.parse)(url).th;
    }
  }

  // if we're in sync world and it's a
  // draft then a hash can come through in the beginning
  return tid.replace('#', '');
}
function getGmailThreadIdForThreadRowByDatabase(threadRow) {
  const domRowMetadata = extractMetadataFromThreadRow(threadRow);
  if (domRowMetadata === ThreadRowAd) {
    // TODO do we want to do anything here?
    return;
  }
  const key = threadMetadataKey(domRowMetadata);
  const value = threadIdsByKey.get(key);
  if (typeof value === 'string') {
    return value;
  }
}
function getGmailThreadIdForThreadRowByClick(threadRow) {
  // Simulate a ctrl-click on the thread row to get the thread id, then
  // simulate a ctrl-click on the previously selected thread row (or the
  // first thread row) to put the cursor back where it was.
  extractMetadataFromThreadRow(threadRow);
  const parent = findParent(threadRow, el => el.nodeName === 'DIV' && el.getAttribute('role') === 'main');
  if (!parent) {
    throw new Error("Can't operate on disconnected thread row");
  }
  const currentRowSelection = parent.querySelector('td.PE') || parent.querySelector('tr');
  const url = clickAndGetPopupUrl(threadRow);
  const threadId = url && getThreadIdFromUrl(url);
  if (currentRowSelection) {
    clickAndGetPopupUrl(currentRowSelection);
  }
  return threadId;
}
// EXTERNAL MODULE: ./node_modules/lodash/startsWith.js
var startsWith = __nested_webpack_require_14798__(240);
var startsWith_default = /*#__PURE__*/__nested_webpack_require_14798__.n(startsWith);
// EXTERNAL MODULE: ./src/platform-implementation-js/driver-common/gmailAjax.ts + 2 modules
var gmailAjax = __nested_webpack_require_14798__(4013);
;// CONCATENATED MODULE: ./src/platform-implementation-js/lib/isNotNil.ts
// Type predicate to avoid opting out of strict type checking in filter operations.
// Adapted from https://stackoverflow.com/a/46700791
function isNotNil(value) {
  return value != null;
}
;// CONCATENATED MODULE: ./src/platform-implementation-js/dom-driver/gmail/gmail-sync-response-processor.ts


function extractThreadsFromSearchResponse(response) {
  const parsedResponse = JSON.parse(response);
  if (Array.isArray(parsedResponse)) {
    try {
      return extractThreadsFromSearchResponse_20220909(parsedResponse);
    } catch (err) {
      return [];
    }
  }
  const threadDescriptors = parsedResponse && parsedResponse[3];
  if (!threadDescriptors) return [];
  return threadDescriptors.map((descriptorWrapper, index) => {
    const descriptor = descriptorWrapper[1];
    if (!descriptor) return null;
    return {
      subject: descriptor[1],
      snippet: descriptor[2],
      syncThreadID: descriptor[4],
      // It seems Gmail is A/B testing including gmailThreadID in descriptor[20] and not including
      // the encoded version of it in descriptor[18], so pull it from [20] if [18] is not set.
      oldGmailThreadID: descriptor[18] != null ? new (bignumber_default())(descriptor[18]).toString(16) : descriptor[20],
      rawResponse: descriptorWrapper,
      extraMetaData: {
        snippet: parsedResponse[15] && parsedResponse[15][1] && parsedResponse[15][1][index] || '',
        syncMessageData: descriptor[5].map(md => ({
          syncMessageID: md[1],
          oldMessageID: md[56],
          date: +md[7]
        }))
      }
    };
  }).filter(isNotNil);
}
function extractThreadsFromSearchResponse_20220909(parsedResponse) {
  const threadDescriptors = parsedResponse && parsedResponse[2];
  if (!threadDescriptors) return [];
  return threadDescriptors.map((descriptorWrapper, index) => {
    const descriptor = descriptorWrapper[0];
    if (!descriptor) return null;
    return {
      subject: descriptor[0],
      snippet: descriptor[1],
      syncThreadID: descriptor[3],
      // It seems Gmail is A/B testing including gmailThreadID in descriptor[20] and not including
      // the encoded version of it in descriptor[18], so pull it from [20] if [18] is not set.
      oldGmailThreadID: descriptor[17] != null ? new (bignumber_default())(descriptor[17]).toString(16) : descriptor[19],
      rawResponse: descriptorWrapper,
      extraMetaData: {
        snippet: parsedResponse[14] && parsedResponse[14][0] && parsedResponse[14][0][index] || '',
        syncMessageData: descriptor[4].map(md => ({
          syncMessageID: md[0],
          oldMessageID: md[55],
          date: +md[6]
        }))
      }
    };
  }).filter(isNotNil);
}
function extractThreadsFromThreadResponse(response) {
  const parsedResponse = JSON.parse(response);
  if (Array.isArray(parsedResponse)) {
    return extractThreadsFromThreadResponse_20220909(parsedResponse);
  }
  const threadDescriptors = parsedResponse && parsedResponse[2];
  if (!threadDescriptors) throw new Error('Failed to process thread response');
  return threadDescriptors.map(descriptorWrapper => {
    if (typeof descriptorWrapper[1] === 'string' && Array.isArray(descriptorWrapper[3]) && !(descriptorWrapper[2] && descriptorWrapper[2][1] && descriptorWrapper[2][1][14] && Array.isArray(descriptorWrapper[2][2]))) {
      return {
        syncThreadID: descriptorWrapper[1],
        oldGmailThreadID: descriptorWrapper[2] && descriptorWrapper[2][1] && descriptorWrapper[2][1][16] || undefined,
        extraMetaData: {
          snippet: descriptorWrapper[2] && descriptorWrapper[2][1] && descriptorWrapper[2][1][3] || undefined,
          syncMessageData: (descriptorWrapper[3] || []).filter(md => Boolean(md[2])).map(md => ({
            syncMessageID: md[1],
            date: +md[2][17],
            recipients: getRecipientsFromMessageDescriptor(md)
          }))
        }
      };
    } else {
      const threadDescriptor = descriptorWrapper[2] && descriptorWrapper[2][1];
      if (!threadDescriptor) return null;
      let syncMessageData;
      const fullMessageDescriptors = Array.isArray(descriptorWrapper[3]) && descriptorWrapper[3];
      if (fullMessageDescriptors) {
        syncMessageData = fullMessageDescriptors.map(md => ({
          syncMessageID: md[1],
          date: +md[2][17],
          recipients: getRecipientsFromMessageDescriptor(md)
        }));
      } else {
        const messageDescriptors = descriptorWrapper[2] && descriptorWrapper[2][2];
        syncMessageData = messageDescriptors.map(md => ({
          syncMessageId: md[1],
          date: +md[16]
        }));
      }
      return {
        subject: threadDescriptor[2],
        snippet: threadDescriptor[3],
        syncThreadID: threadDescriptor[1],
        oldGmailThreadID: new (bignumber_default())(threadDescriptor[14]).toString(16),
        rawResponse: descriptorWrapper,
        extraMetaData: {
          syncMessageData,
          snippet: ''
        }
      };
    }
  }).filter(isNotNil);
}
function extractThreadsFromThreadResponse_20220909(parsedResponse) {
  const threadDescriptors = parsedResponse && parsedResponse[1];
  if (!threadDescriptors) throw new Error('Failed to process thread response');
  return threadDescriptors.map(descriptorWrapper => {
    if (typeof descriptorWrapper[0] === 'string' && Array.isArray(descriptorWrapper[2]) && !(descriptorWrapper[1] && descriptorWrapper[1][0] && descriptorWrapper[1][0][13] && Array.isArray(descriptorWrapper[1][1]))) {
      return {
        syncThreadID: descriptorWrapper[0],
        oldGmailThreadID: descriptorWrapper[1] && descriptorWrapper[1][0] && descriptorWrapper[1][0][15] || undefined,
        extraMetaData: {
          snippet: descriptorWrapper[1] && descriptorWrapper[1][0] && descriptorWrapper[1][0][2] || undefined,
          syncMessageData: (descriptorWrapper[2] || []).filter(md => Boolean(md[1])).map(md => ({
            syncMessageID: md[0],
            date: +md[1][16],
            recipients: getRecipientsFromMessageDescriptor_20220909(md)
          }))
        }
      };
    } else {
      const threadDescriptor = descriptorWrapper[1] && descriptorWrapper[1][0];
      if (!threadDescriptor) return null;
      let syncMessageData;
      const fullMessageDescriptors = Array.isArray(descriptorWrapper[2]) && descriptorWrapper[2];
      if (fullMessageDescriptors) {
        syncMessageData = fullMessageDescriptors.map(md => ({
          syncMessageID: md[0],
          date: +md[1][16],
          recipients: getRecipientsFromMessageDescriptor_20220909(md)
        }));
      } else {
        const messageDescriptors = descriptorWrapper[1] && descriptorWrapper[1][1];
        syncMessageData = messageDescriptors.map(md => ({
          syncMessageId: md[0],
          date: +md[15]
        }));
      }
      return {
        subject: threadDescriptor[1],
        snippet: threadDescriptor[2],
        syncThreadID: threadDescriptor[0],
        oldGmailThreadID: new (bignumber_default())(threadDescriptor[13]).toString(16),
        rawResponse: descriptorWrapper,
        extraMetaData: {
          syncMessageData,
          snippet: ''
        }
      };
    }
  }).filter(isNotNil);
}
function getRecipientsFromMessageDescriptor(messageDescriptor) {
  if (!messageDescriptor[2]) return;
  const to = messageDescriptor[2][1] || [];
  const cc = messageDescriptor[2][2] || [];
  const bcc = messageDescriptor[2][3] || [];
  return to.concat(cc).concat(bcc).map(recipientDescriptor => ({
    emailAddress: recipientDescriptor[2],
    name: recipientDescriptor[3]
  }));
}
function getRecipientsFromMessageDescriptor_20220909(messageDescriptor) {
  if (!messageDescriptor[1]) return;
  const to = messageDescriptor[1][0] || [];
  const cc = messageDescriptor[1][1] || [];
  const bcc = messageDescriptor[1][2] || [];
  return to.concat(cc).concat(bcc).map(recipientDescriptor => ({
    emailAddress: recipientDescriptor[1],
    name: recipientDescriptor[2]
  }));
}
function replaceThreadsInSearchResponse(response, replacementThreads, _unused // TODO why is this unused?
) {
  const parsedResponse = JSON.parse(response);
  if (Array.isArray(parsedResponse)) {
    try {
      return replaceThreadsInSearchResponse_20220909(parsedResponse, replacementThreads, _unused);
    } catch (err) {
      console.error('Caught err in replaceThreadsInSearchResponse', err);
      return response;
    }
  }
  if (parsedResponse[3] || replacementThreads.length) {
    parsedResponse[3] = replacementThreads.map((_ref, index) => {
      let {
        rawResponse
      } = _ref;
      return {
        ...rawResponse,
        '2': index
      };
    });
  }
  if (parsedResponse[15] || replacementThreads.length) {
    parsedResponse[15] = {
      ...parsedResponse[15],
      '1': replacementThreads.map(_ref2 => {
        let {
          extraMetaData
        } = _ref2;
        return extraMetaData.snippet;
      }),
      '2': replacementThreads.map(_ref3 => {
        let {
          extraMetaData
        } = _ref3;
        return extraMetaData.syncMessageData.map(_ref4 => {
          let {
            syncMessageID
          } = _ref4;
          return syncMessageID;
        });
      })
    };
  }
  return JSON.stringify(parsedResponse);
}
function replaceThreadsInSearchResponse_20220909(parsedResponse, replacementThreads, _unused // TODO why is this unused?
) {
  if (parsedResponse[2] || replacementThreads.length) {
    parsedResponse[2] = replacementThreads.map((_ref5, index) => {
      let {
        rawResponse
      } = _ref5;
      const res = [...rawResponse];
      res[1] = index;
      return res;
    });
  }
  if (parsedResponse[14] || replacementThreads.length) {
    parsedResponse[14] = [...parsedResponse[14]];
    parsedResponse[14][0] = replacementThreads.map(_ref6 => {
      let {
        extraMetaData
      } = _ref6;
      return extraMetaData.snippet;
    });
    if (Array.isArray(parsedResponse[14][1]) && parsedResponse[14][1].length > 0 && Array.isArray(parsedResponse[14][1][0][0])) {
      // 2023-04-19 gmail change
      parsedResponse[14][1] = replacementThreads.map(_ref7 => {
        let {
          extraMetaData
        } = _ref7;
        return [[extraMetaData.syncMessageData[0].syncMessageID]];
      });
    } else {
      parsedResponse[14][1] = replacementThreads.map(_ref8 => {
        let {
          extraMetaData
        } = _ref8;
        return extraMetaData.syncMessageData.map(_ref9 => {
          let {
            syncMessageID
          } = _ref9;
          return syncMessageID;
        });
      });
    }
  }
  return JSON.stringify(parsedResponse);
}
// EXTERNAL MODULE: ./src/platform-implementation-js/driver-common/getAccountUrlPart.ts
var getAccountUrlPart = __nested_webpack_require_14798__(4653);
;// CONCATENATED MODULE: ./src/platform-implementation-js/dom-driver/gmail/gmail-driver/getSyncThreadFromSyncThreadId.ts



async function getThreadFromSyncThreadId(driver, syncThreadId) {
  const [btaiHeader, xsrfToken] = await Promise.all([driver.getPageCommunicator().getBtaiHeader(), driver.getPageCommunicator().getXsrfToken()]);
  return getThreadFromSyncThreadIdUsingHeaders(syncThreadId, btaiHeader, xsrfToken);
}
async function getThreadFromSyncThreadIdUsingHeaders(syncThreadId, btaiHeader, xsrfToken) {
  let responseText = null;
  try {
    const {
      text
    } = await (0,gmailAjax/* default */.Z)({
      method: 'POST',
      url: `https://mail.google.com/sync${(0,getAccountUrlPart/* default */.Z)()}/i/fd`,
      headers: {
        'Content-Type': 'application/json',
        'X-Framework-Xsrf-Token': xsrfToken,
        'X-Gmail-BTAI': btaiHeader,
        'X-Google-BTD': '1'
      },
      data: JSON.stringify({
        '1': [{
          '1': syncThreadId,
          '2': 1
        }]
      })
    });
    responseText = text;
  } catch (err) {
    // try sending request with new format 2022_09_09
    const {
      text
    } = await (0,gmailAjax/* default */.Z)({
      method: 'POST',
      url: `https://mail.google.com/sync${(0,getAccountUrlPart/* default */.Z)()}/i/fd?rt=r&pt=ji`,
      headers: {
        'Content-Type': 'application/json',
        'X-Framework-Xsrf-Token': xsrfToken,
        'X-Gmail-BTAI': btaiHeader,
        'X-Google-BTD': '1'
      },
      data: JSON.stringify([[[syncThreadId, 1]], 2])
    });
    responseText = text;
  }
  const threadDescriptors = extractThreadsFromThreadResponse(responseText);
  if (threadDescriptors.length > 0) {
    const thread = threadDescriptors[0];
    if (thread.oldGmailThreadID) {
      return thread;
    }
  }
  return null;
}
// EXTERNAL MODULE: ./src/platform-implementation-js/driver-common/requestGmailThread.ts
var requestGmailThread = __nested_webpack_require_14798__(3179);
;// CONCATENATED MODULE: ./src/injected-js/message-metadata-holder.ts





const threadIdToMessages = new Map();
function message_metadata_holder_setup() {
  document.addEventListener('inboxSDKtellMeThisMessageDate', function (event) {
    exposeMetadata(event, 'data-inboxsdk-sortdate', m => m.date);
  });
  document.addEventListener('inboxSDKtellMeThisMessageRecipients', function (event) {
    exposeMetadata(event, 'data-inboxsdk-recipients', m => {
      if (m.recipients) return m.recipients;else return null;
    });
  });
}
function exposeMetadata(event, attribute, processor) {
  const {
    target,
    detail: {
      threadId,
      ikValue,
      btaiHeader,
      xsrfToken
    }
  } = event;
  (async () => {
    const messageIndex = Array.from(target.parentElement.children).filter(el => !el.classList.contains('inboxsdk__custom_message_view')).indexOf(target);
    if (messageIndex < 0) {
      throw new Error('Should not happen');
    }
    let message = getMessage(threadId, messageIndex);
    if (message == null || !message.recipients) {
      try {
        await addDataForThread(threadId, ikValue, btaiHeader, xsrfToken);
      } catch (err) {
        injected_logger.error(err);
      }
      message = getMessage(threadId, messageIndex);
      if (message == null) {
        throw new Error('Failed to find message date after re-requesting thread');
      }
    }
    target.setAttribute(attribute, JSON.stringify(processor(message)));
  })().catch(err => {
    target.setAttribute(attribute, 'error');
    injected_logger.error(err);
  });
}
function getMessage(threadId, messageIndex) {
  const messages = threadIdToMessages.get(threadId);
  if (messages) {
    const message = messages[messageIndex];
    if (message) {
      return message;
    }
  }
}
function add(groupedMessages) {
  groupedMessages.forEach(group => {
    threadIdToMessages.set(group.threadID, group.messages);
  });
}
const activeThreadRequestPromises = new Map();
function addDataForThread(threadId, ikValue, btaiHeader, xsrfToken) {
  const existingRequestPromise = activeThreadRequestPromises.get(threadId);
  if (existingRequestPromise) {
    return existingRequestPromise;
  }
  const newPromise = (async () => {
    try {
      if (startsWith_default()(threadId, 'thread')) {
        // new data layer
        if (!btaiHeader || !xsrfToken) {
          throw new Error('Need btaiHeader and xsrfToken when in new data layer');
        }
        const syncThread = await getThreadFromSyncThreadIdUsingHeaders(threadId, btaiHeader, xsrfToken);
        if (syncThread) {
          add([{
            threadID: syncThread.syncThreadID,
            messages: syncThread.extraMetaData.syncMessageData.map(syncMessage => ({
              date: syncMessage.date,
              recipients: syncMessage.recipients
            }))
          }]);
        }
      } else {
        // legacy gmail
        const text = await (0,requestGmailThread/* default */.Z)(ikValue, threadId);
        add((0,gmail_response_processor/* extractMessages */.bd)(text));
      }
    } catch (err) {
      injected_logger.error(err);
    } finally {
      activeThreadRequestPromises.delete(threadId);
    }
  })();
  activeThreadRequestPromises.set(threadId, newPromise);
  return newPromise;
}
;// CONCATENATED MODULE: ./src/common/quoted-split.ts
// Splits a string on spaces, but ignores spaces inside quotes.

function quotedSplit(s) {
  let split = [];
  let lastEnd = 0;
  const quoteRe = /"[^"]*"/g;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const match = quoteRe.exec(s);
    split = split.concat((match ? s.substring(lastEnd, match.index) : s.substring(lastEnd)).split(/ +/).filter(Boolean));
    if (!match) break;
    lastEnd = match.index + match[0].length;
    split.push(match[0]);
  }
  return split;
}
;// CONCATENATED MODULE: ./src/common/defer.ts
// This is a drop-in replacement for RSVP.defer(). New code should avoid using
// this, and should use the Promise constructor instead!

function defer() {
  let resolve = undefined;
  let reject = undefined;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return {
    resolve,
    reject,
    promise
  };
}
// EXTERNAL MODULE: ./src/injected-js/gmail/modify-suggestions.ts
var modify_suggestions = __nested_webpack_require_14798__(8751);
// EXTERNAL MODULE: ./node_modules/lodash/sortBy.js
var sortBy = __nested_webpack_require_14798__(9734);
var sortBy_default = /*#__PURE__*/__nested_webpack_require_14798__.n(sortBy);
;// CONCATENATED MODULE: ./src/injected-js/gmail/constants.ts
const SEND_ACTIONS = ['^pfg'];
const DRAFT_SAVING_ACTIONS = ['^r', '^r_bt'];
;// CONCATENATED MODULE: ./src/injected-js/gmail/sync-compose-processor-20220909.ts




const ACTION_TYPE_PRIORITY_RANK = ['SEND', 'DRAFT_SAVE'];
function parseComposeRequestBody_2022_09_09(request) {
  return parseCreateUpdateSendDraftRequestBody(request);
}
function parseComposeResponseBody_2022_09_09(response) {
  return parseCreateUpdateSendDraftResponseBody(response);
}
function replaceBodyContentInComposeSendRequestBody_2022_09_09(request, newBodyHtmlContent) {
  return replaceBodyContentInSendRequestBody(request, newBodyHtmlContent);
}

/**
 * Parses request body when compose window either saves a draft for the first time,
 * updates the draft or sends the draft.
 * NOTE: request could contain multiple threads and messages within it,
 * prioritize SEND to DRAFT_SAVE message.
 */
function parseCreateUpdateSendDraftRequestBody(request) {
  const updateList = request[1]?.[0];
  if (!Array.isArray(updateList)) {
    // cannot parse
    return null;
  }
  const parsedMessages = updateList.map(parseRequestThread).filter(isNotNil);
  const sorted = sortBy_default()(parsedMessages, m => ACTION_TYPE_PRIORITY_RANK.indexOf(m.type));
  return sorted[0] || null;
}

/**
 * Parses response body when compose window either saved a draft for the first time,
 * updated the draft, or sent the draft.
 * NOTE: response could contain multiple threads and messages within it
 * even not related to a message/thread in the request body.
 * So the calling code should find needed message manually.
 */
function parseCreateUpdateSendDraftResponseBody(response) {
  const updateList = response[1]?.[5];
  if (!Array.isArray(updateList)) {
    // cannot parse
    return [];
  }
  return updateList.map(parseResponseThread).filter(isNotNil).flatMap(parsedThread => {
    const {
      threadId,
      oldThreadId,
      parsedMessages
    } = parsedThread;
    return parsedMessages.map(parsedMessage => {
      const {
        messageId,
        to,
        cc,
        bcc,
        actions,
        rfcID,
        oldMessageId
      } = parsedMessage;
      const actionType = actionsToComposeRequestType(actions);
      if (!actionType) {
        // unsupported actions within a message
        return null;
      }
      return {
        threadId,
        messageId,
        to,
        cc,
        bcc,
        actions,
        rfcID,
        oldMessageId,
        oldThreadId,
        type: actionType
      };
    });
  }).filter(isNotNil);
}
function replaceBodyContentInSendRequestBody(request, newBodyHtmlContent) {
  // since draftID is not passed from outside,
  // use parse function to find a message which body needs to be replaced
  const parsed = parseCreateUpdateSendDraftRequestBody(request);
  if (!parsed) {
    return null;
  }
  const replaceBodyInThisMessageId = parsed.messageId;
  const updateList = request[1]?.[0];
  if (!Array.isArray(updateList)) {
    // cannot parse
    return null;
  }
  for (const threadWrapper of updateList) {
    if (!Array.isArray(threadWrapper) || !Array.isArray(threadWrapper[1])) {
      // cannot parse
      return null;
    }
    const thread = threadWrapper[1];
    const threadId = parseThreadId(thread[0]);
    if (!threadId) {
      // cannot parse
      return null;
    }
    const parseResult = findAndParseRequestMessage(thread);
    if (parseResult?.parsedMsg.messageId === replaceBodyInThisMessageId) {
      const actionType = actionsToComposeRequestType(parseResult.parsedMsg.actions);
      if (actionType === 'SEND') {
        // find first message with needed messageId and 'SEND' action and replace the body content
        replaceBodyInRequestMsg(parseResult.originalMsg, newBodyHtmlContent);
        return request;
      }
    }
  }
  return null;
}
function parseThreadId(threadId) {
  if (!threadId.startsWith('thread-')) {
    return null;
  }
  if (threadId.includes('|')) {
    return threadId.split('|')[0];
  }
  return threadId;
}
function parseMsgId(messageId) {
  if (!messageId.startsWith('msg-')) {
    // cannot parse
    return null;
  }
  return messageId;
}
function parseContacts(contacts) {
  if (!Array.isArray(contacts)) {
    // cannot parse
    return null;
  }
  return contacts.filter(c => !!c[1]).map(c => ({
    emailAddress: c[1],
    name: c[2] ?? null
  }));
}
function findAndParseRequestMessage(thread) {
  const originalMsgs = [thread[1]?.[2]?.[0]?.[4]?.[0], thread[1]?.[1]?.[0], thread[1]?.[13]?.[0]];
  for (const originalMsg of originalMsgs) {
    const parsedMsg = parseRequestMsg(originalMsg);
    if (parsedMsg) {
      return {
        parsedMsg,
        originalMsg
      };
    }
  }
  return null;
}
function parseRequestThread(threadWrapper) {
  if (!Array.isArray(threadWrapper) || !Array.isArray(threadWrapper[1])) {
    // cannot parse
    return null;
  }
  const thread = threadWrapper[1];
  const threadId = parseThreadId(thread[0]);
  if (!threadId) {
    // cannot parse
    return null;
  }
  const parseResult = findAndParseRequestMessage(thread);
  if (!parseResult) {
    // cannot parse
    return null;
  }
  const {
    parsedMsg: message,
    originalMsg
  } = parseResult;
  const {
    messageId,
    to,
    cc,
    bcc,
    subject,
    body,
    actions
  } = message;
  let actionType = actionsToComposeRequestType(actions);
  if (!actionType) {
    // exit if doesn't have required actions
    return null;
  }

  // usually for draft_save action when draft or reply got saved for first time, response could be different
  // from usual update response, so replace draft_save action with first_draft_save in this case.
  if (actionType === 'DRAFT_SAVE' && (originalMsg === thread[1]?.[2]?.[0]?.[4]?.[0] || originalMsg === thread[1]?.[1]?.[0])) {
    actionType = 'FIRST_DRAFT_SAVE';
  }
  return {
    threadId,
    messageId,
    to,
    cc,
    bcc,
    subject,
    body,
    actions,
    type: actionType
  };
}
function parseRequestMsg(msg) {
  if (!Array.isArray(msg)) {
    // cannot parse
    return null;
  }
  const messageId = parseMsgId(msg[0]);
  if (!messageId) {
    // cannot parse
    return null;
  }
  const subject = msg[7];
  const to = parseContacts(msg[2]);
  const cc = parseContacts(msg[3]);
  const bcc = parseContacts(msg[4]);
  const body = msg[8][1][0][1];
  const actions = msg[10];
  const rfcID = msg[13];
  const oldMessageId = msg[55];
  return {
    messageId,
    to,
    cc,
    bcc,
    subject,
    body,
    actions,
    rfcID,
    oldMessageId
  };
}
function replaceBodyInRequestMsg(msg, newBodyHtmlContent) {
  if (!Array.isArray(msg)) {
    // cannot parse
    return null;
  }
  msg[8][1][0][1] = newBodyHtmlContent;
}
function parseResponseThread(threadWrapper) {
  if (!Array.isArray(threadWrapper) || !Array.isArray(threadWrapper[0])) {
    // cannot parse
    return null;
  }
  const thread = threadWrapper[0];
  const threadId = parseThreadId(thread[0]);
  if (!threadId) {
    // cannot parse
    return null;
  }
  const threadInner = thread[2]?.[6]?.[0];
  if (!Array.isArray(threadInner)) {
    // cannot parse
    return null;
  }
  const oldThreadId = threadInner[19];
  const parsedMessages = Array.isArray(threadInner[4]) ? threadInner[4].map(msg => {
    if (!Array.isArray(msg)) {
      // cannot parse
      return null;
    }
    return parseResponseMsg(msg);
  }).filter(isNotNil) : [];
  return {
    threadId,
    oldThreadId,
    parsedMessages
  };
}
function parseResponseMsg(msg) {
  if (!Array.isArray(msg)) {
    // cannot parse
    return null;
  }
  const messageId = parseMsgId(msg[0]);
  if (!messageId) {
    // cannot parse
    return null;
  }
  const actions = msg[10];
  const to = parseContacts(msg[2]);
  const cc = parseContacts(msg[3]);
  const bcc = parseContacts(msg[4]);
  const rfcID = msg[13];
  const oldMessageId = msg[55];
  return {
    messageId,
    to,
    cc,
    bcc,
    actions,
    rfcID,
    oldMessageId
  };
}
function actionsToComposeRequestType(actions) {
  if (intersection_default()(actions, DRAFT_SAVING_ACTIONS).length === DRAFT_SAVING_ACTIONS.length) {
    return 'DRAFT_SAVE';
  }
  if (intersection_default()(actions, SEND_ACTIONS).length === SEND_ACTIONS.length) {
    return 'SEND';
  }
  return null;
}
;// CONCATENATED MODULE: ./src/injected-js/gmail/sync-compose-request-processor.ts


function getDetailsOfComposeRequest(parsed) {
  const updateList = parsed[2] && parsed[2][1];
  if (!updateList) return null;
  const messageUpdates = updateList.filter(update => {
    const updateWrapper = update[2] && update[2][2] && (update[2][2][14] || update[2][2][2]);
    return updateWrapper && updateWrapper[1] && updateWrapper[1][1] && updateWrapper[1][1].indexOf('msg-a:') > -1;
  });
  if (messageUpdates.length) {
    const sendUpdateMatch = messageUpdates.find(update => {
      const updateWrapper = update[2] && update[2][2] && (update[2][2][14] || update[2][2][2]);
      return updateWrapper[1][11] && intersection_default()(updateWrapper[1][11], SEND_ACTIONS).length === SEND_ACTIONS.length;
    });
    if (sendUpdateMatch) {
      const sendUpdateWrapper = sendUpdateMatch[2] && sendUpdateMatch[2][2] && (sendUpdateMatch[2][2][14] || sendUpdateMatch[2][2][2]);
      const sendUpdate = sendUpdateWrapper[1];
      return getComposeRequestFromUpdate(sendUpdate, 'SEND');
    } else {
      // There's a small chance that an update list could contain the
      // draft saves for multiple drafts in some situations  we've never
      // seen this so currently just picking the first update and assuming
      // that if there are multiple updates in the request they are for
      // queued up versions of the same draft.

      const firstMessageUpdate = messageUpdates[0];
      const updateWrapper = firstMessageUpdate[2] && firstMessageUpdate[2][2] && (firstMessageUpdate[2][2][14] || firstMessageUpdate[2][2][2]);
      const update = updateWrapper[1];
      return getComposeRequestFromUpdate(update, 'DRAFT_SAVE');
    }
  } else {
    // the first time a draft is saved it has a different response format
    const messageUpdates = updateList.map(update => update[2] && update[2][2] && update[2][2][3] && update[2][2][3][1] && update[2][2][3][1][5] && update[2][2][3][1][5][0]).filter(Boolean);
    if (messageUpdates.length === 0) return null;
    const firstMessageUpdate = messageUpdates[0];
    return getComposeRequestFromUpdate(firstMessageUpdate, 'FIRST_DRAFT_SAVE');
  }
}
function getComposeRequestFromUpdate(update, type) {
  const body = update[9] && update[9][2] && update[9][2][0] && update[9][2][0][2];
  if (body == null) return null;
  return {
    body,
    type,
    to: sync_compose_request_processor_parseContacts(update[3]),
    cc: sync_compose_request_processor_parseContacts(update[4]),
    bcc: sync_compose_request_processor_parseContacts(update[5]),
    draftID: update[1].replace('msg-a:', ''),
    subject: update[8]
  };
}
function sync_compose_request_processor_parseContacts(contacts) {
  if (!Array.isArray(contacts)) {
    // exit cuz cannot parse
    return null;
  }
  return contacts.map(c => ({
    emailAddress: c[2],
    name: c[3] || null
  }));
}
function replaceEmailBodyForSendRequest(request, newBody) {
  if (!newBody) return request;
  const parsed = JSON.parse(request);
  const updateList = parsed[2] && parsed[2][1];
  if (!updateList) return request;
  const messageUpdates = updateList.filter(update => {
    const updateWrapper = update[2] && update[2][2] && (update[2][2][14] || update[2][2][2]);
    return updateWrapper && updateWrapper[1] && updateWrapper[1][1] && updateWrapper[1][1].indexOf('msg-a:') > -1;
  });
  if (!messageUpdates.length) return request;
  const sendUpdateMatch = messageUpdates.find(update => {
    const updateWrapper = update[2] && update[2][2] && (update[2][2][14] || update[2][2][2]);
    return updateWrapper[1][11] && intersection_default()(updateWrapper[1][11], SEND_ACTIONS).length === SEND_ACTIONS.length;
  });
  if (!sendUpdateMatch) return request;
  const sendUpdateWrapper = sendUpdateMatch[2] && sendUpdateMatch[2][2] && (sendUpdateMatch[2][2][14] || sendUpdateMatch[2][2][2]);
  const sendUpdate = sendUpdateWrapper[1];
  sendUpdate[9][2][0][2] = newBody;
  return JSON.stringify(parsed);
}
;// CONCATENATED MODULE: ./src/injected-js/gmail/sync-compose-processor.ts



function parseComposeRequestBody(request) {
  const requestParsed = JSON.parse(request);
  try {
    if (Array.isArray(requestParsed)) {
      const parsed = parseComposeRequestBody_2022_09_09(requestParsed);
      if (parsed) {
        return {
          type: parsed.type,
          to: parsed.to,
          cc: parsed.cc,
          bcc: parsed.bcc,
          draftID: parsed.messageId.replace('msg-a:', ''),
          subject: parsed.subject,
          body: parsed.body
        };
      }
      return null;
    }
  } catch (err) {
    injected_logger.eventSdkPassive('connection.requestResponseParsingFailed', {
      requestParseError: err
    });
  }
  return getDetailsOfComposeRequest(requestParsed);
}
function parseComposeResponseBody(response) {
  const responseParsed = JSON.parse(response);
  if (Array.isArray(responseParsed)) {
    return parseComposeResponseBody_2022_09_09(responseParsed);
  }
  return [];
}
function replaceBodyContentInComposeSendRequestBody(request, newBodyHtmlContent) {
  const requestParsed = JSON.parse(request);
  try {
    if (Array.isArray(requestParsed)) {
      const replacedRequestObj = replaceBodyContentInComposeSendRequestBody_2022_09_09(requestParsed, newBodyHtmlContent);
      if (replacedRequestObj) {
        return JSON.stringify(replacedRequestObj);
      }

      // if couldn't parse and replace body content, return original object
      return request;
    }
  } catch (err) {
    injected_logger.eventSdkPassive('connection.requestResponseParsingFailed', {
      replaceBodyFailed: err
    });
  }
  return replaceEmailBodyForSendRequest(request, newBodyHtmlContent);
}
;// CONCATENATED MODULE: ./src/injected-js/gmail/setup-gmail-interceptor.ts


















function logErrorExceptEventListeners(err, details) {
  // Don't log Gmail's errors
  if (details !== 'XMLHttpRequest event listener error') {
    injected_logger.error(err, details);
  } else {
    setTimeout(function () {
      // let window.onerror log this
      throw err;
    }, 1);
  }
}
function setupGmailInterceptor() {
  let jsFrame = null;
  const js_frame_element = top.document.getElementById('js_frame');
  if (js_frame_element) {
    jsFrame = js_frame_element.contentDocument.defaultView;
  } else {
    injected_logger.eventSdkPassive('noJSFrameElementFound');
  }
  setupGmailInterceptorOnFrames(window, jsFrame);
}

// Split into a separate step to make it easy for tests to use.
function setupGmailInterceptorOnFrames(mainFrame, jsFrame) {
  const main_wrappers = [],
    js_frame_wrappers = [];
  {
    const main_originalXHR = mainFrame.XMLHttpRequest;
    mainFrame.XMLHttpRequest = XHRProxyFactory(main_originalXHR, main_wrappers, {
      logError: logErrorExceptEventListeners
    });
  }
  if (jsFrame) {
    const js_frame_originalXHR = jsFrame.XMLHttpRequest;
    jsFrame.XMLHttpRequest = XHRProxyFactory(js_frame_originalXHR, js_frame_wrappers, {
      logError: logErrorExceptEventListeners
    });
  }
  setup();
  message_metadata_holder_setup();
  //email sending modifier/notifier
  {
    const modifiers = {};
    kefir_esm["default"].fromEvents(document, 'inboxSDKregisterComposeRequestModifier').onValue(_ref => {
      let {
        detail
      } = _ref;
      const keyId = detail.composeid || detail.draftID;
      if (!modifiers[keyId]) {
        modifiers[keyId] = [];
      }
      modifiers[keyId].push(detail.modifierId);
    });
    kefir_esm["default"].fromEvents(document, 'inboxSDKunregisterComposeRequestModifier').onValue(_ref2 => {
      let {
        detail
      } = _ref2;
      const {
        keyId,
        modifierId
      } = detail;
      modifiers[keyId] = modifiers[keyId].filter(item => item !== modifierId);
      if (modifiers[keyId].length === 0) {
        delete modifiers[keyId];
      }
    });
    js_frame_wrappers.push({
      isRelevantTo: function (connection) {
        return connection.params.act === 'sm';
      },
      originalSendBodyLogger: function (connection, body) {
        triggerEvent({
          type: 'emailSending',
          body: body
        });
      },
      requestChanger: async function (connection, request) {
        let composeParams = querystring_es3.parse(request.body);
        const composeid = composeParams.composeid;
        const composeModifierIds = modifiers[composeParams.composeid];
        if (!composeModifierIds || composeModifierIds.length === 0) {
          return request;
        }
        for (let ii = 0; ii < composeModifierIds.length; ii++) {
          const modifierId = composeModifierIds[ii];
          const modificationPromise = kefir_esm["default"].fromEvents(document, 'inboxSDKcomposeRequestModified').filter(_ref3 => {
            let {
              detail
            } = _ref3;
            return detail.composeid === composeid && detail.modifierId === modifierId;
          }).take(1).map(_ref4 => {
            let {
              detail
            } = _ref4;
            return detail.composeParams;
          }).toPromise(

            /* Promise */);
          triggerEvent({
            type: 'inboxSDKmodifyComposeRequest',
            composeid,
            modifierId,
            composeParams: {
              body: composeParams.body,
              isPlainText: composeParams.ishtml !== '1'
            }
          });
          const newComposeParams = await modificationPromise;
          composeParams = Object.assign({}, composeParams, newComposeParams);
        }
        return Object.assign({}, request, {
          body: stringifyComposeParams(composeParams)
        });
      },
      afterListeners: function (connection) {
        if (connection.status === 200) {
          triggerEvent({
            type: 'emailSent',
            responseText: connection.originalResponseText,
            originalSendBody: connection.originalSendBody
          });
          if (connection.originalSendBody) {
            const composeParams = querystring_es3.parse(connection.originalSendBody);
            delete modifiers[composeParams.composeid];
          }
        }
      }
    });
    js_frame_wrappers.push({
      isRelevantTo: function (connection) {
        return connection.params.act === 'sd';
      },
      originalSendBodyLogger: function (connection, body) {
        triggerEvent({
          type: 'emailDraftSaveSending',
          body: body
        });
      },
      afterListeners: function (connection) {
        if (connection.status === 200) {
          triggerEvent({
            type: 'emailDraftReceived',
            responseText: connection.originalResponseText,
            originalSendBody: connection.originalSendBody,
            connectionDetails: {
              method: connection.method,
              url: connection.url,
              params: connection.params,
              responseType: connection.responseType
            }
          });
        }
      }
    });
    {
      // Sync API-based compose sending intercept
      const currentSendConnectionIDs = new WeakMap();
      const currentDraftSaveConnectionIDs = new WeakMap();
      const currentFirstDraftSaveConnectionIDs = new WeakMap();
      main_wrappers.push({
        isRelevantTo(connection) {
          return /sync(?:\/u\/\d+)?\/i\/s/.test(connection.url);
        },
        originalSendBodyLogger(connection) {
          if (connection.originalSendBody) {
            const composeRequestDetails = parseComposeRequestBody(connection.originalSendBody);
            if (!composeRequestDetails) {
              return;
            }
            const {
              draftID
            } = composeRequestDetails;
            switch (composeRequestDetails.type) {
              case 'FIRST_DRAFT_SAVE':
                currentFirstDraftSaveConnectionIDs.set(connection, draftID);
                break;
              case 'DRAFT_SAVE':
                currentDraftSaveConnectionIDs.set(connection, draftID);
                break;
              case 'SEND':
                currentSendConnectionIDs.set(connection, draftID);
                triggerEvent({
                  type: 'emailSending',
                  draftID
                });
                break;
            }
          }
        },
        requestChanger: async function (connection, request) {
          const composeRequestDetails = parseComposeRequestBody(request.body);
          if (!composeRequestDetails || composeRequestDetails.type !== 'SEND') return request;
          const {
            draftID
          } = composeRequestDetails;
          const composeModifierIds = modifiers[draftID];
          if (!composeModifierIds || composeModifierIds.length === 0) return request;
          let newEmailBody = composeRequestDetails.body;
          for (let ii = 0; ii < composeModifierIds.length; ii++) {
            const modifierId = composeModifierIds[ii];
            const modificationPromise = kefir_esm["default"].fromEvents(document, 'inboxSDKcomposeRequestModified').filter(_ref5 => {
              let {
                detail
              } = _ref5;
              return detail.draftID === draftID && detail.modifierId === modifierId;
            }).take(1).map(_ref6 => {
              let {
                detail
              } = _ref6;
              return detail.composeParams;
            }).toPromise(

              /* Promise */);
            triggerEvent({
              type: 'inboxSDKmodifyComposeRequest',
              draftID,
              modifierId,
              composeParams: {
                body: newEmailBody,
                isPlainText: false
              }
            });
            const newComposeParams = await modificationPromise;
            newEmailBody = newComposeParams.body;
          }
          return Object.assign({}, request, {
            body: replaceBodyContentInComposeSendRequestBody(request.body, newEmailBody)
          });
        },
        afterListeners(connection) {
          if (currentSendConnectionIDs.has(connection) || currentDraftSaveConnectionIDs.has(connection) || currentFirstDraftSaveConnectionIDs.has(connection)) {
            const sendFailed = () => {
              triggerEvent({
                type: 'emailSendFailed',
                draftID
              });
              currentSendConnectionIDs.delete(connection);
            };
            const draftID = currentSendConnectionIDs.get(connection) || currentDraftSaveConnectionIDs.get(connection) || currentFirstDraftSaveConnectionIDs.get(connection);
            if (connection.status !== 200 || !connection.originalResponseText) {
              sendFailed();
              return;
            }
            try {
              const responsesParsed = parseComposeResponseBody(connection.originalResponseText);
              for (const responseParsed of responsesParsed) {
                // If we're sending a draft, we only care about the response related to the draft we're sending.
                if (draftID && !responseParsed.messageId.endsWith(draftID)) {
                  continue;
                }
                if (responseParsed.type === 'FIRST_DRAFT_SAVE' || responseParsed.type === 'DRAFT_SAVE') {
                  triggerEvent({
                    draftID: draftID,
                    type: 'emailDraftReceived',
                    rfcID: responseParsed.rfcID,
                    threadID: responseParsed.threadId,
                    messageID: responseParsed.messageId,
                    oldMessageID: responseParsed.oldMessageId,
                    oldThreadID: responseParsed.oldThreadId
                  });
                  currentSendConnectionIDs.delete(connection);
                  currentDraftSaveConnectionIDs.delete(connection);
                  currentFirstDraftSaveConnectionIDs.delete(connection);
                  return;
                } else if (responseParsed.type === 'SEND') {
                  triggerEvent({
                    draftID: draftID,
                    type: 'emailSent',
                    rfcID: responseParsed.rfcID,
                    threadID: responseParsed.threadId,
                    messageID: responseParsed.messageId,
                    oldMessageID: responseParsed.oldMessageId,
                    oldThreadID: responseParsed.oldThreadId
                  });
                  currentSendConnectionIDs.delete(connection);
                  currentDraftSaveConnectionIDs.delete(connection);
                  currentFirstDraftSaveConnectionIDs.delete(connection);
                  return;
                }
              }
            } catch (err) {
              injected_logger.eventSdkPassive('connection.requestResponseParsingFailed', {
                responseParseError: err
              });
            }
            const originalResponse = JSON.parse(connection.originalResponseText);

            // TODO this function silently fails way too easily. Need to add better logging for it!
            if (currentFirstDraftSaveConnectionIDs.has(connection)) {
              const wrapper = originalResponse[2] && originalResponse[2][6] && originalResponse[2][6][0] && originalResponse[2][6][0][1];
              if (wrapper) {
                const threadUpdate = wrapper[3] && wrapper[3][7] && wrapper[3][7][1];
                const messageUpdate = threadUpdate && threadUpdate[5] && threadUpdate[5][0];
                if (threadUpdate && messageUpdate) {
                  triggerEvent({
                    draftID: draftID,
                    type: 'emailDraftReceived',
                    rfcID: messageUpdate[14],
                    threadID: threadUpdate[4].split('|')[0],
                    messageID: messageUpdate[1],
                    oldMessageID: messageUpdate[56],
                    oldThreadID: threadUpdate[20]
                  });
                } else {
                  injected_logger.error(new Error('Could not parse draft save'));
                }
              } else {
                // pre-2019-05-29 handling
                injected_logger.eventSdkPassive('old compose draft id handling hit');
                const oldWrapper = originalResponse[2] && originalResponse[2][6] && originalResponse[2][6][1] && originalResponse[2][6][1][1];
                if (oldWrapper) {
                  const saveUpdate = oldWrapper[3] && oldWrapper[3][1] && oldWrapper[3][1][1];
                  if (saveUpdate) {
                    triggerEvent({
                      draftID: draftID,
                      type: 'emailDraftReceived',
                      rfcID: saveUpdate[14],
                      messageID: saveUpdate[1],
                      oldMessageID: saveUpdate[48] ? new (bignumber_default())(saveUpdate[48]).toString(16) : saveUpdate[56],
                      syncThreadID: oldWrapper[1]
                    });
                  }
                }
              }
            } else {
              const updateList = originalResponse[2]?.[6];
              if (!updateList) {
                sendFailed();
                return;
              }
              const sendUpdateMatch = updateList.find(update => update[1]?.[3]?.[7]?.[1]?.[5]?.[0]?.[14] && update[1][3][7][1][5].find(message => includes_default()(message[1], draftID)));
              if (!sendUpdateMatch) {
                if (currentSendConnectionIDs.has(connection)) {
                  const minimalSendUpdates = updateList.filter(update => update[1]?.[3]?.[5]?.[3]);
                  if (minimalSendUpdates.length > 0) {
                    const threadID = minimalSendUpdates[0][1][1] ? minimalSendUpdates[0][1][1].replace(/\|.*$/, '') : undefined;
                    triggerEvent({
                      draftID,
                      type: 'emailSent',
                      threadID,
                      //new compose
                      messageID: minimalSendUpdates[0][1][3]?.[5]?.[5]?.[0] ||
                      //replies
                      minimalSendUpdates[0][1][3][5][3]?.[0]
                    });
                  } else {
                    sendFailed();
                  }
                } else {
                  sendFailed();
                }
                return;
              }
              const sendUpdateWrapper = sendUpdateMatch[1]?.[3]?.[7]?.[1];
              const sendUpdate = sendUpdateWrapper[5].find(message => message[1].includes(draftID));
              if (!sendUpdate) {
                sendFailed();
                return;
              }
              const isEmailSentResponse = currentSendConnectionIDs.has(connection);
              if (!Array.isArray(sendUpdate[11])) {
                injected_logger.error(new Error('sendUpdate[11] was not an array'));
              } else {
                if (isEmailSentResponse) {
                  if (sendUpdate[11].indexOf('^r') >= 0) {
                    injected_logger.error(new Error('sendUpdate[11] unexpectedly contained "^r"'));
                  }
                }
              }
              if (isEmailSentResponse) {
                if (sendUpdate[22] !== undefined && sendUpdate[22] !== 3) {
                  injected_logger.error(new Error('sendUpdate[22] was not expected value'), {
                    value: sendUpdate[22]
                  });
                }
              }
              const threadID = sendUpdateWrapper[4] ? sendUpdateWrapper[4].replace(/\|.*$/, '') : undefined;
              triggerEvent({
                draftID: draftID,
                type: isEmailSentResponse ? 'emailSent' : 'emailDraftReceived',
                rfcID: sendUpdate[14],
                messageID: sendUpdate[1],
                oldMessageID: sendUpdate[48] ? new (bignumber_default())(sendUpdate[48]).toString(16) : sendUpdate[56],
                threadID,
                // It seems Gmail is A/B testing including gmailThreadID in response[20] and not including
                // the encoded version of it in response[18], so pull it from [20] if [18] is not set.
                oldThreadID: sendUpdateWrapper[18] != null ? new (bignumber_default())(sendUpdateWrapper[18]).toString(16) : sendUpdateWrapper[20]
              });
            }
            currentSendConnectionIDs.delete(connection);
            currentDraftSaveConnectionIDs.delete(connection);
            currentFirstDraftSaveConnectionIDs.delete(connection);
          }
        }
      });
    }
  }

  // intercept and process thread responses
  {
    js_frame_wrappers.push({
      isRelevantTo(connection) {
        return !!connection.params.search && connection.params.view === 'tl';
      },
      async responseTextChanger(connection, responseText) {
        // Presence of a responseTextChanger blocks Gmail from getting the partial
        // values as this loads. We want our originalResponseTextLogger to run
        // before Gmail has seen any of the response.
        return responseText;
      },
      originalResponseTextLogger(connection) {
        if (connection.status === 200) {
          const responseText = connection.originalResponseText;
          processThreadListResponse(responseText);
        }
      }
    });
  }
  // intercept and process conversation view responses to get message metadata
  {
    // do this for gmail v1
    {
      js_frame_wrappers.push({
        isRelevantTo(connection) {
          return connection.params.view === 'cv';
        },
        originalResponseTextLogger(connection) {
          if (connection.status === 200) {
            const groupedMessages = gmail_response_processor/* extractMessages */.bd(connection.originalResponseText);
            add(groupedMessages);
          }
        }
      });
    }
    // sync API based
    {
      // search response
      main_wrappers.push({
        isRelevantTo: function (connection) {
          return /sync(?:\/u\/\d+)?\/i\/bv/.test(connection.url);
        },
        originalResponseTextLogger(connection) {
          if (connection.status === 200) {
            const threads = extractThreadsFromSearchResponse(connection.originalResponseText);
            add(threads.map(syncThread => ({
              threadID: syncThread.syncThreadID,
              messages: syncThread.extraMetaData.syncMessageData.map(syncMessage => ({
                date: syncMessage.date,
                recipients: syncMessage.recipients
              }))
            })));
          }
        }
      });
      // thread response
      main_wrappers.push({
        isRelevantTo: function (connection) {
          return /sync(?:\/u\/\d+)?\/i\/fd/.test(connection.url);
        },
        originalResponseTextLogger(connection) {
          if (connection.status === 200) {
            const threads = extractThreadsFromThreadResponse(connection.originalResponseText);
            add(threads.map(syncThread => ({
              threadID: syncThread.syncThreadID,
              messages: syncThread.extraMetaData.syncMessageData.map(syncMessage => ({
                date: syncMessage.date,
                recipients: syncMessage.recipients
              }))
            })));
          }
        }
      });
    }
  }
  // Search suggestions modifier
  // The content scripts tell us when they're interested in adding
  // modifications to future suggestion results. When we see a search
  // suggestions request come through, we signal the query string to the content
  // scripts, wait for the same number of responses as the number of registered
  // suggestion modifiers, and then meld them into the query response.
  {
    const providers = Object.create(null);
    let currentQuery;
    let suggestionModifications;
    let currentQueryDefer;
    document.addEventListener('inboxSDKregisterSuggestionsModifier', function (_ref7) {
      let {
        detail
      } = _ref7;
      providers[detail.providerID] = {
        position: Object.keys(providers).length
      };
    });
    document.addEventListener('inboxSDKprovideSuggestions', function (_ref8) {
      let {
        detail
      } = _ref8;
      if (detail.query === currentQuery) {
        const provider = providers[detail.providerID];
        if (!provider) {
          throw new Error('provider does not exist for providerID');
        }
        if (suggestionModifications == null) {
          throw new Error('tried to modified a null suggestionModifications');
        }
        suggestionModifications[provider.position] = detail.suggestions;
        if (suggestionModifications.filter(Boolean).length === Object.keys(providers).length) {
          if (currentQueryDefer == null) {
            throw new Error('tried to resolve a null currentQueryDefer');
          }
          currentQueryDefer.resolve(flatten_default()(suggestionModifications));
          currentQueryDefer = currentQuery = suggestionModifications = null;
        }
      }
    });
    main_wrappers.push({
      isRelevantTo(connection) {
        return Object.keys(providers).length > 0 && !!connection.url.match(/^\/cloudsearch\/request\?/) && connection.params.client == 'gmail' && connection.params.gs_ri == 'gmail';
      },
      originalSendBodyLogger(connection, body) {
        const parsedBody = querystring_es3.parse(body);
        if (!parsedBody.request) {
          return;
        }
        const query = JSON.parse(parsedBody.request)[2];
        if (!query) {
          return;
        }
        currentQuery = query;
        if (currentQueryDefer) currentQueryDefer.resolve();
        currentQueryDefer = connection._defer = defer();
        suggestionModifications = [];
        triggerEvent({
          type: 'suggestionsRequest',
          query: currentQuery
        });
      },
      async responseTextChanger(connection, responseText) {
        if (connection._defer && connection.status === 200) {
          const modifications = await connection._defer.promise;
          if (modifications) {
            return (0,modify_suggestions/* default */.Z)(responseText, modifications);
          }
        }
        return responseText;
      }
    });
  }
  {
    // TODO: simplify this code
    // the triggerEvent call should happen in the requestChanger callback
    // and a lot of these state variables can be stored in the closure
    // Search query replacer.
    // The content script tells us search terms to watch for. Whenever we see a
    // search query containing the term, we delay it being sent out, trigger an
    // event containing the full query, and wait for a response event from the
    // content script that contains a new query to substitute in.
    const customSearchTerms = [];
    let queryReplacement;
    document.addEventListener('inboxSDKcreateCustomSearchTerm', function (event) {
      customSearchTerms.push(event.detail.term);
    });
    document.addEventListener('inboxSDKsearchReplacementReady', function (event) {
      if (queryReplacement.query === event.detail.query) {
        queryReplacement.newQuery.resolve(event.detail.newQuery);
      }
    });

    // classic Gmail API intercept
    js_frame_wrappers.push({
      isRelevantTo: function (connection) {
        let customSearchTerm;
        const params = connection.params;
        if (connection.method === 'POST' && params.search && params.view === 'tl' && connection.url.match(/^\?/) && params.q && (customSearchTerm = intersection_default()(customSearchTerms, quotedSplit(params.q))[0])) {
          if (queryReplacement && queryReplacement.query === params.q && queryReplacement.start != params.start) {
            // If this is the same query that was made last, but just for a
            // different page, then re-use the replacement query we got last time.
            // Don't wait on the extension to come up with it again (and risk it
            // giving an inconsistent answer between pages).
            connection._queryReplacement = queryReplacement;
            // Mark the old queryReplacement with this page now so we can tell on
            // a later request whether the page was changed or the list refresh
            // button was hit.
            queryReplacement.start = params.start;
          } else {
            if (queryReplacement) {
              // Resolve the old one with something because no one else is going
              // to after it's replaced in a moment.
              queryReplacement.newQuery.resolve(queryReplacement.query);
            }
            queryReplacement = connection._queryReplacement = {
              term: customSearchTerm,
              query: params.q,
              start: params.start,
              newQuery: defer()
            };
            triggerEvent({
              type: 'searchQueryForReplacement',
              term: customSearchTerm,
              query: params.q
            });
          }
          return true;
        }
        return false;
      },
      requestChanger: function (connection, request) {
        return connection._queryReplacement.newQuery.promise.then(function (newQuery) {
          const newParams = clone_default()(connection.params);
          newParams.q = newQuery;
          return {
            method: request.method,
            url: '?' + (0,querystring_es3.stringify)(newParams),
            body: request.body
          };
        });
      }
    });

    // newer, sync API based request intercept
    main_wrappers.push({
      isRelevantTo: function (connection) {
        return connection.method === 'POST' && /sync(?:\/u\/\d+)?\/i\/bv/.test(connection.url);
      },
      requestChanger: function (connection, request) {
        let customSearchTerm;
        const body = JSON.parse(request.body);
        let newFormat = false;
        let payload, searchString, pageOffset;
        if (Array.isArray(body)) {
          newFormat = true;
          payload = body[0];
          searchString = payload[3];
          pageOffset = payload[9];
        } else {
          payload = body[1];
          searchString = payload[4];
          pageOffset = payload[10];
        }
        const isSyncAPISearchWithCustomTerm = payload[newFormat ? 0 : 1] === 79 && typeof searchString === 'string' && (customSearchTerm = intersection_default()(customSearchTerms, quotedSplit(searchString))[0]);
        if (!isSyncAPISearchWithCustomTerm) return Promise.resolve(request);
        if (queryReplacement && queryReplacement.query === searchString && queryReplacement.start != pageOffset) {
          // If this is the same query that was made last, but just for a
          // different page, then re-use the replacement query we got last time.
          // Don't wait on the extension to come up with it again (and risk it
          // giving an inconsistent answer between pages).
          connection._queryReplacement = queryReplacement;
          // Mark the old queryReplacement with this page now so we can tell on
          // a later request whether the page was changed or the list refresh
          // button was hit.
          queryReplacement.start = pageOffset;
        } else {
          if (queryReplacement) {
            // Resolve the old one with something because no one else is going
            // to after it's replaced in a moment.
            queryReplacement.newQuery.resolve(queryReplacement.query);
          }
          queryReplacement = connection._queryReplacement = {
            term: customSearchTerm,
            query: searchString,
            start: pageOffset,
            newQuery: defer()
          };
          triggerEvent({
            type: 'searchQueryForReplacement',
            term: customSearchTerm,
            query: searchString
          });
        }
        return connection._queryReplacement.newQuery.promise.then(function (newQuery) {
          if (newFormat) {
            body[0][3] = newQuery;
          } else {
            body[1][4] = newQuery;
          }
          return {
            method: request.method,
            url: request.url,
            body: JSON.stringify(body)
          };
        });
      }
    });
  }
  {
    // Search results replacer.
    // The content script tells us a search query to watch for. Whenever we see
    // the search query, trigger an event containing the query, trigger an
    // event containing the response, and then wait for a response event from
    // the content script that contains new results to substitute in.
    const customSearchQueries = [];
    let customListJob;
    document.addEventListener('inboxSDKcustomListRegisterQuery', event => {
      customSearchQueries.push(event.detail.query);
    });
    document.addEventListener('inboxSDKcustomListNewQuery', event => {
      if (customListJob.query === event.detail.query && customListJob.start === event.detail.start) {
        const {
          newQuery,
          newStart
        } = event.detail;
        customListJob.newRequestParams.resolve({
          query: newQuery,
          start: newStart
        });
      }
    });
    document.addEventListener('inboxSDKcustomListResults', event => {
      if (customListJob.query === event.detail.query) {
        customListJob.newResults.resolve(event.detail.newResults);
      }
    });
    js_frame_wrappers.push({
      isRelevantTo: function (connection) {
        const params = connection.params;
        if (connection.method === 'POST' && params.search && params.view === 'tl' && connection.url.match(/^\?/) && params.q && !params.act && find_default()(customSearchQueries, x => x === params.q)) {
          if (customListJob) {
            // Resolve the old one with something because no one else is going
            // to after it's replaced in a moment.
            customListJob.newRequestParams.resolve({
              query: customListJob.query,
              start: customListJob.start
            });
            customListJob.newResults.resolve(null);
          }
          customListJob = connection._customListJob = {
            query: params.q,
            start: +params.start,
            newRequestParams: defer(),
            newResults: defer()
          };
          triggerEvent({
            type: 'searchForReplacement',
            query: customListJob.query,
            start: customListJob.start
          });
          return true;
        }
        return false;
      },
      requestChanger: function (connection, request) {
        return connection._customListJob.newRequestParams.promise.then(_ref9 => {
          let {
            query,
            start
          } = _ref9;
          const newParams = clone_default()(connection.params);
          newParams.q = query;
          newParams.start = start;
          return {
            method: request.method,
            url: '?' + (0,querystring_es3.stringify)(newParams),
            body: request.body
          };
        });
      },
      responseTextChanger: function (connection, response) {
        triggerEvent({
          type: 'searchResultsResponse',
          query: connection._customListJob.query,
          start: connection._customListJob.start,
          response
        });
        return connection._customListJob.newResults.promise.then(newResults => newResults === null ? response : newResults);
      }
    });
    // Sync API-based custom thread list interception
    main_wrappers.push({
      isRelevantTo: function (connection) {
        if (/sync(?:\/u\/\d+)?\/i\/bv/.test(connection.url)) {
          if (customListJob) {
            // Resolve the old one with something because no one else is going
            // to after it's replaced in a moment.
            customListJob.newRequestParams.resolve({
              query: customListJob.query,
              start: customListJob.start
            });
            customListJob.newResults.resolve(null);
          }
          return true;
        }
        return false;
      },
      requestChanger: async function (connection, request) {
        if (request.body) {
          const parsedBody = JSON.parse(request.body);
          const newFormat = Array.isArray(parsedBody);
          // we are a search!
          const searchQuery = (newFormat ? parsedBody && parsedBody[0] && parsedBody[0][3] : parsedBody && parsedBody[1] && parsedBody[1][4]) || '';
          if (find_default()(customSearchQueries, x => x === searchQuery)) {
            customListJob = connection._customListJob = {
              query: searchQuery,
              start: newFormat ? parsedBody[0][9] : parsedBody[1][10],
              newRequestParams: defer(),
              newResults: defer()
            };
            triggerEvent({
              type: 'searchForReplacement',
              query: customListJob.query,
              start: customListJob.start
            });
            return connection._customListJob.newRequestParams.promise.then(_ref10 => {
              let {
                query,
                start
              } = _ref10;
              if (newFormat) {
                parsedBody[0][3] = query;
                parsedBody[0][9] = start;
              } else {
                parsedBody[1][4] = query;
                parsedBody[1][10] = start;
              }
              return {
                method: request.method,
                url: request.url,
                body: JSON.stringify(parsedBody)
              };
            });
          }
        }
        return request;
      },
      responseTextChanger: async function (connection, response) {
        if (connection._customListJob) {
          triggerEvent({
            type: 'searchResultsResponse',
            query: connection._customListJob.query,
            start: connection._customListJob.start,
            response
          });
          return connection._customListJob.newResults.promise.then(newResults => newResults === null ? response : newResults);
        } else {
          return response;
        }
      }
    });
  }
  // sync token savers
  {
    const saveBTAIHeader = header => {
      document.head.setAttribute('data-inboxsdk-btai-header', header);
      triggerEvent({
        type: 'btaiHeaderReceived'
      });
    };
    main_wrappers.push({
      isRelevantTo(connection) {
        return /sync(?:\/u\/\d+)?\//.test(connection.url) && !document.head.hasAttribute('data-inboxsdk-btai-header');
      },
      originalSendBodyLogger(connection) {
        if (connection.headers['X-Gmail-BTAI']) {
          saveBTAIHeader(connection.headers['X-Gmail-BTAI']);
        }
      }
    });
    const saveXsrfTokenHeader = header => {
      document.head.setAttribute('data-inboxsdk-xsrf-token', header);
      triggerEvent({
        type: 'xsrfTokenHeaderReceived'
      });
    };
    main_wrappers.push({
      isRelevantTo(connection) {
        return /sync(?:\/u\/\d+)?\//.test(connection.url) && !document.head.hasAttribute('data-inboxsdk-xsrf-token');
      },
      originalSendBodyLogger(connection) {
        if (connection.headers['X-Framework-Xsrf-Token']) {
          saveXsrfTokenHeader(connection.headers['X-Framework-Xsrf-Token']);
        }
      }
    });
  }

  // Google API request header values
  {
    // harcoding a value observed across multiple accounts to start with.
    // Will be updated when we see a request, in case Gmail has changed it.
    let googleApiKey = 'AIzaSyBm7aDMG9actsWSlx-MvrYsepwdnLgz69I';
    document.addEventListener('inboxSDKgetGoogleRequestHeaders', () => {
      const authorizationHeader = window.gapi.auth.getAuthHeaderValueForFirstParty([]);
      const headers = {
        authorization: authorizationHeader,
        'x-goog-api-key': googleApiKey
      };
      document.head.setAttribute('data-inboxsdk-google-headers', JSON.stringify(headers));
    });
    main_wrappers.push({
      isRelevantTo(connection) {
        // check for absolute URLs going to a google domain
        if (connection.url.startsWith('https://')) {
          const url = new URL(connection.url);
          return url.hostname.endsWith('.google.com');
        }
        return false;
      },
      originalSendBodyLogger(connection) {
        if (connection.headers['X-Goog-Api-Key']) {
          googleApiKey = connection.headers['X-Goog-Api-Key'];
        }
      }
    });
  }
}
function triggerEvent(detail) {
  document.dispatchEvent(new CustomEvent('inboxSDKajaxIntercept', {
    bubbles: true,
    cancelable: false,
    detail
  }));
}
function stringifyComposeParams(inComposeParams) {
  const composeParams = clone_default()(inComposeParams);
  const string = `=${stringifyComposeRecipientParam(composeParams.to, 'to')}&=${stringifyComposeRecipientParam(composeParams.cc, 'cc')}&=${stringifyComposeRecipientParam(composeParams.bcc, 'bcc')}`;
  delete composeParams.to;
  delete composeParams.bcc;
  delete composeParams.cc;
  return string + '&' + querystring_es3.stringify(composeParams);
}
function stringifyComposeRecipientParam(value, paramType) {
  let string = '';
  if (Array.isArray(value)) {
    for (let ii = 0; ii < value.length; ii++) {
      string += `&${paramType}=${encodeURIComponent(value[ii])}`;
    }
  } else {
    string += `&${paramType}=${encodeURIComponent(value)}`;
  }
  return string;
}

/***/ }),

/***/ 7131:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_116468__) => {

"use strict";
/* harmony export */ __nested_webpack_require_116468__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupGmonkeyHandler)
/* harmony export */ });
function setupGmonkeyHandler() {
  const gmonkeyPromise = setupGmonkey();
  document.addEventListener('inboxSDKtellMeIsConversationViewDisabled', function () {
    gmonkeyPromise.then(gmonkey => {
      const answer = gmonkey.isConversationViewDisabled();
      const event = document.createEvent('CustomEvent');
      event.initCustomEvent('inboxSDKgmonkeyResponse', false, false, answer);
      document.dispatchEvent(event);
    });
  });
  document.addEventListener('inboxSDKtellMeCurrentThreadId', function (event) {
    let threadId;
    if (event.detail.isPreviewedThread) {
      const rows = Array.from(document.querySelectorAll('[gh=tl] tr.aps'));
      if (rows.length > 0) {
        const elementWithId = rows.map(row => row.querySelector('[data-thread-id]')).filter(Boolean)[0];
        if (elementWithId) {
          threadId = elementWithId.getAttribute('data-thread-id');
        } else {
          threadId = rows[0].getAttribute('data-inboxsdk-threadid');
        }
      }
    } else {
      threadId = window.gmonkey?.v2?.getCurrentThread?.()?.getThreadId();
    }
    if (threadId) {
      // hash is included in the sync id route url, so we also need to take it out
      threadId = threadId.replace('#', '');
      event.target.setAttribute('data-inboxsdk-currentthreadid', threadId);
    }
  });
}
function setupGmonkey() {
  return new Promise(resolve => {
    function check() {
      if (!window.gmonkey) {
        setTimeout(check, 500);
      } else {
        window.gmonkey.load('2.0', resolve);
      }
    }
    check();
  });
}

/***/ }),

/***/ 5895:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_118309__) => {

"use strict";
__nested_webpack_require_118309__.r(__nested_webpack_exports__);
/* harmony export */ __nested_webpack_require_118309__.d(__nested_webpack_exports__, {
/* harmony export */   "error": () => (/* binding */ error),
/* harmony export */   "eventSdkPassive": () => (/* binding */ eventSdkPassive)
/* harmony export */ });
function error(err, details) {
  if (!err) {
    err = new Error('No error given');
  }
  console.error('Error in injected script', err, details);
  try {
    JSON.stringify(details);
  } catch (e) {
    details = '<failed to jsonify>';
  }
  const errorProperties = {};
  for (const name in err) {
    if (Object.prototype.hasOwnProperty.call(err, name)) {
      try {
        const value = err[name];
        JSON.stringify(value);
        errorProperties[name] = value;
      } catch (err) {
        // ignore
      }
    }
  }
  if (Object.keys(errorProperties).length > 0) {
    details = {
      errorProperties,
      details
    };
  }
  document.dispatchEvent(new CustomEvent('inboxSDKinjectedError', {
    bubbles: false,
    cancelable: false,
    detail: {
      message: err && err.message,
      stack: err && err.stack,
      details
    }
  }));
}
function eventSdkPassive(name, details, sensitive) {
  try {
    JSON.stringify(details);
  } catch (e) {
    details = '<failed to jsonify>';
  }
  document.dispatchEvent(new CustomEvent('inboxSDKinjectedEventSdkPassive', {
    bubbles: false,
    cancelable: false,
    detail: {
      name,
      details,
      sensitive
    }
  }));
}

/***/ }),

/***/ 2726:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_119908__) => {

"use strict";

// EXPORTS
__nested_webpack_require_119908__.d(__nested_webpack_exports__, {
  "Z": () => (/* binding */ setupDataExposer)
});

// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __nested_webpack_require_119908__(3311);
var find_default = /*#__PURE__*/__nested_webpack_require_119908__.n(find);
// EXTERNAL MODULE: ./src/injected-js/injected-logger.ts
var injected_logger = __nested_webpack_require_119908__(5895);
;// CONCATENATED MODULE: ./src/platform-implementation-js/lib/wait-for.ts
class WaitForError extends Error {
  name = 'WaitForError';
  constructor() {
    super('waitFor timeout');
  }
}

/**
 * @param condition a function that returns the value to wait for, or falsey if it's not ready yet
 * @throws {WaitForError} if the condition is not met within the timeout
 */
function waitFor(condition) {
  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 120 * 1000;
  let steptime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
  // make this error here so we have a sensible stack.
  const timeoutError = new WaitForError();
  return new Promise(function (resolve, reject) {
    let waited = 0;
    function step() {
      try {
        const result = condition();
        if (result) {
          resolve(result);
        } else {
          if (waited >= timeout) {
            reject(timeoutError);
          } else {
            waited += steptime;
            setTimeout(step, steptime);
          }
        }
      } catch (e) {
        reject(e);
      }
    }
    setTimeout(step, 1);
  });
}
;// CONCATENATED MODULE: ./src/injected-js/setup-data-exposer.ts



function stupidToBool(stupid) {
  switch ('' + stupid) {
    case '1':
    case 't':
    case 'true':
      return true;
    default:
      return false;
  }
}
function getSettingValue(settings, name) {
  var entry = find_default()(settings, setting => setting[0] === name);
  return entry ? stupidToBool(entry[1]) : false;
}
function getContext() {
  let context = __nested_webpack_require_119908__.g;
  try {
    // our current tab has globals defined
    if (context.GLOBALS) return context;

    // we don't, let's see if we have access to opener (i.e. we are a new compose/thread view)
    if (__nested_webpack_require_119908__.g.opener && __nested_webpack_require_119908__.g.opener.top) {
      // try to get href
      // if the opener is not gmail (i.e. you clicked on a mailto link on craigslist) then this will throw an error
      __nested_webpack_require_119908__.g.opener.top.location.href;
      context = __nested_webpack_require_119908__.g.opener.top;
    }
  } catch (err) {
    context = __nested_webpack_require_119908__.g; //we got an error from requesting global.opener.top.location.href;
  }

  return context;
}
function setupDataExposer() {
  let context;
  waitFor(() => {
    context = getContext();
    return context && (context.GLOBALS || context.gbar);
  }).then(() => {
    if (!context) return;
    var userEmail = context.GLOBALS ? context.GLOBALS[10] : context.gbar._CONFIG[0][10][5];
    document.head.setAttribute('data-inboxsdk-user-email-address', userEmail);
    var userLanguage = context.GLOBALS ? context.GLOBALS[4].split('.')[1] : context.gbar._CONFIG[0][0][4];
    document.head.setAttribute('data-inboxsdk-user-language', userLanguage);
    document.head.setAttribute('data-inboxsdk-using-sync-api', context.GM_SPT_ENABLED);
    if (context.GLOBALS) {
      // Gmail
      document.head.setAttribute('data-inboxsdk-ik-value', context.GLOBALS[9]);
      document.head.setAttribute('data-inboxsdk-action-token-value', context.GM_ACTION_TOKEN);
      var globalSettingsHolder = find_default()(context.GLOBALS[17], item => item[0] === 'p');
      if (!globalSettingsHolder) {
        // global settings doesn't exist on gmail v2, so we don't need to log this anymore
        return;
      } else {
        var globalSettings = globalSettingsHolder[1];
        {
          var previewPaneLabEnabled = getSettingValue(globalSettings, 'bx_lab_1252');
          var previewPaneEnabled = getSettingValue(globalSettings, 'bx_spa');
          var previewPaneVertical = getSettingValue(globalSettings, 'bx_spo');
          var previewPaneMode = previewPaneLabEnabled && previewPaneEnabled ? previewPaneVertical ? 'vertical' : 'horizontal' : 'none';
          document.head.setAttribute('data-inboxsdk-user-preview-pane-mode', previewPaneMode);
        }
      }
    } else {
      // Inbox
      const preloadDataSearchString = 'window.BT_EmbeddedAppData=[';
      const preloadScript = find_default()(document.querySelectorAll('script:not([src])'), script => script.text && script.text.slice(0, 500).indexOf(preloadDataSearchString) > -1);
      if (!preloadScript) {
        injected_logger.error(new Error('Could not read preloaded BT_EmbeddedAppData'));
      } else {
        const {
          text
        } = preloadScript;
        const firstBracket = text.indexOf('window.BT_EmbeddedAppData=[');
        let lastBracket = text.indexOf(']\n;', firstBracket);
        if (lastBracket === -1) {
          // I have only seen the case where there is a new line between the
          // closing bracket and the semicolon, but want to be defensive in
          // case that changes.
          lastBracket = text.indexOf('];', firstBracket);
        }
        const preloadData = JSON.parse(text.slice(firstBracket + preloadDataSearchString.length - 1, lastBracket + 1));
        const ikValue = preloadData[11];
        if (typeof ikValue !== 'string') {
          injected_logger.error(new Error('Could not find valid ikValue'));
        } else {
          document.head.setAttribute('data-inboxsdk-ik-value', ikValue);
        }
        const xsrfToken = preloadData[12];
        if (typeof xsrfToken !== 'string') {
          injected_logger.error(new Error('Could not find valid xsrfToken'));
        } else {
          document.head.setAttribute('data-inboxsdk-xsrf-token', xsrfToken);
        }
      }
    }
  }).catch(err => {
    function getStatus() {
      return {
        hasGLOBALS: !!context.GLOBALS,
        hasGbar: !!context.gbar
      };
    }
    var startStatus = getStatus();
    var waitTime = 180 * 1000;
    setTimeout(() => {
      var laterStatus = getStatus();
      injected_logger.eventSdkPassive('waitfor global data', {
        startStatus,
        waitTime,
        laterStatus
      });
    }, waitTime);
    throw err;
  }).catch(injected_logger.error);
}

/***/ }),

/***/ 8892:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_126358__) => {

"use strict";
/* harmony export */ __nested_webpack_require_126358__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupErrorSilencer)
/* harmony export */ });
function setupErrorSilencer() {
  var oldErrorHandlers = [];
  document.addEventListener('inboxSDKsilencePageErrors', function () {
    oldErrorHandlers.push(window.onerror);
    window.onerror = function () {
      if (false) { var _len, args, _key; }
      return true;
    };
  });
  document.addEventListener('inboxSDKunsilencePageErrors', function () {
    window.onerror = oldErrorHandlers.pop();
  });
}

/***/ }),

/***/ 7835:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_127048__) => {

"use strict";
/* harmony export */ __nested_webpack_require_127048__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupEventReemitter)
/* harmony export */ });
/* eslint-disable @typescript-eslint/no-empty-function */
function setupEventReemitter() {
  // Webkit has bugs that stop certain types of events from being created. We
  // can manually fake creation of those events, but we have to do it from
  // inside the page's script if we want the page's script to see the modified
  // properties.
  // https://bugs.webkit.org/show_bug.cgi?id=16735
  // https://code.google.com/p/chromium/issues/detail?id=327853
  document.addEventListener('inboxsdk_event_relay', function (event) {
    const newEvent = document.createEvent('Events');
    newEvent.initEvent(event.detail.type, event.detail.bubbles, event.detail.cancelable);
    Object.assign(newEvent, event.detail.props);
    if (event.detail.dataTransfer) {
      const {
        files,
        fileNames
      } = event.detail.dataTransfer;
      if (fileNames) {
        fileNames.forEach((fileName, i) => {
          const file = files[i];
          if (typeof file.name !== 'string') {
            file.name = fileName;
          }
        });
      }
      newEvent.dataTransfer = {
        dropEffect: 'none',
        effectAllowed: 'all',
        files,
        items: files.map((_ref, i) => {
          let {
            type
          } = _ref;
          return {
            kind: 'file',
            type,
            getAsFile() {
              return files[i];
            },
            getAsString() {
              throw new Error('getAsString not supported');
            }
          };
        }),
        types: ['Files'],
        getData() {
          return '';
        },
        setData() {},
        setDragImage() {}
      };
    }
    event.target.dispatchEvent(newEvent);
  });
}

/***/ }),

/***/ 3060:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_129015__) => {

"use strict";
/* harmony export */ __nested_webpack_require_129015__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupCustomViewEventAssassin)
/* harmony export */ });
/* harmony import */ var ud__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_129015__(1010);
/* harmony import */ var lodash_includes__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_129015__(4721);
/* harmony import */ var lodash_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_129015__.n(lodash_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var closest_ng__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_129015__(4681);
/* harmony import */ var closest_ng__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_129015__.n(closest_ng__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _injected_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_129015__(5895);
/* module decorator */ module = __nested_webpack_require_129015__.hmd(module);




function md(value) {
  return {
    value,
    configurable: true
  };
}

// These are basically all the keys that trigger some action in thread list
// views and thread views that we don't want to be triggerable while a custom
// view is open. Key combos which affect things still visible on the screen or
// navigate to a new view are still allowed.

const blockedAnyModKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End', 'Enter'];

// These are only necessary for Safari
const blockedKeyIdentifiers = ['Left', 'Right', 'Up', 'Down'];
const blockedAnyModCharacters = '!#[]{}_+=-;:\r\n1234567890`~';
const blockedNoModCharacters = ',xsyemrafz.ujkpnl';
const blockedShiftCharacters = 'parfniut';
function shouldBlockEvent(event) {
  if (!document.body.classList.contains('inboxsdk__custom_view_active')) {
    return false;
  }
  const target = event.target;
  const key = event.key || /* safari*/String.fromCharCode(event.which || event.keyCode);

  // Block all escape key presses inside a custom view, even when an input
  // is focused.
  if (event.key === 'Escape' && closest_ng__WEBPACK_IMPORTED_MODULE_1___default()(target, '.inboxsdk__custom_view')) {
    return true;
  }
  if (lodash_includes__WEBPACK_IMPORTED_MODULE_0___default()(blockedAnyModKeys, key) || /* safari */lodash_includes__WEBPACK_IMPORTED_MODULE_0___default()(blockedKeyIdentifiers, event.keyIdentifier) || lodash_includes__WEBPACK_IMPORTED_MODULE_0___default()(blockedAnyModCharacters, key) || !event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey && lodash_includes__WEBPACK_IMPORTED_MODULE_0___default()(blockedNoModCharacters, key) || event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey && lodash_includes__WEBPACK_IMPORTED_MODULE_0___default()(blockedShiftCharacters, key.toLowerCase())) {
    if (
    // Gmail already ignores events originating in these elements even if
    // they were made by an extension.
    closest_ng__WEBPACK_IMPORTED_MODULE_1___default()(target, 'input, textarea, button, [contenteditable]') ||
    // Gmail ignores events originating in its own interactive elements
    // which tend to have certain role attributes.
    !closest_ng__WEBPACK_IMPORTED_MODULE_1___default()(target, '.inboxsdk__custom_view') && closest_ng__WEBPACK_IMPORTED_MODULE_1___default()(target, '[role=button], [role=link]')) {
      return false;
    }
    return true;
  }
  return false;
}
const handler = (0,ud__WEBPACK_IMPORTED_MODULE_2__.defn)(module, function (event) {
  try {
    // If the key is in a blacklist and it originated while a custom view is
    // present, then maim the event object before Gmail or Inbox sees it.
    if (shouldBlockEvent(event)) {
      Object.defineProperties(event, {
        altKey: md(false),
        ctrlKey: md(false),
        shiftKey: md(false),
        metaKey: md(false),
        charCode: md(92),
        code: md('Backslash'),
        key: md('\\'),
        keyCode: md(92),
        which: md(92)
      });
    }
  } catch (err) {
    _injected_logger__WEBPACK_IMPORTED_MODULE_3__.error(err);
  }
});
function setupCustomViewEventAssassin() {
  document.addEventListener('keydown', handler, true);
}

/***/ }),

/***/ 5290:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_133275__) => {

"use strict";
/* harmony export */ __nested_webpack_require_133275__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupInboxCustomViewLinkFixer)
/* harmony export */ });
/* harmony import */ var closest_ng__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_133275__(4681);
/* harmony import */ var closest_ng__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_133275__.n(closest_ng__WEBPACK_IMPORTED_MODULE_0__);

function setupInboxCustomViewLinkFixer() {
  const allowedStartTerms = new Set();
  document.addEventListener('inboxSDKregisterAllowedHashLinkStartTerm', function (event) {
    const term = event.detail.term;
    allowedStartTerms.add(term);
  });
  document.addEventListener('click', function (event) {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    const anchor = closest_ng__WEBPACK_IMPORTED_MODULE_0___default()(target, 'a[href^="#"]');
    if (!anchor || !(anchor instanceof HTMLAnchorElement)) return;
    const m = /^#([^/]+)/.exec(anchor.getAttribute('href') || '');
    if (!m) return;
    const startTerm = m[1];
    if (!allowedStartTerms.has(startTerm)) return;

    // eslint-disable-next-line @typescript-eslint/no-empty-function
    event.preventDefault = () => {};
  }, true);
}

/***/ }),

/***/ 7012:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_134647__) => {

"use strict";
/* harmony export */ __nested_webpack_require_134647__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ setupPushStateListener)
/* harmony export */ });
function setupPushStateListener() {
  const origPushState = history.pushState;
  history.pushState = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const ret = origPushState.apply(this, args);
    document.dispatchEvent(new CustomEvent('inboxSDKpushState', {
      bubbles: false,
      cancelable: false,
      detail: {
        args
      }
    }));
    return ret;
  };
}

/***/ }),

/***/ 7640:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_135413__) => {

"use strict";
/* harmony export */ __nested_webpack_require_135413__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ xhrHelper)
/* harmony export */ });
function xhrHelper() {
  document.addEventListener('inboxSDKpageAjax', function (event) {
    const id = event.detail.id;
    const opts = {
      url: event.detail.url,
      method: event.detail.method,
      headers: event.detail.headers,
      xhrFields: event.detail.xhrFields,
      data: event.detail.data
    };

    // It's important to use fetch when possible because it's needed for
    // getDownloadURL() in Gmail v2: Gmail v2's ServiceWorker in Chrome causes
    // xhr.responseURL to have the wrong value (possibly a Chrome bug).
    (async () => {
      const response = await fetch(opts.url, {
        method: opts.method || 'GET',
        credentials: 'include'
      });
      document.dispatchEvent(new CustomEvent('inboxSDKpageAjaxDone', {
        bubbles: false,
        cancelable: false,
        detail: {
          id,
          error: false,
          text: await response.text(),
          responseURL: response.url
        }
      }));
    })().catch(err => {
      document.dispatchEvent(new CustomEvent('inboxSDKpageAjaxDone', {
        bubbles: false,
        cancelable: false,
        detail: {
          id,
          error: true,
          message: err && err.message,
          stack: err && err.stack,
          status: err && err.xhr && err.xhr.status
        }
      }));
    });
  });
}

/***/ }),

/***/ 6139:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_137010__) => {

"use strict";
/* harmony export */ __nested_webpack_require_137010__.d(__nested_webpack_exports__, {
/* harmony export */   "Ae": () => (/* binding */ extractThreadsFromDeserialized),
/* harmony export */   "E3": () => (/* binding */ cleanupPeopleLine),
/* harmony export */   "GE": () => (/* binding */ deserializeArray),
/* harmony export */   "MA": () => (/* binding */ extractThreads),
/* harmony export */   "bd": () => (/* binding */ extractMessages),
/* harmony export */   "qC": () => (/* binding */ serialize),
/* harmony export */   "vB": () => (/* binding */ deserialize)
/* harmony export */ });
/* unused harmony exports interpretSentEmailResponse, extractGmailMessageIdFromSentEmail, extractGmailThreadIdFromSentEmail, extractGmailThreadIdFromMessageIdSearch, rewriteSingleQuotes, readDraftId, replaceThreadsInResponse, extractMessageIdsFromThreadBatchRequest */
/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_137010__(5564);
/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_137010__.n(lodash_flatten__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_last__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_137010__(928);
/* harmony import */ var lodash_last__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_137010__.n(lodash_last__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var transducers_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_137010__(1095);
/* harmony import */ var transducers_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_137010__.n(transducers_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_html_to_text__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_137010__(9865);
/* harmony import */ var _common_assert__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_137010__(9817);






function interpretSentEmailResponse(responseString) {
  const emailSentArray = deserialize(responseString).value;
  const gmailMessageId = extractGmailMessageIdFromSentEmail(emailSentArray);
  const gmailThreadId = extractGmailThreadIdFromSentEmail(emailSentArray) || gmailMessageId;
  if (!gmailMessageId || !gmailThreadId) {
    throw new Error('Failed to read email response');
  }
  return {
    threadID: gmailThreadId,
    messageID: gmailMessageId
  };
}
function extractGmailMessageIdFromSentEmail(emailSentArray) {
  const messageIdArrayMarker = 'a';
  const messageIdArray = _searchArray(emailSentArray, messageIdArrayMarker, markerArray => markerArray.length > 3 && Array.isArray(markerArray[3]) && markerArray[3].length > 0);
  if (!messageIdArray) {
    return null;
  }
  return messageIdArray[3][0];
}
function extractGmailThreadIdFromSentEmail(emailSentArray) {
  const threadIdArrayMarker = 'csd';
  const threadIdArray = _searchArray(emailSentArray, threadIdArrayMarker, function (markerArray) {
    return markerArray.length == 3 && Array.isArray(markerArray[2]) && markerArray[2].length > 5;
  });
  if (!threadIdArray) {
    return null;
  }
  return threadIdArray[1];
}
function extractGmailThreadIdFromMessageIdSearch(responseString) {
  const threadResponseArray = deserialize(responseString).value;
  const threadIdArrayMarker = 'cs';
  const threadIdArray = _searchArray(threadResponseArray, threadIdArrayMarker, markerArray => markerArray[0] === 'cs' && markerArray.length > 20);
  if (!threadIdArray) {
    return null;
  }
  return threadIdArray[1];
}
function rewriteSingleQuotes(s) {
  // The input string contains unquoted, double-quoted, and single-quoted
  // parts. Parse the string for these parts, and transform the single-
  // quoted part into a double-quoted part by swapping the quotes, and
  // escaping any double-quotes inside of it with backslashes.

  // i is our position in the input string. result is our result string that
  // we'll copy the parts of the input to as we interpret them.
  let i = 0;
  const resultParts = [];
  // eslint-disable-next-line no-constant-condition
  while (true) {
    // Find the position of the next singly or doubly quoted part.
    // `i` is increasing monotonically every round of this loop, and the loop
    // ends as soon as no matches are found after the `i`th position in the
    // string, so this while loop can't be infinite.
    const nextQuoteIndex = findNextQuote(s, i);
    if (nextQuoteIndex < 0) {
      resultParts.push(s.substr(i));
      break;
    }
    // Copy the unquoted part preceding the quoted section we found into the
    // result, and put a double-quote into the result to begin the quoted
    // section we found.
    resultParts.push(s.substr(i, nextQuoteIndex - i));
    resultParts.push('"');
    i = nextQuoteIndex + 1;
    if (s[nextQuoteIndex] === '"') {
      // Find the next quotation mark not preceded by a backslash.
      const nextDoubleQuoteIndex = findNextUnescapedCharacter(s, i, '"');
      if (nextDoubleQuoteIndex < 0) {
        throw new Error('Unclosed double quote');
      }
      // Add that entire double-quoted part to the result.
      resultParts.push(s.slice(i, nextDoubleQuoteIndex + 1));
      i = nextDoubleQuoteIndex + 1;
    } else {
      // Same logic as above, but for a single-quoted part.
      const nextSingleQuoteIndex = findNextUnescapedCharacter(s, i, "'");
      if (nextSingleQuoteIndex < 0) {
        throw new Error('Unclosed single quote');
      }
      // Escape all double-quotes inside the part, un-escape all single-quotes
      // inside the part, and then write it out into the result with the ending
      // single-quote replaced with a double-quote.
      const part = s.slice(i, nextSingleQuoteIndex).replace(/"/g, '\\"').replace(/\\'/g, "'");
      resultParts.push(part);
      resultParts.push('"');
      i = nextSingleQuoteIndex + 1;
    }
  }
  return resultParts.join('');
}
function findNextQuote(s, start) {
  for (let i = start, len = s.length; i < len; i++) {
    if (s[i] === '"' || s[i] === "'") {
      return i;
    }
  }
  return -1;
}
function findNextUnescapedCharacter(s, start, char) {
  for (let i = start, len = s.length; i < len; i++) {
    if (s[i] === '\\') {
      i++;
    } else if (s[i] === char) {
      return i;
    }
  }
  return -1;
}
function deserialize(threadResponseString) {
  const options = {
    includeLengths: false,
    suggestionMode: /^5\n/.test(threadResponseString),
    noArrayNewLines: !/^[,\]]/m.test(threadResponseString),
    includeExplicitNulls: true
  };
  const value = [];
  let pos;
  if (options.suggestionMode) {
    pos = threadResponseString.indexOf("'\n");
    if (pos === -1) {
      throw new Error('Message was missing beginning header');
    }
    pos += 2;
  } else {
    pos = threadResponseString.indexOf('\n\n');
    if (pos === -1) {
      throw new Error('Message was missing beginning newlines');
    }
    pos += 2;
  }
  while (pos < threadResponseString.length) {
    let lineEnd = threadResponseString.indexOf('\n', pos + 1);
    if (lineEnd === -1) {
      lineEnd = threadResponseString.length;
    } else if (threadResponseString[lineEnd - 1] === '\r') {
      // seriously Gmail is crazy. The chunk length only sometimes includes the
      // newline after the chunk length.
      lineEnd += 1;
    }
    const line = threadResponseString.slice(pos, lineEnd);
    let dataLine;
    if (/^\d+\s*$/.test(line)) {
      options.includeLengths = true;
      const length = +line;
      dataLine = threadResponseString.slice(lineEnd, lineEnd + length);
      pos = lineEnd + length;
    } else {
      dataLine = threadResponseString.slice(pos);
      pos = threadResponseString.length;
    }
    value.push(deserializeArray(dataLine));
  }
  return {
    value,
    options
  };
}
function transformUnquotedSections(str, cb) {
  const parts = [];
  let nextQuote;
  let position = 0;
  let inString = false;
  while ((nextQuote = findNextUnescapedCharacter(str, position, '"')) !== -1) {
    if (inString) {
      parts.push(str.slice(position, nextQuote + 1));
    } else {
      parts.push(cb(str.slice(position, nextQuote + 1)));
    }
    position = nextQuote + 1;
    inString = !inString;
  }
  if (inString) {
    throw new Error('string ended inside quoted section');
  }
  parts.push(cb(str.slice(position)));
  return parts.join('');
}
function deserializeArray(value) {
  value = value.replace(/[\r\n\t]/g, '');

  // Change all the singly quoted parts to use double-quotes so that the
  // data can be JSON-decoded instead of eval'd. (Also necessary for the
  // next step.)
  value = rewriteSingleQuotes(value);

  // Fix some things with the data. (It's in a weird minified JSON-like
  // format). Make sure we don't modify any data inside of strings!
  value = transformUnquotedSections(value, match => match.replace(/,\s*(?=,|\])/g, ',null') // fix implied nulls
  .replace(/\[\s*(?=,)/g, '[null') // "
  );

  try {
    return JSON.parse(value, (k, v) => v == null ? undefined : v);
  } catch (err) {
    throw new Error('deserialization error');
  }
}
function serialize(value, options) {
  if (options.suggestionMode) {
    (0,_common_assert__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(options.includeLengths);
    return suggestionSerialize(value, options.includeExplicitNulls);
  }
  return threadListSerialize(value, options);
}
function threadListSerialize(threadResponseArray, options) {
  const {
    includeLengths,
    noArrayNewLines,
    includeExplicitNulls
  } = options;
  let response = ")]}'\n" + (noArrayNewLines && includeLengths ? '' : '\n');
  for (let ii = 0; ii < threadResponseArray.length; ii++) {
    const arraySection = threadResponseArray[ii];
    const arraySectionString = serializeArray(arraySection, noArrayNewLines, includeExplicitNulls);
    if (!includeLengths) {
      response += arraySectionString;
    } else {
      const length = arraySectionString.length + (noArrayNewLines ? 2 : 1);
      response += (noArrayNewLines ? '\n' : '') + length + '\n' + arraySectionString;
    }
  }
  if (!includeLengths) {
    if (!noArrayNewLines) {
      const lines = response.split(/\r|\n/);
      const firstLines = lines.slice(0, -3);
      const lastLines = lines.slice(-3);
      response = firstLines.join('\n');
      response += '\n' + lastLines[0] + lastLines[1].replace(/"/g, "'");
    } else {
      // A 16-digit hexadecimal string is often at the end, but sometimes it
      // has fewer digits.
      response = response.replace(/"([0-9a-f]{8,16})"\]$/, "'$1']");
    }
  }
  return response + (noArrayNewLines && includeLengths ? '\n' : '');
}
function suggestionSerialize(suggestionsArray, includeExplicitNulls) {
  let response = "5\n)]}'\n";
  for (let ii = 0; ii < suggestionsArray.length; ii++) {
    const arraySection = suggestionsArray[ii];
    const arraySectionString = serializeArray(arraySection, false, includeExplicitNulls);
    const length = arraySectionString.length;
    response += length + '\r\n' + arraySectionString;
  }
  return response;
}
function serializeArray(array, noArrayNewLines, includeExplicitNulls) {
  let response = '[';
  for (let ii = 0; ii < array.length; ii++) {
    const item = array[ii];
    let addition;
    if (Array.isArray(item)) {
      addition = serializeArray(item, noArrayNewLines, includeExplicitNulls);
    } else if (item == null) {
      addition = includeExplicitNulls ? 'null' : '';
    } else {
      addition = JSON.stringify(item).replace(/</gim, '\\u003c').replace(/=/gim, '\\u003d').replace(/>/gim, '\\u003e').replace(/&/gim, '\\u0026');
    }
    if (ii > 0) {
      response += ',';
    }
    response += addition;
  }
  response += ']' + (noArrayNewLines ? '' : '\n');
  return response;
}
function readDraftId(response, messageID) {
  const decoded = deserialize(response).value;
  const msgA = t.toArray(decoded, t.compose(t.cat, t.filter(Array.isArray), t.cat, t.filter(x => x[0] === 'ms' && x[1] === messageID), t.take(1), t.map(x => x[60])))[0];
  if (msgA) {
    const match = msgA.match(/^msg-[^:]:(\S+)$/i);
    return match && match[1];
  }
  return null;
}
function replaceThreadsInResponse(response, replacementThreads, _ref) {
  let {
    start,
    total
  } = _ref;
  const {
    value,
    options
  } = deserialize(response);
  const actionResponseMode = value.length === 1 && value[0].length === 2 && typeof value[0][1] === 'string';
  const threadValue = actionResponseMode ? value[0][0].map(x => [x]) : value;

  /*
  threadValue looks like this:
  [
  [ // group
    ["blah", ...], // item
    ["blah", ...]  // item
  ],
  [ // group
    ["blah", ...],
    ["tb", [...]],
    ["tb", [...]]
  ],
  [
    ["tb", [...]],
    ["blah", ...]
  ],
  [
    ["blah", ...],
    ["blah", ...]
  ],
  ]
  threadValue is an array of groups. Each group is an array of items. An item is
  an array which has an identifier string as its first item. Each "tb" item
  contains an array of up to 10 threads. All of the "tb" items will be sequential
  but may overflow to other groups.
  We want to replace all of the "tb" items, while trying to stick close to the
  original structure. We prepare by creating an array of groups that come before
  any groups containing a "tb" item, an array of groups that come after any
  groups containing a "tb" item, an array of items that come before any "tb"
  items in the first "tb" group, and an array of items that come after any "tb"
  items in the last "tb" group. Then we generate the new "tb" items, and splice
  it all back together.
  */

  const preTbGroups = [];
  const postTbGroups = [];
  let preTbItems = [];
  let postTbItems = [];
  let hasSeenTb = false;
  threadValue.forEach(group => {
    let tbSeenInThisGroup = false;
    const preTbGroup = [];
    const postTbGroup = [];
    group.forEach(item => {
      if (total && item[0] === 'ti') {
        if (typeof total === 'number') {
          // does not switch out of 'many'-total mode (we currently never need this).
          item[2] = item[10] = total;
        } else if (total === 'MANY') {
          // large total to ensure it is always larger than the actual
          // number of threads.
          item[2] = item[10] = 100 * 1000;
          // flip response from number-total mode into 'many'-total mode.
          item[3] = 1;
          const query = item[5];
          if (item[6]) {
            item[6][0] = [query, 1];
          } else {
            console.error('replaceThreadsInResponse(): Missing item[6]');
          }
        }
      }
      if (item[0] === 'tb') {
        hasSeenTb = tbSeenInThisGroup = true;
        if (preTbGroup.length) {
          preTbItems = preTbGroup;
        }
        postTbItems = postTbGroup;
      } else if (!hasSeenTb) {
        preTbGroup.push(item);
      } else {
        postTbGroup.push(item);
      }
    });
    if (!tbSeenInThisGroup) {
      if (!hasSeenTb) {
        preTbGroups.push(preTbGroup);
      } else {
        postTbGroups.push(postTbGroup);
      }
    }
  });
  const newTbs = _threadsToTbGroups(replacementThreads, start);
  if (preTbItems.length) {
    newTbs[0] = preTbItems.concat(newTbs[0] || []);
  }
  if (postTbItems.length) {
    if (newTbs.length) {
      newTbs[newTbs.length - 1] = newTbs[newTbs.length - 1].concat(postTbItems);
    } else {
      newTbs.push(postTbItems);
    }
  }
  const parsedNew = flatten([preTbGroups, newTbs, postTbGroups]);
  const allSections = flatten(parsedNew);
  const endSection = last(allSections);
  if (endSection[0] !== 'e') {
    throw new Error('Failed to find end section');
  }
  endSection[1] = allSections.length;
  const fullNew = actionResponseMode ? [[flatten(parsedNew), value[0][1]]] : parsedNew;
  return serialize(fullNew, options);
}
function extractThreads(response) {
  return extractThreadsFromDeserialized(deserialize(response).value);
}
function extractThreadsFromDeserialized(value) {
  if (value.length === 1 && value[0].length === 2 && typeof value[0][1] === 'string') {
    value = [value[0][0]];
  }
  return _extractThreadArraysFromResponseArray(value).map(thread => Object.freeze(Object.defineProperty({
    subject: (0,_common_html_to_text__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(thread[9]),
    shortDate: (0,_common_html_to_text__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(thread[14]),
    timeString: (0,_common_html_to_text__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(thread[15]),
    peopleHtml: cleanupPeopleLine(thread[7]),
    timestamp: thread[16] / 1000,
    isUnread: thread[9].indexOf('<b>') > -1,
    lastEmailAddress: thread[28],
    bodyPreviewHtml: thread[10],
    someGmailMessageIds: [thread[1], thread[2]],
    gmailThreadId: thread[0]
  }, '_originalGmailFormat', {
    value: thread
  })));
}
const _extractMessageIdsFromThreadBatchRequestXf = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().compose((transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat), (transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().filter(item => item[0] === 'cs'), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().map(item => [item[1], item[2]]));
function extractMessageIdsFromThreadBatchRequest(response) {
  const {
    value
  } = deserialize(response);
  return t.toObj(value, _extractMessageIdsFromThreadBatchRequestXf);
}
function cleanupPeopleLine(peopleHtml) {
  // Removes possible headings like "To: " that get added on the Sent page, and
  // removes a class that's specific to the current preview pane setting.
  return peopleHtml.replace(/^[^<]*/, '').replace(/(<span[^>]*) class="[^"]*"/g, '$1');
}
const _extractThreadArraysFromResponseArrayXf = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().compose((transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().filter(item => item[0] === 'tb'), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().map(item => item[2]), (transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat));
function _extractThreadArraysFromResponseArray(threadResponseArray) {
  return transducers_js__WEBPACK_IMPORTED_MODULE_2___default().toArray(threadResponseArray, _extractThreadArraysFromResponseArrayXf);
}
const _extractThreadsFromConversationViewResponseArrayXf = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().compose((transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().filter(item => item[0] === 'cs'), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().map(item => ({
  threadID: item[1],
  messageIDs: item[8]
})));
const _extractMessagesFromResponseArrayXf = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().compose((transducers_js__WEBPACK_IMPORTED_MODULE_2___default().cat), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().filter(item => item[0] === 'ms'), transducers_js__WEBPACK_IMPORTED_MODULE_2___default().map(item => ({
  messageID: item[1],
  date: item[7]
})));
function extractMessages(response) {
  // regular view=cv requests have a top level array length of 1
  // whereas view=cv requests when you refresh Gmail while looking at a thread
  // have a top level array with more elements
  let {
    value
  } = deserialize(response);
  if (value.length === 1) value = value[0];
  const threads = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().toArray(value, _extractThreadsFromConversationViewResponseArrayXf);
  const messages = transducers_js__WEBPACK_IMPORTED_MODULE_2___default().toArray(value, _extractMessagesFromResponseArrayXf);
  const messageMap = {};
  messages.forEach(message => {
    messageMap[message.messageID] = message;
  });
  return threads.map(_ref2 => {
    let {
      threadID,
      messageIDs
    } = _ref2;
    return {
      threadID,
      messages: messageIDs.map(messageID => messageMap[messageID])
    };
  });
}
function _threadsToTbGroups(threads, start) {
  const _threadsToTbGroupsXf = t.compose(t.map(thread => thread._originalGmailFormat), t.partition(10), mapIndexed((threadsChunk, i) => [['tb', start + i * 10, threadsChunk]]));
  return t.toArray(threads, _threadsToTbGroupsXf);
}
function _searchArray(responseArray, marker, markerArrayValidator) {
  const pathArray = _searchObject(responseArray, marker, 100);
  for (let ii = 0; ii < pathArray.length; ii++) {
    const pathToMarkerArray = pathArray[ii].path.slice(0, -1);
    const markerArray = _getArrayValueFromPath(responseArray, pathToMarkerArray);
    if (markerArrayValidator(markerArray)) {
      return markerArray;
    }
  }
}
function _searchObject(element, query, maxDepth) {
  const retVal = [];
  const initialNode = {
    el: element,
    path: []
  };
  const nodeList = [initialNode];
  while (nodeList.length > 0) {
    const node = nodeList.pop();
    if (node.path.length <= maxDepth) {
      if (node.el !== null && typeof node.el === 'object') {
        const keys = Object.keys(node.el);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const newNode = {
            el: node.el[key],
            path: node.path.concat([key])
          };
          nodeList.push(newNode);
        }
      } else {
        if (node.el === query) {
          retVal.push(node);
        }
      }
    }
  }
  return retVal;
}
function _getArrayValueFromPath(responseArray, path) {
  let currentArray = responseArray;
  for (let ii = 0; ii < path.length; ii++) {
    currentArray = currentArray[path[ii]];
  }
  return currentArray;
}

/***/ }),

/***/ 4653:
/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_158489__) => {

"use strict";
/* harmony export */ __nested_webpack_require_158489__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ getAccountUrlPart)
/* harmony export */ });
/*
 returns "/u/NUMBER" or "/u/NUMBER/d/DELEGATE_ID" for delegated accounts
*/
function getAccountUrlPart() {
  const delegatedAccountMatch = document.location.pathname.match(/\/b\/(.+?)\/u\/(\d+)/);
  if (delegatedAccountMatch) {
    const delegatedAccountId = delegatedAccountMatch[1];
    const delegatedAccountNumber = delegatedAccountMatch[2];
    return `/u/${delegatedAccountNumber}/d/${delegatedAccountId}`;
  } else {
    const accountParamMatch = document.location.pathname.match(/(\/u\/\d+)\//i);
    //no match happens in inbox when user only has one account
    const accountParam = accountParamMatch ? accountParamMatch[1] : '/u/0';
    return accountParam;
  }
}

/***/ }),

/***/ 4013:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_159428__) => {

"use strict";

// EXPORTS
__nested_webpack_require_159428__.d(__nested_webpack_exports__, {
  "Z": () => (/* binding */ driver_common_gmailAjax)
});

// EXTERNAL MODULE: ./node_modules/ud/js/index.js
var js = __nested_webpack_require_159428__(1010);
// EXTERNAL MODULE: ./node_modules/kefir/dist/kefir.esm.js
var kefir_esm = __nested_webpack_require_159428__(6609);
;// CONCATENATED MODULE: ./src/platform-implementation-js/lib/imageRequest.ts
function imageRequest(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.addEventListener('load', () => resolve(img));
    img.addEventListener('error', reject);
    img.src = url;
  });
}
;// CONCATENATED MODULE: ./src/common/rate-limit-queuer.ts
// Returns a wrapped version of the function which queues up callTimestamps to the
// function if it is called more than count times within period amount of time.
function rateLimitQueuer(fn, period, count) {
  let callTimestamps = [];
  const queue = [];
  let runningQueue = false;
  function runJob() {
    const job = queue.shift();
    job();
    if (queue.length) {
      runQueue();
    } else {
      runningQueue = false;
    }
  }
  function runQueue() {
    runningQueue = true;
    const timeToWait = getTimeToUnqueueItem();
    if (timeToWait > 0) {
      setTimeout(runJob, timeToWait);
    } else {
      runJob();
    }
  }
  function getTimeToUnqueueItem() {
    const now = Date.now();
    const periodAgo = now - period;
    callTimestamps = callTimestamps.filter(time => time > periodAgo);
    if (callTimestamps.length >= count) {
      return callTimestamps[0] - periodAgo;
    }
    return -1;
  }
  return function attempt() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let job;
    const promise = new Promise((resolve, reject) => {
      job = () => {
        callTimestamps.push(Date.now());
        try {
          resolve(fn.apply(this, args));
        } catch (err) {
          reject(err);
        }
      };
    });
    if (!job) throw new Error('Should not happen');
    queue.push(job);
    if (!runningQueue) {
      runQueue();
    }
    return promise;
  };
}
// EXTERNAL MODULE: ./src/common/ajax.ts + 1 modules
var ajax = __nested_webpack_require_159428__(7036);
;// CONCATENATED MODULE: ./src/platform-implementation-js/driver-common/gmailAjax.ts
/* module decorator */ module = __nested_webpack_require_159428__.hmd(module);





const IMAGE_REQUEST_TIMEOUT = 1000 * 60; // one minute

const limitedAjax = rateLimitQueuer(rateLimitQueuer(ajax/* default */.Z, 1000, 7), 10 * 1000, 50);

// Tool for making ajax requests to Gmail endpoints. When used in Inbox, this
// function is able to handle the issue that happens when the user has no Gmail
// cookies.
async function gmailAjax(opts) {
  if (!/^https:\/\/mail\.google\.com(?:$|\/)/.test(opts.url)) {
    throw new Error('Should not happen: gmailAjax called with non-gmail url');
  }
  if (document.location.origin === 'https://mail.google.com') {
    return await limitedAjax(opts);
  }
  try {
    return await limitedAjax({
      ...opts,
      canRetry: false
    });
  } catch (e) {
    if (e && e.status === 0) {
      // The connection failed for an unspecified reason. One possible reason
      // is that we have no Gmail cookies, and the connection tried to redirect
      // to an accounts.google.com URL so the Gmail cookies could be set, but
      // then this connection failed because we don't have ajax permission to
      // accounts.google.com. We can work around this by trying an image
      // request (which doesn't have cross-domain restrictions) so the Gmail
      // cookies get set, and then retrying the original ajax request.
      try {
        await kefir_esm["default"].fromPromise(imageRequest('https://mail.google.com/mail/u/0/')).merge(kefir_esm["default"].later(IMAGE_REQUEST_TIMEOUT, undefined)).take(1).takeErrors(1).toPromise();
      } catch (e) {
        // ignore. If we got an error here, there are several possible causes:
        // 1. The user has Gmail cookies, but the first connection attempt
        //    failed for another reason. In this case, we don't care about how
        //    this image request turned out.
        // 2. The user did not have Gmail cookies, and the image's original
        //    request and its first few redirects succeeded, setting the
        //    cookies, but the final request, after the cookies were set,
        //    failed. We don't care about the image's final request.
        // 3. The user did not have Gmail cookies, and the image request didn't
        //    work at all.
        // In the final case, ideally we would retry the image request, but we
        // can't distinguish that case from the other cases and doing retries
        // of the image request would slow down the other cases. The first case
        // is expected to be significantly more common -- the second two cases
        // where the user has no Gmail cookies is expected to happen maybe once
        // in total to an individual user.
      }
      return await limitedAjax(opts);
    } else if (e && typeof e.status === 'number' && e.status >= 500) {
      return await limitedAjax(opts);
    } else {
      throw e;
    }
  }
}
/* harmony default export */ const driver_common_gmailAjax = ((0,js.defn)(module, gmailAjax));

/***/ }),

/***/ 3179:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_164852__) => {

"use strict";
/* harmony export */ __nested_webpack_require_164852__.d(__nested_webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ud__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_164852__(1010);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_164852__(7735);
/* harmony import */ var _gmailAjax__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_164852__(4013);
/* harmony import */ var _getAccountUrlPart__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_164852__(4653);
/* module decorator */ module = __nested_webpack_require_164852__.hmd(module);




async function requestGmailThread(ikValue, threadId) {
  const queryParameters = {
    ui: 2,
    ik: ikValue,
    view: 'cv',
    th: threadId,
    pcd: 1,
    mb: 0,
    rt: 'c',
    search: 'inbox',
    type: threadId
  };
  const {
    text
  } = await (0,_gmailAjax__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)({
    method: 'POST',
    url: `https://mail.google.com/mail${(0,_getAccountUrlPart__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)()}?${querystring__WEBPACK_IMPORTED_MODULE_0__.stringify(queryParameters)}`,
    canRetry: true
  });
  return text;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,ud__WEBPACK_IMPORTED_MODULE_3__.defn)(module, requestGmailThread));

/***/ }),

/***/ 4431:
/***/ (function(module, exports, __nested_webpack_require_166259__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __nested_webpack_require_166259__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Node.js and other environments that support module.exports.
  } else {}
})(this);


/***/ }),

/***/ 4681:
/***/ ((module, exports, __nested_webpack_require_255475__) => {

"use strict";


exports.__esModule = true;
exports["default"] = closest;

var _matchesSelectorNg = _interopRequireDefault(__nested_webpack_require_255475__(5936));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = __nested_webpack_require_255475__.g.Element && __nested_webpack_require_255475__.g.Element.prototype;
var vendor = proto && proto.closest;

function closest(element, selector) {
  if (vendor) return vendor.call(element, selector);
  var parent = element;

  do {
    if ((0, _matchesSelectorNg.default)(parent, selector)) return parent;
    parent = parent.parentNode;
  } while (parent && parent !== __nested_webpack_require_255475__.g.document);

  return null;
}

module.exports = exports.default;
module.exports["default"] = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJwcm90byIsImdsb2JhbCIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJ2ZW5kb3IiLCJjbG9zZXN0IiwiZWxlbWVudCIsInNlbGVjdG9yIiwiY2FsbCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJkb2N1bWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7OztBQUVBLElBQU1BLEtBQUssR0FBR0MsTUFBTSxDQUFDQyxPQUFQLElBQWtCRCxNQUFNLENBQUNDLE9BQVAsQ0FBZUMsU0FBL0M7QUFDQSxJQUFNQyxNQUFNLEdBQUdKLEtBQUssSUFBSUEsS0FBSyxDQUFDSyxPQUE5Qjs7QUFFZSxTQUFTQSxPQUFULENBQWlCQyxPQUFqQixFQUF1Q0MsUUFBdkMsRUFBNkU7QUFDMUYsTUFBSUgsTUFBSixFQUFZLE9BQU9BLE1BQU0sQ0FBQ0ksSUFBUCxDQUFZRixPQUFaLEVBQXFCQyxRQUFyQixDQUFQO0FBQ1osTUFBSUUsTUFBTSxHQUFHSCxPQUFiOztBQUNBLEtBQUc7QUFDRCxRQUFJLGdDQUFRRyxNQUFSLEVBQWdCRixRQUFoQixDQUFKLEVBQStCLE9BQU9FLE1BQVA7QUFDL0JBLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDQyxVQUFoQjtBQUNELEdBSEQsUUFHU0QsTUFBTSxJQUFJQSxNQUFNLEtBQUtSLE1BQU0sQ0FBQ1UsUUFIckM7O0FBSUEsU0FBTyxJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgbWF0Y2hlcyBmcm9tICdtYXRjaGVzLXNlbGVjdG9yLW5nJztcblxuY29uc3QgcHJvdG8gPSBnbG9iYWwuRWxlbWVudCAmJiBnbG9iYWwuRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCB2ZW5kb3IgPSBwcm90byAmJiBwcm90by5jbG9zZXN0O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG4gIGRvIHtcbiAgICBpZiAobWF0Y2hlcyhwYXJlbnQsIHNlbGVjdG9yKSkgcmV0dXJuIHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gZ2xvYmFsLmRvY3VtZW50KTtcbiAgcmV0dXJuIG51bGw7XG59XG4iXX0=

/***/ }),

/***/ 7187:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 2750:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.moduleId = void 0;
var moduleId = '1f24 e53a';
exports.moduleId = moduleId;
//# sourceMappingURL=moduleId.js.map

/***/ }),

/***/ 9979:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_273179__) => {

"use strict";


var _interopRequireDefault = __nested_webpack_require_273179__(4836);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.init = init;

var _toConsumableArray2 = _interopRequireDefault(__nested_webpack_require_273179__(861));

var _transferrables = _interopRequireDefault(__nested_webpack_require_273179__(4658));

var _moduleId = __nested_webpack_require_273179__(2750);

// must be executed in page's world
function init() {
  // save a reference to XHR so we use the original instead of any replacements that extensions may place.
  var XMLHttpRequest = window.XMLHttpRequest;

  function handler(event) {
    if (!event.data || event.data.type !== 'ext-corb-workaround_port' || event.data.moduleId !== _moduleId.moduleId || event.__ext_claimed) {
      return;
    }

    event.__ext_claimed = true;
    window.removeEventListener('message', handler);
    var port = event.data.port;
    var instancesById = {};
    port.addEventListener('message', function (event) {
      var id = event.data.id;

      switch (event.data.type) {
        case 'NEW_XHR':
          {
            var xhr = instancesById[id] = new XMLHttpRequest();
            xhr.addEventListener('readystatechange', function () {
              if (xhr.readyState !== 4) {
                return;
              }

              delete instancesById[id];
              var responseText;

              try {
                responseText = xhr.responseText;
              } catch (err) {// ignore
              }

              port.postMessage({
                type: 'COMPLETE',
                id: id,
                headers: xhr.getAllResponseHeaders(),
                readyState: xhr.readyState,
                status: xhr.status,
                statusText: xhr.statusText,
                responseURL: xhr.responseURL,
                response: xhr.response,
                responseText: responseText
              }, (0, _transferrables["default"])([xhr.response]));
            });
            break;
          }

        case 'SET':
          {
            var _event$data = event.data,
                prop = _event$data.prop,
                value = _event$data.value;
            instancesById[id][prop] = value;
            break;
          }

        case 'CALL':
          {
            var _ref;

            var _event$data2 = event.data,
                method = _event$data2.method,
                args = _event$data2.args; // Let abort calls silently fail if the XHR isn't present.

            if (method === 'abort' && !instancesById[id]) {
              break;
            }

            (_ref = instancesById[id])[method].apply(_ref, (0, _toConsumableArray2["default"])(args));

            break;
          }

        default:
          {
            // eslint-disable-next-line no-console
            console.error('ext-corb-workaround: Unknown event in page world:', event);
          }
      }
    });
    port.addEventListener('messageerror', function (event) {
      // eslint-disable-next-line no-console
      console.error('ext-corb-workaround: Unknown error in page world:', event);
    });
    port.start();
  }

  window.addEventListener('message', handler);
}


/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_276430__) => {

"use strict";


var _interopRequireDefault = __nested_webpack_require_276430__(4836);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = transferrables;

var _typeof2 = _interopRequireDefault(__nested_webpack_require_276430__(8698));

function transferrables(list) {
  return list.map(function (value) {
    if (value && (0, _typeof2["default"])(value) === 'object' && value.__proto__) {
      if (value.__proto__.constructor.name === 'ArrayBuffer') {
        return value;
      }

      if (value.__proto__.__proto__ && value.__proto__.__proto__.constructor.name === 'TypedArray') {
        return value.buffer;
      }
    }
  }).filter(Boolean);
}
//# sourceMappingURL=transferrables.js.map

/***/ }),

/***/ 6609:
/***/ ((module, __nested_webpack_exports__, __nested_webpack_require_277223__) => {

"use strict";
/* harmony export */ __nested_webpack_require_277223__.d(__nested_webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports dissableDeprecationWarnings, Kefir, Observable, Stream, Property, never, later, interval, sequentially, fromPoll, withInterval, fromCallback, fromNodeCallback, fromEvents, stream, constant, constantError, fromPromise, fromESObservable, combine, zip, merge, concat, Pool, pool, repeat, staticLand */
/* module decorator */ module = __nested_webpack_require_277223__.hmd(module);
/*! Kefir.js v3.8.8
 *  https://github.com/kefirjs/kefir
 */

function createObj(proto) {
  var F = function () {};
  F.prototype = proto;
  return new F();
}

function extend(target /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0,
      prop = void 0;
  for (i = 1; i < length; i++) {
    for (prop in arguments[i]) {
      target[prop] = arguments[i][prop];
    }
  }
  return target;
}

function inherit(Child, Parent /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0;
  Child.prototype = createObj(Parent.prototype);
  Child.prototype.constructor = Child;
  for (i = 2; i < length; i++) {
    extend(Child.prototype, arguments[i]);
  }
  return Child;
}

var NOTHING = ['<nothing>'];
var END = 'end';
var VALUE = 'value';
var ERROR = 'error';
var ANY = 'any';

function concat(a, b) {
  var result = void 0,
      length = void 0,
      i = void 0,
      j = void 0;
  if (a.length === 0) {
    return b;
  }
  if (b.length === 0) {
    return a;
  }
  j = 0;
  result = new Array(a.length + b.length);
  length = a.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = a[i];
  }
  length = b.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = b[i];
  }
  return result;
}

function find(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (arr[i] === value) {
      return i;
    }
  }
  return -1;
}

function findByPred(arr, pred) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
}

function cloneArray(input) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = input[i];
  }
  return result;
}

function remove(input, index) {
  var length = input.length,
      result = void 0,
      i = void 0,
      j = void 0;
  if (index >= 0 && index < length) {
    if (length === 1) {
      return [];
    } else {
      result = new Array(length - 1);
      for (i = 0, j = 0; i < length; i++) {
        if (i !== index) {
          result[j] = input[i];
          j++;
        }
      }
      return result;
    }
  } else {
    return input;
  }
}

function map(input, fn) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = fn(input[i]);
  }
  return result;
}

function forEach(arr, fn) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    fn(arr[i]);
  }
}

function fillArray(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    arr[i] = value;
  }
}

function contains(arr, value) {
  return find(arr, value) !== -1;
}

function slide(cur, next, max) {
  var length = Math.min(max, cur.length + 1),
      offset = cur.length - length + 1,
      result = new Array(length),
      i = void 0;
  for (i = offset; i < length; i++) {
    result[i - offset] = cur[i];
  }
  result[length - 1] = next;
  return result;
}

function callSubscriber(type, fn, event) {
  if (type === ANY) {
    fn(event);
  } else if (type === event.type) {
    if (type === VALUE || type === ERROR) {
      fn(event.value);
    } else {
      fn();
    }
  }
}

function Dispatcher() {
  this._items = [];
  this._spies = [];
  this._inLoop = 0;
  this._removedItems = null;
}

extend(Dispatcher.prototype, {
  add: function (type, fn) {
    this._items = concat(this._items, [{ type: type, fn: fn }]);
    return this._items.length;
  },
  remove: function (type, fn) {
    var index = findByPred(this._items, function (x) {
      return x.type === type && x.fn === fn;
    });

    // if we're currently in a notification loop,
    // remember this subscriber was removed
    if (this._inLoop !== 0 && index !== -1) {
      if (this._removedItems === null) {
        this._removedItems = [];
      }
      this._removedItems.push(this._items[index]);
    }

    this._items = remove(this._items, index);
    return this._items.length;
  },
  addSpy: function (fn) {
    this._spies = concat(this._spies, [fn]);
    return this._spies.length;
  },


  // Because spies are only ever a function that perform logging as
  // their only side effect, we don't need the same complicated
  // removal logic like in remove()
  removeSpy: function (fn) {
    this._spies = remove(this._spies, this._spies.indexOf(fn));
    return this._spies.length;
  },
  dispatch: function (event) {
    this._inLoop++;
    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
      spies[i](event);
    }

    for (var _i = 0, items = this._items; _i < items.length; _i++) {
      // cleanup was called
      if (this._items === null) {
        break;
      }

      // this subscriber was removed
      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
        continue;
      }

      callSubscriber(items[_i].type, items[_i].fn, event);
    }
    this._inLoop--;
    if (this._inLoop === 0) {
      this._removedItems = null;
    }
  },
  cleanup: function () {
    this._items = null;
    this._spies = null;
  }
});

function Observable() {
  this._dispatcher = new Dispatcher();
  this._active = false;
  this._alive = true;
  this._activating = false;
  this._logHandlers = null;
  this._spyHandlers = null;
}

extend(Observable.prototype, {
  _name: 'observable',

  _onActivation: function () {},
  _onDeactivation: function () {},
  _setActive: function (active) {
    if (this._active !== active) {
      this._active = active;
      if (active) {
        this._activating = true;
        this._onActivation();
        this._activating = false;
      } else {
        this._onDeactivation();
      }
    }
  },
  _clear: function () {
    this._setActive(false);
    this._dispatcher.cleanup();
    this._dispatcher = null;
    this._logHandlers = null;
  },
  _emit: function (type, x) {
    switch (type) {
      case VALUE:
        return this._emitValue(x);
      case ERROR:
        return this._emitError(x);
      case END:
        return this._emitEnd();
    }
  },
  _emitValue: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: VALUE, value: value });
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: ERROR, value: value });
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      this._dispatcher.dispatch({ type: END });
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    } else {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  _off: function (type, fn) {
    if (this._alive) {
      var count = this._dispatcher.remove(type, fn);
      if (count === 0) {
        this._setActive(false);
      }
    }
    return this;
  },
  onValue: function (fn) {
    return this._on(VALUE, fn);
  },
  onError: function (fn) {
    return this._on(ERROR, fn);
  },
  onEnd: function (fn) {
    return this._on(END, fn);
  },
  onAny: function (fn) {
    return this._on(ANY, fn);
  },
  offValue: function (fn) {
    return this._off(VALUE, fn);
  },
  offError: function (fn) {
    return this._off(ERROR, fn);
  },
  offEnd: function (fn) {
    return this._off(END, fn);
  },
  offAny: function (fn) {
    return this._off(ANY, fn);
  },
  observe: function (observerOrOnValue, onError, onEnd) {
    var _this = this;
    var closed = false;

    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;

    var handler = function (event) {
      if (event.type === END) {
        closed = true;
      }
      if (event.type === VALUE && observer.value) {
        observer.value(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.end) {
        observer.end(event.value);
      }
    };

    this.onAny(handler);

    return {
      unsubscribe: function () {
        if (!closed) {
          _this.offAny(handler);
          closed = true;
        }
      },

      get closed() {
        return closed;
      }
    };
  },


  // A and B must be subclasses of Stream and Property (order doesn't matter)
  _ofSameType: function (A, B) {
    return A.prototype.getType() === this.getType() ? A : B;
  },
  setName: function (sourceObs /* optional */, selfName) {
    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
    return this;
  },
  log: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var isCurrent = void 0;
    var handler = function (event) {
      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };

    if (this._alive) {
      if (!this._logHandlers) {
        this._logHandlers = [];
      }
      this._logHandlers.push({ name: name, handler: handler });
    }

    isCurrent = true;
    this.onAny(handler);
    isCurrent = false;

    return this;
  },
  offLog: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._logHandlers) {
      var handlerIndex = findByPred(this._logHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this.offAny(this._logHandlers[handlerIndex].handler);
        this._logHandlers.splice(handlerIndex, 1);
      }
    }

    return this;
  },
  spy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var handler = function (event) {
      var type = '<' + event.type + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };
    if (this._alive) {
      if (!this._spyHandlers) {
        this._spyHandlers = [];
      }
      this._spyHandlers.push({ name: name, handler: handler });
      this._dispatcher.addSpy(handler);
    }
    return this;
  },
  offSpy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._spyHandlers) {
      var handlerIndex = findByPred(this._spyHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
        this._spyHandlers.splice(handlerIndex, 1);
      }
    }
    return this;
  }
});

// extend() can't handle `toString` in IE8
Observable.prototype.toString = function () {
  return '[' + this._name + ']';
};

function Stream() {
  Observable.call(this);
}

inherit(Stream, Observable, {
  _name: 'stream',

  getType: function () {
    return 'stream';
  }
});

function Property() {
  Observable.call(this);
  this._currentEvent = null;
}

inherit(Property, Observable, {
  _name: 'property',

  _emitValue: function (value) {
    if (this._alive) {
      this._currentEvent = { type: VALUE, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: VALUE, value: value });
      }
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._currentEvent = { type: ERROR, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: ERROR, value: value });
      }
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      if (!this._activating) {
        this._dispatcher.dispatch({ type: END });
      }
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    }
    if (this._currentEvent !== null) {
      callSubscriber(type, fn, this._currentEvent);
    }
    if (!this._alive) {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  getType: function () {
    return 'property';
  }
});

var neverS = new Stream();
neverS._emitEnd();
neverS._name = 'never';

function never() {
  return neverS;
}

function timeBased(mixin) {
  function AnonymousStream(wait, options) {
    var _this = this;

    Stream.call(this);
    this._wait = wait;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._onTick();
    };
    this._init(options);
  }

  inherit(AnonymousStream, Stream, {
    _init: function () {},
    _free: function () {},
    _onTick: function () {},
    _onActivation: function () {
      this._intervalId = setInterval(this._$onTick, this._wait);
    },
    _onDeactivation: function () {
      if (this._intervalId !== null) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    },
    _clear: function () {
      Stream.prototype._clear.call(this);
      this._$onTick = null;
      this._free();
    }
  }, mixin);

  return AnonymousStream;
}

var S = timeBased({
  _name: 'later',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
    this._emitEnd();
  }
});

function later(wait, x) {
  return new S(wait, { x: x });
}

var S$1 = timeBased({
  _name: 'interval',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
  }
});

function interval(wait, x) {
  return new S$1(wait, { x: x });
}

var S$2 = timeBased({
  _name: 'sequentially',

  _init: function (_ref) {
    var xs = _ref.xs;

    this._xs = cloneArray(xs);
  },
  _free: function () {
    this._xs = null;
  },
  _onTick: function () {
    if (this._xs.length === 1) {
      this._emitValue(this._xs[0]);
      this._emitEnd();
    } else {
      this._emitValue(this._xs.shift());
    }
  }
});

function sequentially(wait, xs) {
  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
}

var S$3 = timeBased({
  _name: 'fromPoll',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _onTick: function () {
    var fn = this._fn;
    this._emitValue(fn());
  }
});

function fromPoll(wait, fn) {
  return new S$3(wait, { fn: fn });
}

function emitter(obs) {
  function value(x) {
    obs._emitValue(x);
    return obs._active;
  }

  function error(x) {
    obs._emitError(x);
    return obs._active;
  }

  function end() {
    obs._emitEnd();
    return obs._active;
  }

  function event(e) {
    obs._emit(e.type, e.value);
    return obs._active;
  }

  return {
    value: value,
    error: error,
    end: end,
    event: event,

    // legacy
    emit: value,
    emitEvent: event
  };
}

var S$4 = timeBased({
  _name: 'withInterval',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._fn = null;
    this._emitter = null;
  },
  _onTick: function () {
    var fn = this._fn;
    fn(this._emitter);
  }
});

function withInterval(wait, fn) {
  return new S$4(wait, { fn: fn });
}

function S$5(fn) {
  Stream.call(this);
  this._fn = fn;
  this._unsubscribe = null;
}

inherit(S$5, Stream, {
  _name: 'stream',

  _onActivation: function () {
    var fn = this._fn;
    var unsubscribe = fn(emitter(this));
    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;

    // fix https://github.com/kefirjs/kefir/issues/35
    if (!this._active) {
      this._callUnsubscribe();
    }
  },
  _callUnsubscribe: function () {
    if (this._unsubscribe !== null) {
      this._unsubscribe();
      this._unsubscribe = null;
    }
  },
  _onDeactivation: function () {
    this._callUnsubscribe();
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._fn = null;
  }
});

function stream(fn) {
  return new S$5(fn);
}

function fromCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (x) {
        emitter.emit(x);
        emitter.end();
      });
      called = true;
    }
  }).setName('fromCallback');
}

function fromNodeCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (error, x) {
        if (error) {
          emitter.error(error);
        } else {
          emitter.emit(x);
        }
        emitter.end();
      });
      called = true;
    }
  }).setName('fromNodeCallback');
}

function spread(fn, length) {
  switch (length) {
    case 0:
      return function () {
        return fn();
      };
    case 1:
      return function (a) {
        return fn(a[0]);
      };
    case 2:
      return function (a) {
        return fn(a[0], a[1]);
      };
    case 3:
      return function (a) {
        return fn(a[0], a[1], a[2]);
      };
    case 4:
      return function (a) {
        return fn(a[0], a[1], a[2], a[3]);
      };
    default:
      return function (a) {
        return fn.apply(null, a);
      };
  }
}

function apply(fn, c, a) {
  var aLength = a ? a.length : 0;
  if (c == null) {
    switch (aLength) {
      case 0:
        return fn();
      case 1:
        return fn(a[0]);
      case 2:
        return fn(a[0], a[1]);
      case 3:
        return fn(a[0], a[1], a[2]);
      case 4:
        return fn(a[0], a[1], a[2], a[3]);
      default:
        return fn.apply(null, a);
    }
  } else {
    switch (aLength) {
      case 0:
        return fn.call(c);
      default:
        return fn.apply(c, a);
    }
  }
}

function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {
  return stream(function (emitter) {
    var handler = transformer ? function () {
      emitter.emit(apply(transformer, this, arguments));
    } : function (x) {
      emitter.emit(x);
    };

    sub(handler);
    return function () {
      return unsub(handler);
    };
  }).setName('fromSubUnsub');
}

var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];

function fromEvents(target, eventName, transformer) {
  var sub = void 0,
      unsub = void 0;

  for (var i = 0; i < pairs.length; i++) {
    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
      sub = pairs[i][0];
      unsub = pairs[i][1];
      break;
    }
  }

  if (sub === undefined) {
    throw new Error("target don't support any of " + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
  }

  return fromSubUnsub(function (handler) {
    return target[sub](eventName, handler);
  }, function (handler) {
    return target[unsub](eventName, handler);
  }, transformer).setName('fromEvents');
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P(value) {
  this._currentEvent = { type: 'value', value: value, current: true };
}

inherit(P, Property, {
  _name: 'constant',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constant(x) {
  return new P(x);
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P$1(value) {
  this._currentEvent = { type: 'error', value: value, current: true };
}

inherit(P$1, Property, {
  _name: 'constantError',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constantError(x) {
  return new P$1(x);
}

function createConstructor(BaseClass, name) {
  return function AnonymousObservable(source, options) {
    var _this = this;

    BaseClass.call(this);
    this._source = source;
    this._name = source._name + '.' + name;
    this._init(options);
    this._$handleAny = function (event) {
      return _this._handleAny(event);
    };
  };
}

function createClassMethods(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handleValue: function (x) {
      this._emitValue(x);
    },
    _handleError: function (x) {
      this._emitError(x);
    },
    _handleEnd: function () {
      this._emitEnd();
    },
    _handleAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleValue(event.value);
        case ERROR:
          return this._handleError(event.value);
        case END:
          return this._handleEnd();
      }
    },
    _onActivation: function () {
      this._source.onAny(this._$handleAny);
    },
    _onDeactivation: function () {
      this._source.offAny(this._$handleAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._source = null;
      this._$handleAny = null;
      this._free();
    }
  };
}

function createStream(name, mixin) {
  var S = createConstructor(Stream, name);
  inherit(S, Stream, createClassMethods(Stream), mixin);
  return S;
}

function createProperty(name, mixin) {
  var P = createConstructor(Property, name);
  inherit(P, Property, createClassMethods(Property), mixin);
  return P;
}

var P$2 = createProperty('toProperty', {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._getInitialCurrent = fn;
  },
  _onActivation: function () {
    if (this._getInitialCurrent !== null) {
      var getInitial = this._getInitialCurrent;
      this._emitValue(getInitial());
    }
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  }
});

function toProperty(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (fn !== null && typeof fn !== 'function') {
    throw new Error('You should call toProperty() with a function or no arguments.');
  }
  return new P$2(obs, { fn: fn });
}

var S$6 = createStream('changes', {
  _handleValue: function (x) {
    if (!this._activating) {
      this._emitValue(x);
    }
  },
  _handleError: function (x) {
    if (!this._activating) {
      this._emitError(x);
    }
  }
});

function changes(obs) {
  return new S$6(obs);
}

function fromPromise(promise) {
  var called = false;

  var result = stream(function (emitter) {
    if (!called) {
      var onValue = function (x) {
        emitter.emit(x);
        emitter.end();
      };
      var onError = function (x) {
        emitter.error(x);
        emitter.end();
      };
      var _promise = promise.then(onValue, onError);

      // prevent libraries like 'Q' or 'when' from swallowing exceptions
      if (_promise && typeof _promise.done === 'function') {
        _promise.done();
      }

      called = true;
    }
  });

  return toProperty(result, null).setName('fromPromise');
}

function getGlodalPromise() {
  if (typeof Promise === 'function') {
    return Promise;
  } else {
    throw new Error("There isn't default Promise, use shim or parameter");
  }
}

var toPromise = function (obs) {
  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();

  var last = null;
  return new Promise(function (resolve, reject) {
    obs.onAny(function (event) {
      if (event.type === END && last !== null) {
        (last.type === VALUE ? resolve : reject)(last.value);
        last = null;
      } else {
        last = event;
      }
    });
  });
};

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __nested_webpack_require_277223__.g !== 'undefined') {
  root = __nested_webpack_require_277223__.g;
} else if (true) {
  root = module;
} else {}

var result = symbolObservablePonyfill(root);

// this file contains some hot JS modules systems stuff

var $$observable = result.default ? result.default : result;

function fromESObservable(_observable) {
  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
  return stream(function (emitter) {
    var unsub = observable.subscribe({
      error: function (error) {
        emitter.error(error);
        emitter.end();
      },
      next: function (value) {
        emitter.emit(value);
      },
      complete: function () {
        emitter.end();
      }
    });

    if (unsub.unsubscribe) {
      return function () {
        unsub.unsubscribe();
      };
    } else {
      return unsub;
    }
  }).setName('fromESObservable');
}

function ESObservable(observable) {
  this._observable = observable.takeErrors(1);
}

extend(ESObservable.prototype, {
  subscribe: function (observerOrOnNext, onError, onComplete) {
    var _this = this;

    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;

    var fn = function (event) {
      if (event.type === END) {
        closed = true;
      }

      if (event.type === VALUE && observer.next) {
        observer.next(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.complete) {
        observer.complete(event.value);
      }
    };

    this._observable.onAny(fn);
    var closed = false;

    var subscription = {
      unsubscribe: function () {
        closed = true;
        _this._observable.offAny(fn);
      },
      get closed() {
        return closed;
      }
    };
    return subscription;
  }
});

// Need to assign directly b/c Symbols aren't enumerable.
ESObservable.prototype[$$observable] = function () {
  return this;
};

function toESObservable() {
  return new ESObservable(this);
}

function collect(source, keys, values) {
  for (var prop in source) {
    if (source.hasOwnProperty(prop)) {
      keys.push(prop);
      values.push(source[prop]);
    }
  }
}

function defaultErrorsCombinator(errors) {
  var latestError = void 0;
  for (var i = 0; i < errors.length; i++) {
    if (errors[i] !== undefined) {
      if (latestError === undefined || latestError.index < errors[i].index) {
        latestError = errors[i];
      }
    }
  }
  return latestError.error;
}

function Combine(active, passive, combinator) {
  var _this = this;

  Stream.call(this);
  this._activeCount = active.length;
  this._sources = concat(active, passive);
  this._combinator = combinator;
  this._aliveCount = 0;
  this._latestValues = new Array(this._sources.length);
  this._latestErrors = new Array(this._sources.length);
  fillArray(this._latestValues, NOTHING);
  this._emitAfterActivation = false;
  this._endAfterActivation = false;
  this._latestErrorIndex = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Combine, Stream, {
  _name: 'combine',

  _onActivation: function () {
    this._aliveCount = this._activeCount;

    // we need to suscribe to _passive_ sources before _active_
    // (see https://github.com/kefirjs/kefir/issues/98)
    for (var i = this._activeCount; i < this._sources.length; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
    for (var _i = 0; _i < this._activeCount; _i++) {
      this._sources[_i].onAny(this._$handlers[_i]);
    }

    if (this._emitAfterActivation) {
      this._emitAfterActivation = false;
      this._emitIfFull();
    }
    if (this._endAfterActivation) {
      this._emitEnd();
    }
  },
  _onDeactivation: function () {
    var length = this._sources.length,
        i = void 0;
    for (i = 0; i < length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emitIfFull: function () {
    var hasAllValues = true;
    var hasErrors = false;
    var length = this._latestValues.length;
    var valuesCopy = new Array(length);
    var errorsCopy = new Array(length);

    for (var i = 0; i < length; i++) {
      valuesCopy[i] = this._latestValues[i];
      errorsCopy[i] = this._latestErrors[i];

      if (valuesCopy[i] === NOTHING) {
        hasAllValues = false;
      }

      if (errorsCopy[i] !== undefined) {
        hasErrors = true;
      }
    }

    if (hasAllValues) {
      var combinator = this._combinator;
      this._emitValue(combinator(valuesCopy));
    }
    if (hasErrors) {
      this._emitError(defaultErrorsCombinator(errorsCopy));
    }
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE || event.type === ERROR) {
      if (event.type === VALUE) {
        this._latestValues[i] = event.value;
        this._latestErrors[i] = undefined;
      }
      if (event.type === ERROR) {
        this._latestValues[i] = NOTHING;
        this._latestErrors[i] = {
          index: this._latestErrorIndex++,
          error: event.value
        };
      }

      if (i < this._activeCount) {
        if (this._activating) {
          this._emitAfterActivation = true;
        } else {
          this._emitIfFull();
        }
      }
    } else {
      // END

      if (i < this._activeCount) {
        this._aliveCount--;
        if (this._aliveCount === 0) {
          if (this._activating) {
            this._endAfterActivation = true;
          } else {
            this._emitEnd();
          }
        }
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._latestValues = null;
    this._latestErrors = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function combineAsArray(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var combinator = arguments[2];

  if (!Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
    return x;
  };
  return active.length === 0 ? never() : new Combine(active, passive, combinator);
}

function combineAsObject(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var combinator = arguments[2];

  if (typeof passive !== 'object' || Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  var keys = [],
      activeObservables = [],
      passiveObservables = [];

  collect(active, keys, activeObservables);
  collect(passive, keys, passiveObservables);

  var objectify = function (values) {
    var event = {};
    for (var i = values.length - 1; 0 <= i; i--) {
      event[keys[i]] = values[i];
    }
    return combinator ? combinator(event) : event;
  };

  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
}

function combine(active, passive, combinator) {
  if (typeof passive === 'function') {
    combinator = passive;
    passive = undefined;
  }

  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
}

var Observable$2 = {
  empty: function () {
    return never();
  },


  // Monoid based on merge() seems more useful than one based on concat().
  concat: function (a, b) {
    return a.merge(b);
  },
  of: function (x) {
    return constant(x);
  },
  map: function (fn, obs) {
    return obs.map(fn);
  },
  bimap: function (fnErr, fnVal, obs) {
    return obs.mapErrors(fnErr).map(fnVal);
  },


  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get
  // different (not very useful) behavior. But spec requires that if method can be derived
  // it must have the same behavior as hand-written method. We intentionally violate the spec
  // in hope that it won't cause many troubles in practice. And in return we have more useful type.
  ap: function (obsFn, obsVal) {
    return combine([obsFn, obsVal], function (fn, val) {
      return fn(val);
    });
  },
  chain: function (fn, obs) {
    return obs.flatMap(fn);
  }
};



var staticLand = Object.freeze({
	Observable: Observable$2
});

var mixin = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    this._emitValue(fn(x));
  }
};

var S$7 = createStream('map', mixin);
var P$3 = createProperty('map', mixin);

var id = function (x) {
  return x;
};

function map$1(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;

  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
}

var mixin$1 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    }
  }
};

var S$8 = createStream('filter', mixin$1);
var P$4 = createProperty('filter', mixin$1);

var id$1 = function (x) {
  return x;
};

function filter(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;

  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
}

var mixin$2 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitValue(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$9 = createStream('take', mixin$2);
var P$5 = createProperty('take', mixin$2);

function take(obs, n) {
  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
}

var mixin$3 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleError: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitError(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$10 = createStream('takeErrors', mixin$3);
var P$6 = createProperty('takeErrors', mixin$3);

function takeErrors(obs, n) {
  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
}

var mixin$4 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    } else {
      this._emitEnd();
    }
  }
};

var S$11 = createStream('takeWhile', mixin$4);
var P$7 = createProperty('takeWhile', mixin$4);

var id$2 = function (x) {
  return x;
};

function takeWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;

  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
}

var mixin$5 = {
  _init: function () {
    this._lastValue = NOTHING;
  },
  _free: function () {
    this._lastValue = null;
  },
  _handleValue: function (x) {
    this._lastValue = x;
  },
  _handleEnd: function () {
    if (this._lastValue !== NOTHING) {
      this._emitValue(this._lastValue);
    }
    this._emitEnd();
  }
};

var S$12 = createStream('last', mixin$5);
var P$8 = createProperty('last', mixin$5);

function last(obs) {
  return new (obs._ofSameType(S$12, P$8))(obs);
}

var mixin$6 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = Math.max(0, n);
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      this._emitValue(x);
    } else {
      this._n--;
    }
  }
};

var S$13 = createStream('skip', mixin$6);
var P$9 = createProperty('skip', mixin$6);

function skip(obs, n) {
  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
}

var mixin$7 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._fn !== null && !fn(x)) {
      this._fn = null;
    }
    if (this._fn === null) {
      this._emitValue(x);
    }
  }
};

var S$14 = createStream('skipWhile', mixin$7);
var P$10 = createProperty('skipWhile', mixin$7);

var id$3 = function (x) {
  return x;
};

function skipWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;

  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
}

var mixin$8 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._prev = NOTHING;
  },
  _free: function () {
    this._fn = null;
    this._prev = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._prev === NOTHING || !fn(this._prev, x)) {
      this._prev = x;
      this._emitValue(x);
    }
  }
};

var S$15 = createStream('skipDuplicates', mixin$8);
var P$11 = createProperty('skipDuplicates', mixin$8);

var eq = function (a, b) {
  return a === b;
};

function skipDuplicates(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;

  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
}

var mixin$9 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._prev = seed;
  },
  _free: function () {
    this._prev = null;
    this._fn = null;
  },
  _handleValue: function (x) {
    if (this._prev !== NOTHING) {
      var fn = this._fn;
      this._emitValue(fn(this._prev, x));
    }
    this._prev = x;
  }
};

var S$16 = createStream('diff', mixin$9);
var P$12 = createProperty('diff', mixin$9);

function defaultFn(a, b) {
  return [a, b];
}

function diff(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });
}

var P$13 = createProperty('scan', {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._seed = seed;
    if (seed !== NOTHING) {
      this._emitValue(seed);
    }
  },
  _free: function () {
    this._fn = null;
    this._seed = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._currentEvent === null || this._currentEvent.type === ERROR) {
      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
    } else {
      this._emitValue(fn(this._currentEvent.value, x));
    }
  }
});

function scan(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new P$13(obs, { fn: fn, seed: seed });
}

var mixin$10 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var xs = fn(x);
    for (var i = 0; i < xs.length; i++) {
      this._emitValue(xs[i]);
    }
  }
};

var S$17 = createStream('flatten', mixin$10);

var id$4 = function (x) {
  return x;
};

function flatten(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;

  return new S$17(obs, { fn: fn });
}

var END_MARKER = {};

var mixin$11 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait;

    this._wait = Math.max(0, wait);
    this._buff = [];
    this._$shiftBuff = function () {
      var value = _this._buff.shift();
      if (value === END_MARKER) {
        _this._emitEnd();
      } else {
        _this._emitValue(value);
      }
    };
  },
  _free: function () {
    this._buff = null;
    this._$shiftBuff = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._buff.push(x);
      setTimeout(this._$shiftBuff, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      this._buff.push(END_MARKER);
      setTimeout(this._$shiftBuff, this._wait);
    }
  }
};

var S$18 = createStream('delay', mixin$11);
var P$14 = createProperty('delay', mixin$11);

function delay(obs, wait) {
  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
}

var now = Date.now ? function () {
  return Date.now();
} : function () {
  return new Date().getTime();
};

var mixin$12 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        leading = _ref.leading,
        trailing = _ref.trailing;

    this._wait = Math.max(0, wait);
    this._leading = leading;
    this._trailing = trailing;
    this._trailingValue = null;
    this._timeoutId = null;
    this._endLater = false;
    this._lastCallTime = 0;
    this._$trailingCall = function () {
      return _this._trailingCall();
    };
  },
  _free: function () {
    this._trailingValue = null;
    this._$trailingCall = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      var curTime = now();
      if (this._lastCallTime === 0 && !this._leading) {
        this._lastCallTime = curTime;
      }
      var remaining = this._wait - (curTime - this._lastCallTime);
      if (remaining <= 0) {
        this._cancelTrailing();
        this._lastCallTime = curTime;
        this._emitValue(x);
      } else if (this._trailing) {
        this._cancelTrailing();
        this._trailingValue = x;
        this._timeoutId = setTimeout(this._$trailingCall, remaining);
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _cancelTrailing: function () {
    if (this._timeoutId !== null) {
      clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  },
  _trailingCall: function () {
    this._emitValue(this._trailingValue);
    this._timeoutId = null;
    this._trailingValue = null;
    this._lastCallTime = !this._leading ? 0 : now();
    if (this._endLater) {
      this._emitEnd();
    }
  }
};

var S$19 = createStream('throttle', mixin$12);
var P$15 = createProperty('throttle', mixin$12);

function throttle(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$leading = _ref2.leading,
      leading = _ref2$leading === undefined ? true : _ref2$leading,
      _ref2$trailing = _ref2.trailing,
      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;

  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });
}

var mixin$13 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        immediate = _ref.immediate;

    this._wait = Math.max(0, wait);
    this._immediate = immediate;
    this._lastAttempt = 0;
    this._timeoutId = null;
    this._laterValue = null;
    this._endLater = false;
    this._$later = function () {
      return _this._later();
    };
  },
  _free: function () {
    this._laterValue = null;
    this._$later = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._lastAttempt = now();
      if (this._immediate && !this._timeoutId) {
        this._emitValue(x);
      }
      if (!this._timeoutId) {
        this._timeoutId = setTimeout(this._$later, this._wait);
      }
      if (!this._immediate) {
        this._laterValue = x;
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId && !this._immediate) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _later: function () {
    var last = now() - this._lastAttempt;
    if (last < this._wait && last >= 0) {
      this._timeoutId = setTimeout(this._$later, this._wait - last);
    } else {
      this._timeoutId = null;
      if (!this._immediate) {
        var _laterValue = this._laterValue;
        this._laterValue = null;
        this._emitValue(_laterValue);
      }
      if (this._endLater) {
        this._emitEnd();
      }
    }
  }
};

var S$20 = createStream('debounce', mixin$13);
var P$16 = createProperty('debounce', mixin$13);

function debounce(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$immediate = _ref2.immediate,
      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;

  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });
}

var mixin$14 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    this._emitError(fn(x));
  }
};

var S$21 = createStream('mapErrors', mixin$14);
var P$17 = createProperty('mapErrors', mixin$14);

var id$5 = function (x) {
  return x;
};

function mapErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;

  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
}

var mixin$15 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitError(x);
    }
  }
};

var S$22 = createStream('filterErrors', mixin$15);
var P$18 = createProperty('filterErrors', mixin$15);

var id$6 = function (x) {
  return x;
};

function filterErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;

  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
}

var mixin$16 = {
  _handleValue: function () {}
};

var S$23 = createStream('ignoreValues', mixin$16);
var P$19 = createProperty('ignoreValues', mixin$16);

function ignoreValues(obs) {
  return new (obs._ofSameType(S$23, P$19))(obs);
}

var mixin$17 = {
  _handleError: function () {}
};

var S$24 = createStream('ignoreErrors', mixin$17);
var P$20 = createProperty('ignoreErrors', mixin$17);

function ignoreErrors(obs) {
  return new (obs._ofSameType(S$24, P$20))(obs);
}

var mixin$18 = {
  _handleEnd: function () {}
};

var S$25 = createStream('ignoreEnd', mixin$18);
var P$21 = createProperty('ignoreEnd', mixin$18);

function ignoreEnd(obs) {
  return new (obs._ofSameType(S$25, P$21))(obs);
}

var mixin$19 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleEnd: function () {
    var fn = this._fn;
    this._emitValue(fn());
    this._emitEnd();
  }
};

var S$26 = createStream('beforeEnd', mixin$19);
var P$22 = createProperty('beforeEnd', mixin$19);

function beforeEnd(obs, fn) {
  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
}

var mixin$20 = {
  _init: function (_ref) {
    var min = _ref.min,
        max = _ref.max;

    this._max = max;
    this._min = min;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _handleValue: function (x) {
    this._buff = slide(this._buff, x, this._max);
    if (this._buff.length >= this._min) {
      this._emitValue(this._buff);
    }
  }
};

var S$27 = createStream('slidingWindow', mixin$20);
var P$23 = createProperty('slidingWindow', mixin$20);

function slidingWindow(obs, max) {
  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });
}

var mixin$21 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        flushOnEnd = _ref.flushOnEnd;

    this._fn = fn;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    var fn = this._fn;
    if (!fn(x)) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$28 = createStream('bufferWhile', mixin$21);
var P$24 = createProperty('bufferWhile', mixin$21);

var id$7 = function (x) {
  return x;
};

function bufferWhile(obs, fn) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });
}

var mixin$22 = {
  _init: function (_ref) {
    var count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$29 = createStream('bufferWithCount', mixin$22);
var P$25 = createProperty('bufferWithCount', mixin$22);

function bufferWhile$1(obs, count) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });
}

var mixin$23 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._wait = wait;
    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._flush();
    };
    this._buff = [];
  },
  _free: function () {
    this._$onTick = null;
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      clearInterval(this._intervalId);
      this._flush();
      this._intervalId = setInterval(this._$onTick, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd && this._buff.length !== 0) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._intervalId = setInterval(this._$onTick, this._wait);
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  },
  _onDeactivation: function () {
    if (this._intervalId !== null) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
    this._source.offAny(this._$handleAny); // copied from patterns/one-source
  }
};

var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);

function bufferWithTimeOrCount(obs, wait, count) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });
}

function xformForObs(obs) {
  return {
    '@@transducer/step': function (res, input) {
      obs._emitValue(input);
      return null;
    },
    '@@transducer/result': function () {
      obs._emitEnd();
      return null;
    }
  };
}

var mixin$24 = {
  _init: function (_ref) {
    var transducer = _ref.transducer;

    this._xform = transducer(xformForObs(this));
  },
  _free: function () {
    this._xform = null;
  },
  _handleValue: function (x) {
    if (this._xform['@@transducer/step'](null, x) !== null) {
      this._xform['@@transducer/result'](null);
    }
  },
  _handleEnd: function () {
    this._xform['@@transducer/result'](null);
  }
};

var S$31 = createStream('transduce', mixin$24);
var P$27 = createProperty('transduce', mixin$24);

function transduce(obs, transducer) {
  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
}

var mixin$25 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._handler = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._handler = null;
    this._emitter = null;
  },
  _handleAny: function (event) {
    this._handler(this._emitter, event);
  }
};

var S$32 = createStream('withHandler', mixin$25);
var P$28 = createProperty('withHandler', mixin$25);

function withHandler(obs, fn) {
  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
}

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function Zip(sources, combinator) {
  var _this = this;

  Stream.call(this);

  this._buffers = map(sources, function (source) {
    return isArray(source) ? cloneArray(source) : [];
  });
  this._sources = map(sources, function (source) {
    return isArray(source) ? never() : source;
  });

  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
    return x;
  };
  this._aliveCount = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Zip, Stream, {
  _name: 'zip',

  _onActivation: function () {
    // if all sources are arrays
    while (this._isFull()) {
      this._emit();
    }

    var length = this._sources.length;
    this._aliveCount = length;
    for (var i = 0; i < length && this._active; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0; i < this._sources.length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emit: function () {
    var values = new Array(this._buffers.length);
    for (var i = 0; i < this._buffers.length; i++) {
      values[i] = this._buffers[i].shift();
    }
    var combinator = this._combinator;
    this._emitValue(combinator(values));
  },
  _isFull: function () {
    for (var i = 0; i < this._buffers.length; i++) {
      if (this._buffers[i].length === 0) {
        return false;
      }
    }
    return true;
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE) {
      this._buffers[i].push(event.value);
      if (this._isFull()) {
        this._emit();
      }
    }
    if (event.type === ERROR) {
      this._emitError(event.value);
    }
    if (event.type === END) {
      this._aliveCount--;
      if (this._aliveCount === 0) {
        this._emitEnd();
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._buffers = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function zip(observables, combinator /* Function | falsey */) {
  return observables.length === 0 ? never() : new Zip(observables, combinator);
}

var id$8 = function (x) {
  return x;
};

function AbstractPool() {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$queueLim = _ref.queueLim,
      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,
      _ref$concurLim = _ref.concurLim,
      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,
      _ref$drop = _ref.drop,
      drop = _ref$drop === undefined ? 'new' : _ref$drop;

  Stream.call(this);

  this._queueLim = queueLim < 0 ? -1 : queueLim;
  this._concurLim = concurLim < 0 ? -1 : concurLim;
  this._drop = drop;
  this._queue = [];
  this._curSources = [];
  this._$handleSubAny = function (event) {
    return _this._handleSubAny(event);
  };
  this._$endHandlers = [];
  this._currentlyAdding = null;

  if (this._concurLim === 0) {
    this._emitEnd();
  }
}

inherit(AbstractPool, Stream, {
  _name: 'abstractPool',

  _add: function (obj, toObs /* Function | falsey */) {
    toObs = toObs || id$8;
    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
      this._addToCur(toObs(obj));
    } else {
      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
        this._addToQueue(toObs(obj));
      } else if (this._drop === 'old') {
        this._removeOldest();
        this._add(obj, toObs);
      }
    }
  },
  _addAll: function (obss) {
    var _this2 = this;

    forEach(obss, function (obs) {
      return _this2._add(obs);
    });
  },
  _remove: function (obs) {
    if (this._removeCur(obs) === -1) {
      this._removeQueue(obs);
    }
  },
  _addToQueue: function (obs) {
    this._queue = concat(this._queue, [obs]);
  },
  _addToCur: function (obs) {
    if (this._active) {
      // HACK:
      //
      // We have two optimizations for cases when `obs` is ended. We don't want
      // to add such observable to the list, but only want to emit events
      // from it (if it has some).
      //
      // Instead of this hacks, we could just did following,
      // but it would be 5-8 times slower:
      //
      //     this._curSources = concat(this._curSources, [obs]);
      //     this._subscribe(obs);
      //

      // #1
      // This one for cases when `obs` already ended
      // e.g., Kefir.constant() or Kefir.never()
      if (!obs._alive) {
        if (obs._currentEvent) {
          this._emit(obs._currentEvent.type, obs._currentEvent.value);
        }
        // The _emit above could have caused this stream to end.
        if (this._active) {
          if (this._queue.length !== 0) {
            this._pullQueue();
          } else if (this._curSources.length === 0) {
            this._onEmpty();
          }
        }
        return;
      }

      // #2
      // This one is for cases when `obs` going to end synchronously on
      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})
      this._currentlyAdding = obs;
      obs.onAny(this._$handleSubAny);
      this._currentlyAdding = null;
      if (obs._alive) {
        this._curSources = concat(this._curSources, [obs]);
        if (this._active) {
          this._subToEnd(obs);
        }
      } else {
        if (this._queue.length !== 0) {
          this._pullQueue();
        } else if (this._curSources.length === 0) {
          this._onEmpty();
        }
      }
    } else {
      this._curSources = concat(this._curSources, [obs]);
    }
  },
  _subToEnd: function (obs) {
    var _this3 = this;

    var onEnd = function () {
      return _this3._removeCur(obs);
    };
    this._$endHandlers.push({ obs: obs, handler: onEnd });
    obs.onEnd(onEnd);
  },
  _subscribe: function (obs) {
    obs.onAny(this._$handleSubAny);

    // it can become inactive in responce of subscribing to `obs.onAny` above
    if (this._active) {
      this._subToEnd(obs);
    }
  },
  _unsubscribe: function (obs) {
    obs.offAny(this._$handleSubAny);

    var onEndI = findByPred(this._$endHandlers, function (obj) {
      return obj.obs === obs;
    });
    if (onEndI !== -1) {
      obs.offEnd(this._$endHandlers[onEndI].handler);
      this._$endHandlers.splice(onEndI, 1);
    }
  },
  _handleSubAny: function (event) {
    if (event.type === VALUE) {
      this._emitValue(event.value);
    } else if (event.type === ERROR) {
      this._emitError(event.value);
    }
  },
  _removeQueue: function (obs) {
    var index = find(this._queue, obs);
    this._queue = remove(this._queue, index);
    return index;
  },
  _removeCur: function (obs) {
    if (this._active) {
      this._unsubscribe(obs);
    }
    var index = find(this._curSources, obs);
    this._curSources = remove(this._curSources, index);
    if (index !== -1) {
      if (this._queue.length !== 0) {
        this._pullQueue();
      } else if (this._curSources.length === 0) {
        this._onEmpty();
      }
    }
    return index;
  },
  _removeOldest: function () {
    this._removeCur(this._curSources[0]);
  },
  _pullQueue: function () {
    if (this._queue.length !== 0) {
      this._queue = cloneArray(this._queue);
      this._addToCur(this._queue.shift());
    }
  },
  _onActivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
      this._subscribe(sources[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length; i++) {
      this._unsubscribe(sources[i]);
    }
    if (this._currentlyAdding !== null) {
      this._unsubscribe(this._currentlyAdding);
    }
  },
  _isEmpty: function () {
    return this._curSources.length === 0;
  },
  _onEmpty: function () {},
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._queue = null;
    this._curSources = null;
    this._$handleSubAny = null;
    this._$endHandlers = null;
  }
});

function Merge(sources) {
  AbstractPool.call(this);
  this._addAll(sources);
  this._initialised = true;
}

inherit(Merge, AbstractPool, {
  _name: 'merge',

  _onEmpty: function () {
    if (this._initialised) {
      this._emitEnd();
    }
  }
});

function merge(observables) {
  return observables.length === 0 ? never() : new Merge(observables);
}

function S$33(generator) {
  var _this = this;

  Stream.call(this);
  this._generator = generator;
  this._source = null;
  this._inLoop = false;
  this._iteration = 0;
  this._$handleAny = function (event) {
    return _this._handleAny(event);
  };
}

inherit(S$33, Stream, {
  _name: 'repeat',

  _handleAny: function (event) {
    if (event.type === END) {
      this._source = null;
      this._getSource();
    } else {
      this._emit(event.type, event.value);
    }
  },
  _getSource: function () {
    if (!this._inLoop) {
      this._inLoop = true;
      var generator = this._generator;
      while (this._source === null && this._alive && this._active) {
        this._source = generator(this._iteration++);
        if (this._source) {
          this._source.onAny(this._$handleAny);
        } else {
          this._emitEnd();
        }
      }
      this._inLoop = false;
    }
  },
  _onActivation: function () {
    if (this._source) {
      this._source.onAny(this._$handleAny);
    } else {
      this._getSource();
    }
  },
  _onDeactivation: function () {
    if (this._source) {
      this._source.offAny(this._$handleAny);
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._generator = null;
    this._source = null;
    this._$handleAny = null;
  }
});

var repeat = function (generator) {
  return new S$33(generator);
};

function concat$1(observables) {
  return repeat(function (index) {
    return observables.length > index ? observables[index] : false;
  }).setName('concat');
}

function Pool() {
  AbstractPool.call(this);
}

inherit(Pool, AbstractPool, {
  _name: 'pool',

  plug: function (obs) {
    this._add(obs);
    return this;
  },
  unplug: function (obs) {
    this._remove(obs);
    return this;
  }
});

function FlatMap(source, fn, options) {
  var _this = this;

  AbstractPool.call(this, options);
  this._source = source;
  this._fn = fn;
  this._mainEnded = false;
  this._lastCurrent = null;
  this._$handleMain = function (event) {
    return _this._handleMain(event);
  };
}

inherit(FlatMap, AbstractPool, {
  _onActivation: function () {
    AbstractPool.prototype._onActivation.call(this);
    if (this._active) {
      this._source.onAny(this._$handleMain);
    }
  },
  _onDeactivation: function () {
    AbstractPool.prototype._onDeactivation.call(this);
    this._source.offAny(this._$handleMain);
    this._hadNoEvSinceDeact = true;
  },
  _handleMain: function (event) {
    if (event.type === VALUE) {
      // Is latest value before deactivation survived, and now is 'current' on this activation?
      // We don't want to handle such values, to prevent to constantly add
      // same observale on each activation/deactivation when our main source
      // is a `Kefir.conatant()` for example.
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === ERROR) {
      this._emitError(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  },
  _onEmpty: function () {
    if (this._mainEnded) {
      this._emitEnd();
    }
  },
  _clear: function () {
    AbstractPool.prototype._clear.call(this);
    this._source = null;
    this._lastCurrent = null;
    this._$handleMain = null;
  }
});

function FlatMapErrors(source, fn) {
  FlatMap.call(this, source, fn);
}

inherit(FlatMapErrors, FlatMap, {
  // Same as in FlatMap, only VALUE/ERROR flipped
  _handleMain: function (event) {
    if (event.type === ERROR) {
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === VALUE) {
      this._emitValue(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  }
});

function createConstructor$1(BaseClass, name) {
  return function AnonymousObservable(primary, secondary, options) {
    var _this = this;

    BaseClass.call(this);
    this._primary = primary;
    this._secondary = secondary;
    this._name = primary._name + '.' + name;
    this._lastSecondary = NOTHING;
    this._$handleSecondaryAny = function (event) {
      return _this._handleSecondaryAny(event);
    };
    this._$handlePrimaryAny = function (event) {
      return _this._handlePrimaryAny(event);
    };
    this._init(options);
  };
}

function createClassMethods$1(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handlePrimaryValue: function (x) {
      this._emitValue(x);
    },
    _handlePrimaryError: function (x) {
      this._emitError(x);
    },
    _handlePrimaryEnd: function () {
      this._emitEnd();
    },
    _handleSecondaryValue: function (x) {
      this._lastSecondary = x;
    },
    _handleSecondaryError: function (x) {
      this._emitError(x);
    },
    _handleSecondaryEnd: function () {},
    _handlePrimaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handlePrimaryValue(event.value);
        case ERROR:
          return this._handlePrimaryError(event.value);
        case END:
          return this._handlePrimaryEnd(event.value);
      }
    },
    _handleSecondaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleSecondaryValue(event.value);
        case ERROR:
          return this._handleSecondaryError(event.value);
        case END:
          this._handleSecondaryEnd(event.value);
          this._removeSecondary();
      }
    },
    _removeSecondary: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
        this._$handleSecondaryAny = null;
        this._secondary = null;
      }
    },
    _onActivation: function () {
      if (this._secondary !== null) {
        this._secondary.onAny(this._$handleSecondaryAny);
      }
      if (this._active) {
        this._primary.onAny(this._$handlePrimaryAny);
      }
    },
    _onDeactivation: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
      }
      this._primary.offAny(this._$handlePrimaryAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._primary = null;
      this._secondary = null;
      this._lastSecondary = null;
      this._$handleSecondaryAny = null;
      this._$handlePrimaryAny = null;
      this._free();
    }
  };
}

function createStream$1(name, mixin) {
  var S = createConstructor$1(Stream, name);
  inherit(S, Stream, createClassMethods$1(Stream), mixin);
  return S;
}

function createProperty$1(name, mixin) {
  var P = createConstructor$1(Property, name);
  inherit(P, Property, createClassMethods$1(Property), mixin);
  return P;
}

var mixin$26 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
      this._emitEnd();
    }
  }
};

var S$34 = createStream$1('filterBy', mixin$26);
var P$29 = createProperty$1('filterBy', mixin$26);

function filterBy(primary, secondary) {
  return new (primary._ofSameType(S$34, P$29))(primary, secondary);
}

var id2 = function (_, x) {
  return x;
};

function sampledBy(passive, active, combinator) {
  var _combinator = combinator ? function (a, b) {
    return combinator(b, a);
  } : id2;
  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
}

var mixin$27 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING) {
      this._emitEnd();
    }
  }
};

var S$35 = createStream$1('skipUntilBy', mixin$27);
var P$30 = createProperty$1('skipUntilBy', mixin$27);

function skipUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$35, P$30))(primary, secondary);
}

var mixin$28 = {
  _handleSecondaryValue: function () {
    this._emitEnd();
  }
};

var S$36 = createStream$1('takeUntilBy', mixin$28);
var P$31 = createProperty$1('takeUntilBy', mixin$28);

function takeUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$36, P$31))(primary, secondary);
}

var mixin$29 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._primary.onAny(this._$handlePrimaryAny);
    if (this._alive && this._secondary !== null) {
      this._secondary.onAny(this._$handleSecondaryAny);
    }
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
  },
  _handleSecondaryValue: function () {
    this._flush();
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd) {
      this._emitEnd();
    }
  }
};

var S$37 = createStream$1('bufferBy', mixin$29);
var P$32 = createProperty$1('bufferBy', mixin$29);

function bufferBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
}

var mixin$30 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,
        _ref$flushOnChange = _ref.flushOnChange,
        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
    this._flushOnChange = flushOnChange;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
      this._flush();
    }
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
      this._emitEnd();
    }
  },
  _handleSecondaryValue: function (x) {
    if (this._flushOnChange && !x) {
      this._flush();
    }

    // from default _handleSecondaryValue
    this._lastSecondary = x;
  }
};

var S$38 = createStream$1('bufferWhileBy', mixin$30);
var P$33 = createProperty$1('bufferWhileBy', mixin$30);

function bufferWhileBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
}

var f = function () {
  return false;
};
var t = function () {
  return true;
};

function awaiting(a, b) {
  var result = merge([map$1(a, t), map$1(b, f)]);
  result = skipDuplicates(result);
  result = toProperty(result, f);
  return result.setName(a, 'awaiting');
}

var mixin$31 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitError(result.error);
    } else {
      this._emitValue(x);
    }
  }
};

var S$39 = createStream('valuesToErrors', mixin$31);
var P$34 = createProperty('valuesToErrors', mixin$31);

var defFn = function (x) {
  return { convert: true, error: x };
};

function valuesToErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;

  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
}

var mixin$32 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitValue(result.value);
    } else {
      this._emitError(x);
    }
  }
};

var S$40 = createStream('errorsToValues', mixin$32);
var P$35 = createProperty('errorsToValues', mixin$32);

var defFn$1 = function (x) {
  return { convert: true, value: x };
};

function errorsToValues(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;

  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
}

var mixin$33 = {
  _handleError: function (x) {
    this._emitError(x);
    this._emitEnd();
  }
};

var S$41 = createStream('endOnError', mixin$33);
var P$36 = createProperty('endOnError', mixin$33);

function endOnError(obs) {
  return new (obs._ofSameType(S$41, P$36))(obs);
}

// Create a stream
// -----------------------------------------------------------------------------

// () -> Stream
// (number, any) -> Stream
// (number, any) -> Stream
// (number, Array<any>) -> Stream
// (number, Function) -> Stream
// (number, Function) -> Stream
// (Function) -> Stream
// (Function) -> Stream
// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}
// (Target, string, Function|undefined) -> Stream
// (Function) -> Stream
// Create a property
// -----------------------------------------------------------------------------

// (any) -> Property
// (any) -> Property
// Convert observables
// -----------------------------------------------------------------------------

// (Stream|Property, Function|undefined) -> Property
Observable.prototype.toProperty = function (fn) {
  return toProperty(this, fn);
};

// (Stream|Property) -> Stream
Observable.prototype.changes = function () {
  return changes(this);
};

// Interoperation with other implimentations
// -----------------------------------------------------------------------------

// (Promise) -> Property
// (Stream|Property, Function|undefined) -> Promise
Observable.prototype.toPromise = function (Promise) {
  return toPromise(this, Promise);
};

// (ESObservable) -> Stream
// (Stream|Property) -> ES7 Observable
Observable.prototype.toESObservable = toESObservable;
Observable.prototype[$$observable] = toESObservable;

// Modify an observable
// -----------------------------------------------------------------------------

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.map = function (fn) {
  return map$1(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filter = function (fn) {
  return filter(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.take = function (n) {
  return take(this, n);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.takeErrors = function (n) {
  return takeErrors(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.takeWhile = function (fn) {
  return takeWhile(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.last = function () {
  return last(this);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.skip = function (n) {
  return skip(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipWhile = function (fn) {
  return skipWhile(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipDuplicates = function (fn) {
  return skipDuplicates(this, fn);
};

// (Stream, Function|falsey, any|undefined) -> Stream
// (Property, Function|falsey, any|undefined) -> Property
Observable.prototype.diff = function (fn, seed) {
  return diff(this, fn, seed);
};

// (Stream|Property, Function, any|undefined) -> Property
Observable.prototype.scan = function (fn, seed) {
  return scan(this, fn, seed);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.flatten = function (fn) {
  return flatten(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.delay = function (wait) {
  return delay(this, wait);
};

// Options = {leading: boolean|undefined, trailing: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.throttle = function (wait, options) {
  return throttle(this, wait, options);
};

// Options = {immediate: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.debounce = function (wait, options) {
  return debounce(this, wait, options);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.mapErrors = function (fn) {
  return mapErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filterErrors = function (fn) {
  return filterErrors(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreValues = function () {
  return ignoreValues(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreErrors = function () {
  return ignoreErrors(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreEnd = function () {
  return ignoreEnd(this);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.beforeEnd = function (fn) {
  return beforeEnd(this, fn);
};

// (Stream, number, number|undefined) -> Stream
// (Property, number, number|undefined) -> Property
Observable.prototype.slidingWindow = function (max, min) {
  return slidingWindow(this, max, min);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Function|falsey, Options|undefined) -> Stream
// (Property, Function|falsey, Options|undefined) -> Property
Observable.prototype.bufferWhile = function (fn, options) {
  return bufferWhile(this, fn, options);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.bufferWithCount = function (count, options) {
  return bufferWhile$1(this, count, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, number, number, Options|undefined) -> Stream
// (Property, number, number, Options|undefined) -> Property
Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
  return bufferWithTimeOrCount(this, wait, count, options);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.transduce = function (transducer) {
  return transduce(this, transducer);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.withHandler = function (fn) {
  return withHandler(this, fn);
};

// (Stream, Stream -> a) -> a
// (Property, Property -> a) -> a
Observable.prototype.thru = function (fn) {
  return fn(this);
};

// Combine observables
// -----------------------------------------------------------------------------

// (Array<Stream|Property>, Function|undefiend) -> Stream
// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.combine = function (other, combinator) {
  return combine([this, other], combinator);
};

// (Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.zip = function (other, combinator) {
  return zip([this, other], combinator);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.merge = function (other) {
  return merge([this, other]);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.concat = function (other) {
  return concat$1([this, other]);
};

// () -> Pool
var pool = function () {
  return new Pool();
};

// (Function) -> Stream
// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}
// (Stream|Property, Function|falsey, Options|undefined) -> Stream
Observable.prototype.flatMap = function (fn) {
  return new FlatMap(this, fn).setName(this, 'flatMap');
};
Observable.prototype.flatMapLatest = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');
};
Observable.prototype.flatMapFirst = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
};
Observable.prototype.flatMapConcat = function (fn) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');
};
Observable.prototype.flatMapConcurLimit = function (fn, limit) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');
};

// (Stream|Property, Function|falsey) -> Stream
Observable.prototype.flatMapErrors = function (fn) {
  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
};

// Combine two observables
// -----------------------------------------------------------------------------

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.filterBy = function (other) {
  return filterBy(this, other);
};

// (Stream, Stream|Property, Function|undefiend) -> Stream
// (Property, Stream|Property, Function|undefiend) -> Property
Observable.prototype.sampledBy = function (other, combinator) {
  return sampledBy(this, other, combinator);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.skipUntilBy = function (other) {
  return skipUntilBy(this, other);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.takeUntilBy = function (other) {
  return takeUntilBy(this, other);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferBy = function (other, options) {
  return bufferBy(this, other, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferWhileBy = function (other, options) {
  return bufferWhileBy(this, other, options);
};

// Deprecated
// -----------------------------------------------------------------------------

var DEPRECATION_WARNINGS = true;
function dissableDeprecationWarnings() {
  DEPRECATION_WARNINGS = false;
}

function warn(msg) {
  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
    var msg2 = '\nHere is an Error object for you containing the call stack:';
    console.warn(msg, msg2, new Error());
  }
}

// (Stream|Property, Stream|Property) -> Property
Observable.prototype.awaiting = function (other) {
  warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');
  return awaiting(this, other);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.valuesToErrors = function (fn) {
  warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');
  return valuesToErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.errorsToValues = function (fn) {
  warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');
  return errorsToValues(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.endOnError = function () {
  warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');
  return endOnError(this);
};

// Exports
// --------------------------------------------------------------------------

var Kefir = {
  Observable: Observable,
  Stream: Stream,
  Property: Property,
  never: never,
  later: later,
  interval: interval,
  sequentially: sequentially,
  fromPoll: fromPoll,
  withInterval: withInterval,
  fromCallback: fromCallback,
  fromNodeCallback: fromNodeCallback,
  fromEvents: fromEvents,
  stream: stream,
  constant: constant,
  constantError: constantError,
  fromPromise: fromPromise,
  fromESObservable: fromESObservable,
  combine: combine,
  zip: zip,
  merge: merge,
  concat: concat$1,
  Pool: Pool,
  pool: pool,
  repeat: repeat,
  staticLand: staticLand
};

Kefir.Kefir = Kefir;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Kefir);


/***/ }),

/***/ 8552:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_365592__) => {

var getNative = __nested_webpack_require_365592__(852),
    root = __nested_webpack_require_365592__(5639);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 1989:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_365904__) => {

var hashClear = __nested_webpack_require_365904__(1789),
    hashDelete = __nested_webpack_require_365904__(401),
    hashGet = __nested_webpack_require_365904__(7667),
    hashHas = __nested_webpack_require_365904__(1327),
    hashSet = __nested_webpack_require_365904__(1866);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 8407:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_366759__) => {

var listCacheClear = __nested_webpack_require_366759__(7040),
    listCacheDelete = __nested_webpack_require_366759__(4125),
    listCacheGet = __nested_webpack_require_366759__(2117),
    listCacheHas = __nested_webpack_require_366759__(7518),
    listCacheSet = __nested_webpack_require_366759__(4705);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 7071:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_367712__) => {

var getNative = __nested_webpack_require_367712__(852),
    root = __nested_webpack_require_367712__(5639);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 3369:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_368009__) => {

var mapCacheClear = __nested_webpack_require_368009__(4785),
    mapCacheDelete = __nested_webpack_require_368009__(1285),
    mapCacheGet = __nested_webpack_require_368009__(6000),
    mapCacheHas = __nested_webpack_require_368009__(9916),
    mapCacheSet = __nested_webpack_require_368009__(5265);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 3818:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_368967__) => {

var getNative = __nested_webpack_require_368967__(852),
    root = __nested_webpack_require_368967__(5639);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 8525:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_369276__) => {

var getNative = __nested_webpack_require_369276__(852),
    root = __nested_webpack_require_369276__(5639);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 8668:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_369573__) => {

var MapCache = __nested_webpack_require_369573__(3369),
    setCacheAdd = __nested_webpack_require_369573__(619),
    setCacheHas = __nested_webpack_require_369573__(2385);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 6384:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_370301__) => {

var ListCache = __nested_webpack_require_370301__(8407),
    stackClear = __nested_webpack_require_370301__(7465),
    stackDelete = __nested_webpack_require_370301__(3779),
    stackGet = __nested_webpack_require_370301__(7599),
    stackHas = __nested_webpack_require_370301__(4758),
    stackSet = __nested_webpack_require_370301__(4309);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 2705:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_371141__) => {

var root = __nested_webpack_require_371141__(5639);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 1149:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_371360__) => {

var root = __nested_webpack_require_371360__(5639);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 577:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_371590__) => {

var getNative = __nested_webpack_require_371590__(852),
    root = __nested_webpack_require_371590__(5639);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 6874:
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ 7412:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 4963:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 7443:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_373923__) => {

var baseIndexOf = __nested_webpack_require_373923__(2118);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ 1196:
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ 4636:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_375205__) => {

var baseTimes = __nested_webpack_require_375205__(2545),
    isArguments = __nested_webpack_require_375205__(5694),
    isArray = __nested_webpack_require_375205__(1469),
    isBuffer = __nested_webpack_require_375205__(4144),
    isIndex = __nested_webpack_require_375205__(5776),
    isTypedArray = __nested_webpack_require_375205__(6719);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 9932:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 2488:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 2908:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 4865:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_378821__) => {

var baseAssignValue = __nested_webpack_require_378821__(9465),
    eq = __nested_webpack_require_378821__(7813);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ 8470:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_379820__) => {

var eq = __nested_webpack_require_379820__(7813);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 4037:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_380411__) => {

var copyObject = __nested_webpack_require_380411__(8363),
    keys = __nested_webpack_require_380411__(3674);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 3886:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_380984__) => {

var copyObject = __nested_webpack_require_380984__(8363),
    keysIn = __nested_webpack_require_380984__(1704);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 9465:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_381567__) => {

var defineProperty = __nested_webpack_require_381567__(8777);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ 9750:
/***/ ((module) => {

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;


/***/ }),

/***/ 5990:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_382901__) => {

var Stack = __nested_webpack_require_382901__(6384),
    arrayEach = __nested_webpack_require_382901__(7412),
    assignValue = __nested_webpack_require_382901__(4865),
    baseAssign = __nested_webpack_require_382901__(4037),
    baseAssignIn = __nested_webpack_require_382901__(3886),
    cloneBuffer = __nested_webpack_require_382901__(4626),
    copyArray = __nested_webpack_require_382901__(278),
    copySymbols = __nested_webpack_require_382901__(8805),
    copySymbolsIn = __nested_webpack_require_382901__(1911),
    getAllKeys = __nested_webpack_require_382901__(8234),
    getAllKeysIn = __nested_webpack_require_382901__(6904),
    getTag = __nested_webpack_require_382901__(4160),
    initCloneArray = __nested_webpack_require_382901__(3824),
    initCloneByTag = __nested_webpack_require_382901__(9148),
    initCloneObject = __nested_webpack_require_382901__(8517),
    isArray = __nested_webpack_require_382901__(1469),
    isBuffer = __nested_webpack_require_382901__(4144),
    isMap = __nested_webpack_require_382901__(6688),
    isObject = __nested_webpack_require_382901__(3218),
    isSet = __nested_webpack_require_382901__(2928),
    keys = __nested_webpack_require_382901__(3674),
    keysIn = __nested_webpack_require_382901__(1704);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 3118:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_388647__) => {

var isObject = __nested_webpack_require_388647__(3218);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 9881:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_389431__) => {

var baseForOwn = __nested_webpack_require_389431__(7816),
    createBaseEach = __nested_webpack_require_389431__(9291);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ 760:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_389977__) => {

var baseEach = __nested_webpack_require_389977__(9881);

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ 1848:
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ 1078:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_391477__) => {

var arrayPush = __nested_webpack_require_391477__(2488),
    isFlattenable = __nested_webpack_require_391477__(7285);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ 8483:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_392772__) => {

var createBaseFor = __nested_webpack_require_392772__(5063);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ 7816:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_393457__) => {

var baseFor = __nested_webpack_require_393457__(8483),
    keys = __nested_webpack_require_393457__(3674);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ 7786:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_394019__) => {

var castPath = __nested_webpack_require_394019__(1811),
    toKey = __nested_webpack_require_394019__(327);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 8866:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_394737__) => {

var arrayPush = __nested_webpack_require_394737__(2488),
    isArray = __nested_webpack_require_394737__(1469);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 4239:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_395577__) => {

var Symbol = __nested_webpack_require_395577__(2705),
    getRawTag = __nested_webpack_require_395577__(9607),
    objectToString = __nested_webpack_require_395577__(2333);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 8565:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ 13:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ 2118:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_397492__) => {

var baseFindIndex = __nested_webpack_require_397492__(1848),
    baseIsNaN = __nested_webpack_require_397492__(2722),
    strictIndexOf = __nested_webpack_require_397492__(2351);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ 7556:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_398243__) => {

var SetCache = __nested_webpack_require_398243__(8668),
    arrayIncludes = __nested_webpack_require_398243__(7443),
    arrayIncludesWith = __nested_webpack_require_398243__(1196),
    arrayMap = __nested_webpack_require_398243__(9932),
    baseUnary = __nested_webpack_require_398243__(1717),
    cacheHas = __nested_webpack_require_398243__(4757);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;


/***/ }),

/***/ 9454:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_400602__) => {

var baseGetTag = __nested_webpack_require_400602__(4239),
    isObjectLike = __nested_webpack_require_400602__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 939:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_401184__) => {

var baseIsEqualDeep = __nested_webpack_require_401184__(2492),
    isObjectLike = __nested_webpack_require_401184__(7005);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_402293__) => {

var Stack = __nested_webpack_require_402293__(6384),
    equalArrays = __nested_webpack_require_402293__(7114),
    equalByTag = __nested_webpack_require_402293__(8351),
    equalObjects = __nested_webpack_require_402293__(6096),
    getTag = __nested_webpack_require_402293__(4160),
    isArray = __nested_webpack_require_402293__(1469),
    isBuffer = __nested_webpack_require_402293__(4144),
    isTypedArray = __nested_webpack_require_402293__(6719);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 5588:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_405417__) => {

var getTag = __nested_webpack_require_405417__(4160),
    isObjectLike = __nested_webpack_require_405417__(7005);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 2958:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_405994__) => {

var Stack = __nested_webpack_require_405994__(6384),
    baseIsEqual = __nested_webpack_require_405994__(939);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ 2722:
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ 8458:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_408201__) => {

var isFunction = __nested_webpack_require_408201__(3560),
    isMasked = __nested_webpack_require_408201__(5346),
    isObject = __nested_webpack_require_408201__(3218),
    toSource = __nested_webpack_require_408201__(346);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 9221:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_409723__) => {

var getTag = __nested_webpack_require_409723__(4160),
    isObjectLike = __nested_webpack_require_409723__(7005);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_410300__) => {

var baseGetTag = __nested_webpack_require_410300__(4239),
    isLength = __nested_webpack_require_410300__(1780),
    isObjectLike = __nested_webpack_require_410300__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 7206:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_412621__) => {

var baseMatches = __nested_webpack_require_412621__(1573),
    baseMatchesProperty = __nested_webpack_require_412621__(6432),
    identity = __nested_webpack_require_412621__(6557),
    isArray = __nested_webpack_require_412621__(1469),
    property = __nested_webpack_require_412621__(9601);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ 280:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_413614__) => {

var isPrototype = __nested_webpack_require_413614__(5726),
    nativeKeys = __nested_webpack_require_413614__(6916);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 313:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_414484__) => {

var isObject = __nested_webpack_require_414484__(3218),
    isPrototype = __nested_webpack_require_414484__(5726),
    nativeKeysIn = __nested_webpack_require_414484__(3498);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ 9199:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_415451__) => {

var baseEach = __nested_webpack_require_415451__(9881),
    isArrayLike = __nested_webpack_require_415451__(8612);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ 1573:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_416217__) => {

var baseIsMatch = __nested_webpack_require_416217__(2958),
    getMatchData = __nested_webpack_require_416217__(1499),
    matchesStrictComparable = __nested_webpack_require_416217__(2634);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ 6432:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_417008__) => {

var baseIsEqual = __nested_webpack_require_417008__(939),
    get = __nested_webpack_require_417008__(7361),
    hasIn = __nested_webpack_require_417008__(9095),
    isKey = __nested_webpack_require_417008__(5403),
    isStrictComparable = __nested_webpack_require_417008__(9162),
    matchesStrictComparable = __nested_webpack_require_417008__(2634),
    toKey = __nested_webpack_require_417008__(327);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ 2689:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_418238__) => {

var arrayMap = __nested_webpack_require_418238__(9932),
    baseGet = __nested_webpack_require_418238__(7786),
    baseIteratee = __nested_webpack_require_418238__(7206),
    baseMap = __nested_webpack_require_418238__(9199),
    baseSortBy = __nested_webpack_require_418238__(1131),
    baseUnary = __nested_webpack_require_418238__(1717),
    compareMultiple = __nested_webpack_require_418238__(5022),
    identity = __nested_webpack_require_418238__(6557),
    isArray = __nested_webpack_require_418238__(1469);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ 371:
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ 9152:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_420314__) => {

var baseGet = __nested_webpack_require_420314__(7786);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ 8674:
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),

/***/ 5976:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_421208__) => {

var identity = __nested_webpack_require_421208__(6557),
    overRest = __nested_webpack_require_421208__(5357),
    setToString = __nested_webpack_require_421208__(61);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ 6560:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_421866__) => {

var constant = __nested_webpack_require_421866__(5703),
    defineProperty = __nested_webpack_require_421866__(8777),
    identity = __nested_webpack_require_421866__(6557);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ 1131:
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ 2545:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 531:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_423746__) => {

var Symbol = __nested_webpack_require_423746__(2705),
    arrayMap = __nested_webpack_require_423746__(9932),
    isArray = __nested_webpack_require_423746__(1469),
    isSymbol = __nested_webpack_require_423746__(3448);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 7561:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_425011__) => {

var trimmedEndIndex = __nested_webpack_require_425011__(7990);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ 1717:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 7415:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_425924__) => {

var arrayMap = __nested_webpack_require_425924__(9932);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ 4757:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 4387:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_426939__) => {

var isArrayLikeObject = __nested_webpack_require_426939__(9246);

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;


/***/ }),

/***/ 4290:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_427409__) => {

var identity = __nested_webpack_require_427409__(6557);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ 1811:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_427833__) => {

var isArray = __nested_webpack_require_427833__(1469),
    isKey = __nested_webpack_require_427833__(5403),
    stringToPath = __nested_webpack_require_427833__(5514),
    toString = __nested_webpack_require_427833__(9833);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 4318:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_428510__) => {

var Uint8Array = __nested_webpack_require_428510__(1149);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ 4626:
/***/ ((module, exports, __nested_webpack_require_429037__) => {

/* module decorator */ module = __nested_webpack_require_429037__.nmd(module);
var root = __nested_webpack_require_429037__(5639);

/** Detect free variable `exports`. */
var freeExports =   true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ 7157:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_430233__) => {

var cloneArrayBuffer = __nested_webpack_require_430233__(4318);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 3147:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 419:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_431314__) => {

var Symbol = __nested_webpack_require_431314__(2705);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 7133:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_431937__) => {

var cloneArrayBuffer = __nested_webpack_require_431937__(4318);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ 6393:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_432553__) => {

var isSymbol = __nested_webpack_require_432553__(3448);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ 5022:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_433994__) => {

var compareAscending = __nested_webpack_require_433994__(6393);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ 278:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ 8363:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_436182__) => {

var assignValue = __nested_webpack_require_436182__(4865),
    baseAssignValue = __nested_webpack_require_436182__(9465);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ 8805:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_437316__) => {

var copyObject = __nested_webpack_require_437316__(8363),
    getSymbols = __nested_webpack_require_437316__(9551);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 1911:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_437858__) => {

var copyObject = __nested_webpack_require_437858__(8363),
    getSymbolsIn = __nested_webpack_require_437858__(1442);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 4429:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_438422__) => {

var root = __nested_webpack_require_438422__(5639);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 9291:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_438680__) => {

var isArrayLike = __nested_webpack_require_438680__(8612);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ 5063:
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ 7740:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_440356__) => {

var baseIteratee = __nested_webpack_require_440356__(7206),
    isArrayLike = __nested_webpack_require_440356__(8612),
    keys = __nested_webpack_require_440356__(3674);

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ 8777:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_441311__) => {

var getNative = __nested_webpack_require_441311__(852);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 7114:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_441639__) => {

var SetCache = __nested_webpack_require_441639__(8668),
    arraySome = __nested_webpack_require_441639__(2908),
    cacheHas = __nested_webpack_require_441639__(4757);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 8351:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_444403__) => {

var Symbol = __nested_webpack_require_444403__(2705),
    Uint8Array = __nested_webpack_require_444403__(1149),
    eq = __nested_webpack_require_444403__(7813),
    equalArrays = __nested_webpack_require_444403__(7114),
    mapToArray = __nested_webpack_require_444403__(8776),
    setToArray = __nested_webpack_require_444403__(1814);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 6096:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_448261__) => {

var getAllKeys = __nested_webpack_require_448261__(8234);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 9464:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_451327__) => {

var basePropertyOf = __nested_webpack_require_451327__(8674);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_451897__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __nested_webpack_require_451897__.g == 'object' && __nested_webpack_require_451897__.g && __nested_webpack_require_451897__.g.Object === Object && __nested_webpack_require_451897__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 8234:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_452224__) => {

var baseGetAllKeys = __nested_webpack_require_452224__(8866),
    getSymbols = __nested_webpack_require_452224__(9551),
    keys = __nested_webpack_require_452224__(3674);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 6904:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_452779__) => {

var baseGetAllKeys = __nested_webpack_require_452779__(8866),
    getSymbolsIn = __nested_webpack_require_452779__(1442),
    keysIn = __nested_webpack_require_452779__(1704);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 5050:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_453363__) => {

var isKeyable = __nested_webpack_require_453363__(7019);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 1499:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_453859__) => {

var isStrictComparable = __nested_webpack_require_453859__(9162),
    keys = __nested_webpack_require_453859__(3674);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ 852:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_454526__) => {

var baseIsNative = __nested_webpack_require_454526__(8458),
    getValue = __nested_webpack_require_454526__(7801);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 5924:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_455105__) => {

var overArg = __nested_webpack_require_455105__(5569);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ 9607:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_455366__) => {

var Symbol = __nested_webpack_require_455366__(2705);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 9551:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_456604__) => {

var arrayFilter = __nested_webpack_require_456604__(4963),
    stubArray = __nested_webpack_require_456604__(479);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 1442:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_457586__) => {

var arrayPush = __nested_webpack_require_457586__(2488),
    getPrototype = __nested_webpack_require_457586__(5924),
    getSymbols = __nested_webpack_require_457586__(9551),
    stubArray = __nested_webpack_require_457586__(479);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 4160:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_458438__) => {

var DataView = __nested_webpack_require_458438__(8552),
    Map = __nested_webpack_require_458438__(7071),
    Promise = __nested_webpack_require_458438__(3818),
    Set = __nested_webpack_require_458438__(8525),
    WeakMap = __nested_webpack_require_458438__(577),
    baseGetTag = __nested_webpack_require_458438__(4239),
    toSource = __nested_webpack_require_458438__(346);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 7801:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 222:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_460770__) => {

var castPath = __nested_webpack_require_460770__(1811),
    isArguments = __nested_webpack_require_460770__(5694),
    isArray = __nested_webpack_require_460770__(1469),
    isIndex = __nested_webpack_require_460770__(5776),
    isLength = __nested_webpack_require_460770__(1780),
    toKey = __nested_webpack_require_460770__(327);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_461971__) => {

var nativeCreate = __nested_webpack_require_461971__(4536);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 401:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_462836__) => {

var nativeCreate = __nested_webpack_require_462836__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 1327:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_463701__) => {

var nativeCreate = __nested_webpack_require_463701__(4536);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 1866:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_464420__) => {

var nativeCreate = __nested_webpack_require_464420__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 3824:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 9148:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_465850__) => {

var cloneArrayBuffer = __nested_webpack_require_465850__(4318),
    cloneDataView = __nested_webpack_require_465850__(7157),
    cloneRegExp = __nested_webpack_require_465850__(3147),
    cloneSymbol = __nested_webpack_require_465850__(419),
    cloneTypedArray = __nested_webpack_require_465850__(7133);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 8517:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_468193__) => {

var baseCreate = __nested_webpack_require_468193__(3118),
    getPrototype = __nested_webpack_require_468193__(5924),
    isPrototype = __nested_webpack_require_468193__(5726);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ 7285:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_468773__) => {

var Symbol = __nested_webpack_require_468773__(2705),
    isArguments = __nested_webpack_require_468773__(5694),
    isArray = __nested_webpack_require_468773__(1469);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ 5776:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 6612:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_470292__) => {

var eq = __nested_webpack_require_470292__(7813),
    isArrayLike = __nested_webpack_require_470292__(8612),
    isIndex = __nested_webpack_require_470292__(5776),
    isObject = __nested_webpack_require_470292__(3218);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ 5403:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_471282__) => {

var isArray = __nested_webpack_require_471282__(1469),
    isSymbol = __nested_webpack_require_471282__(3448);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 7019:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 5346:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_472742__) => {

var coreJsData = __nested_webpack_require_472742__(4429);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 5726:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 9162:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_473928__) => {

var isObject = __nested_webpack_require_473928__(3218);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ 7040:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 4125:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_474705__) => {

var assocIndexOf = __nested_webpack_require_474705__(8470);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 2117:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_475573__) => {

var assocIndexOf = __nested_webpack_require_475573__(8470);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 7518:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_476086__) => {

var assocIndexOf = __nested_webpack_require_476086__(8470);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 4705:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_476582__) => {

var assocIndexOf = __nested_webpack_require_476582__(8470);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 4785:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_477228__) => {

var Hash = __nested_webpack_require_477228__(1989),
    ListCache = __nested_webpack_require_477228__(8407),
    Map = __nested_webpack_require_477228__(7071);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 1285:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_477732__) => {

var getMapData = __nested_webpack_require_477732__(5050);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 6000:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_478277__) => {

var getMapData = __nested_webpack_require_478277__(5050);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 9916:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_478702__) => {

var getMapData = __nested_webpack_require_478702__(5050);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5265:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_479179__) => {

var getMapData = __nested_webpack_require_479179__(5050);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 8776:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 2634:
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ 4523:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_480794__) => {

var memoize = __nested_webpack_require_480794__(8306);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 4536:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_481526__) => {

var getNative = __nested_webpack_require_481526__(852);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 6916:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_481808__) => {

var overArg = __nested_webpack_require_481808__(5569);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 3498:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ 1167:
/***/ ((module, exports, __nested_webpack_require_482630__) => {

/* module decorator */ module = __nested_webpack_require_482630__.nmd(module);
var freeGlobal = __nested_webpack_require_482630__(1957);

/** Detect free variable `exports`. */
var freeExports =   true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 2333:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 5569:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 5357:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_484800__) => {

var apply = __nested_webpack_require_484800__(6874);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ 5639:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_485996__) => {

var freeGlobal = __nested_webpack_require_485996__(1957);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 619:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 2385:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 1814:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 61:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_487614__) => {

var baseSetToString = __nested_webpack_require_487614__(6560),
    shortOut = __nested_webpack_require_487614__(1275);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ 1275:
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ 7465:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_489087__) => {

var ListCache = __nested_webpack_require_489087__(8407);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 3779:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 7599:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 4758:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 4309:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_490577__) => {

var ListCache = __nested_webpack_require_490577__(8407),
    Map = __nested_webpack_require_490577__(7071),
    MapCache = __nested_webpack_require_490577__(3369);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 2351:
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ 5514:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_492184__) => {

var memoizeCapped = __nested_webpack_require_492184__(4523);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 327:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_493115__) => {

var isSymbol = __nested_webpack_require_493115__(3448);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 346:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 7990:
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ 9567:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_494900__) => {

var toInteger = __nested_webpack_require_494900__(554);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;


/***/ }),

/***/ 6678:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_496086__) => {

var baseClone = __nested_webpack_require_496086__(5990);

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ 5703:
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ 6073:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_497822__) => {

module.exports = __nested_webpack_require_497822__(4486);


/***/ }),

/***/ 7813:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 1675:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_498806__) => {

var escapeHtmlChar = __nested_webpack_require_498806__(9464),
    toString = __nested_webpack_require_498806__(9833);

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),

/***/ 3105:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_500345__) => {

var arrayFilter = __nested_webpack_require_500345__(4963),
    baseFilter = __nested_webpack_require_500345__(760),
    baseIteratee = __nested_webpack_require_500345__(7206),
    isArray = __nested_webpack_require_500345__(1469);

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ 3311:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_502126__) => {

var createFind = __nested_webpack_require_502126__(7740),
    findIndex = __nested_webpack_require_502126__(998);

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ 998:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_503526__) => {

var baseFindIndex = __nested_webpack_require_503526__(1848),
    baseIteratee = __nested_webpack_require_503526__(7206),
    toInteger = __nested_webpack_require_503526__(554);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ 5564:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_505273__) => {

var baseFlatten = __nested_webpack_require_505273__(1078);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ 4486:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_505856__) => {

var arrayEach = __nested_webpack_require_505856__(7412),
    baseEach = __nested_webpack_require_505856__(9881),
    castFunction = __nested_webpack_require_505856__(4290),
    isArray = __nested_webpack_require_505856__(1469);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ 7361:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_507314__) => {

var baseGet = __nested_webpack_require_507314__(7786);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 8721:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_508296__) => {

var baseHas = __nested_webpack_require_508296__(8565),
    hasPath = __nested_webpack_require_508296__(222);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ 9095:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_509154__) => {

var baseHasIn = __nested_webpack_require_509154__(13),
    hasPath = __nested_webpack_require_509154__(222);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ 6557:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 4721:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_510421__) => {

var baseIndexOf = __nested_webpack_require_510421__(2118),
    isArrayLike = __nested_webpack_require_510421__(8612),
    isString = __nested_webpack_require_510421__(7037),
    toInteger = __nested_webpack_require_510421__(554),
    values = __nested_webpack_require_510421__(2628);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;


/***/ }),

/***/ 5325:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_512300__) => {

var arrayMap = __nested_webpack_require_512300__(9932),
    baseIntersection = __nested_webpack_require_512300__(7556),
    baseRest = __nested_webpack_require_512300__(5976),
    castArrayLikeObject = __nested_webpack_require_512300__(4387);

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;


/***/ }),

/***/ 5694:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_513340__) => {

var baseIsArguments = __nested_webpack_require_513340__(9454),
    isObjectLike = __nested_webpack_require_513340__(7005);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 1469:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_514991__) => {

var isFunction = __nested_webpack_require_514991__(3560),
    isLength = __nested_webpack_require_514991__(1780);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 9246:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_515921__) => {

var isArrayLike = __nested_webpack_require_515921__(8612),
    isObjectLike = __nested_webpack_require_515921__(7005);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ 4144:
/***/ ((module, exports, __nested_webpack_require_516741__) => {

/* module decorator */ module = __nested_webpack_require_516741__.nmd(module);
var root = __nested_webpack_require_516741__(5639),
    stubFalse = __nested_webpack_require_516741__(5062);

/** Detect free variable `exports`. */
var freeExports =   true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 3560:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_517998__) => {

var baseGetTag = __nested_webpack_require_517998__(4239),
    isObject = __nested_webpack_require_517998__(3218);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 1780:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 6688:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_519939__) => {

var baseIsMap = __nested_webpack_require_519939__(5588),
    baseUnary = __nested_webpack_require_519939__(1717),
    nodeUtil = __nested_webpack_require_519939__(1167);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 3218:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 7005:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 2928:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_522094__) => {

var baseIsSet = __nested_webpack_require_522094__(9221),
    baseUnary = __nested_webpack_require_522094__(1717),
    nodeUtil = __nested_webpack_require_522094__(1167);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 7037:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_522808__) => {

var baseGetTag = __nested_webpack_require_522808__(4239),
    isArray = __nested_webpack_require_522808__(1469),
    isObjectLike = __nested_webpack_require_522808__(7005);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ 3448:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_523631__) => {

var baseGetTag = __nested_webpack_require_523631__(4239),
    isObjectLike = __nested_webpack_require_523631__(7005);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 6719:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_524408__) => {

var baseIsTypedArray = __nested_webpack_require_524408__(8749),
    baseUnary = __nested_webpack_require_524408__(1717),
    nodeUtil = __nested_webpack_require_524408__(1167);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 3674:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_525197__) => {

var arrayLikeKeys = __nested_webpack_require_525197__(4636),
    baseKeys = __nested_webpack_require_525197__(280),
    isArrayLike = __nested_webpack_require_525197__(8612);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 1704:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_526176__) => {

var arrayLikeKeys = __nested_webpack_require_526176__(4636),
    baseKeysIn = __nested_webpack_require_526176__(313),
    isArrayLike = __nested_webpack_require_526176__(8612);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ 928:
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ 8306:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_527494__) => {

var MapCache = __nested_webpack_require_527494__(3369);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 308:
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ 1463:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_530111__) => {

var before = __nested_webpack_require_530111__(9567);

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;


/***/ }),

/***/ 9601:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_530876__) => {

var baseProperty = __nested_webpack_require_530876__(371),
    basePropertyDeep = __nested_webpack_require_530876__(9152),
    isKey = __nested_webpack_require_530876__(5403),
    toKey = __nested_webpack_require_530876__(327);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ 9734:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_531767__) => {

var baseFlatten = __nested_webpack_require_531767__(1078),
    baseOrderBy = __nested_webpack_require_531767__(2689),
    baseRest = __nested_webpack_require_531767__(5976),
    isIterateeCall = __nested_webpack_require_531767__(6612);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ 240:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_533528__) => {

var baseClamp = __nested_webpack_require_533528__(9750),
    baseToString = __nested_webpack_require_533528__(531),
    toInteger = __nested_webpack_require_533528__(554),
    toString = __nested_webpack_require_533528__(9833);

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

module.exports = startsWith;


/***/ }),

/***/ 479:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 5062:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 8601:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_535408__) => {

var toNumber = __nested_webpack_require_535408__(4841);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ 554:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_536373__) => {

var toFinite = __nested_webpack_require_536373__(8601);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ 4841:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_537231__) => {

var baseTrim = __nested_webpack_require_537231__(7561),
    isObject = __nested_webpack_require_537231__(3218),
    isSymbol = __nested_webpack_require_537231__(3448);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ 9833:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_538855__) => {

var baseToString = __nested_webpack_require_538855__(531);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 2628:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_539527__) => {

var baseValues = __nested_webpack_require_539527__(7415),
    keys = __nested_webpack_require_539527__(3674);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ 5936:
/***/ ((module, exports, __nested_webpack_require_540346__) => {

"use strict";


exports.__esModule = true;
exports["default"] = match;
var proto = __nested_webpack_require_540346__.g.Element && __nested_webpack_require_540346__.g.Element.prototype;
var vendor = proto && (proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector);

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var parentNode = el.parentNode;

  if (parentNode && typeof parentNode.querySelectorAll === 'function') {
    var nodes = parentNode.querySelectorAll(selector);

    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] === el) return true;
    }
  }

  return false;
}

module.exports = exports.default;
module.exports["default"] = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJwcm90byIsImdsb2JhbCIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJ2ZW5kb3IiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibWF0Y2giLCJlbCIsInNlbGVjdG9yIiwiY2FsbCIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwibm9kZXMiLCJpIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUEsSUFBTUEsS0FBSyxHQUFHQyxNQUFNLENBQUNDLE9BQVAsSUFBa0JELE1BQU0sQ0FBQ0MsT0FBUCxDQUFlQyxTQUEvQztBQUNBLElBQU1DLE1BQU0sR0FBR0osS0FBSyxLQUFLQSxLQUFLLENBQUNLLE9BQU4sSUFDcEJMLEtBQUssQ0FBQ00sZUFEYyxJQUVwQk4sS0FBSyxDQUFDTyxxQkFGYyxJQUdwQlAsS0FBSyxDQUFDUSxrQkFIYyxJQUlwQlIsS0FBSyxDQUFDUyxpQkFKYyxJQUtwQlQsS0FBSyxDQUFDVSxnQkFMUyxDQUFwQjs7QUFPZSxTQUFTQyxLQUFULENBQWVDLEVBQWYsRUFBZ0NDLFFBQWhDLEVBQTJEO0FBQ3hFLE1BQUlULE1BQUosRUFBWSxPQUFPQSxNQUFNLENBQUNVLElBQVAsQ0FBWUYsRUFBWixFQUFnQkMsUUFBaEIsQ0FBUDtBQUQ0RCxNQUVqRUUsVUFGaUUsR0FFbkRILEVBRm1ELENBRWpFRyxVQUZpRTs7QUFHeEUsTUFBSUEsVUFBVSxJQUFJLE9BQVFBLFVBQUQsQ0FBaUJDLGdCQUF4QixLQUE2QyxVQUEvRCxFQUEyRTtBQUN6RSxRQUFNQyxLQUFLLEdBQUlGLFVBQUQsQ0FBaUJDLGdCQUFqQixDQUFrQ0gsUUFBbEMsQ0FBZDs7QUFDQSxTQUFLLElBQUlLLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELEtBQUssQ0FBQ0UsTUFBMUIsRUFBa0NELENBQUMsRUFBbkMsRUFBdUM7QUFDckMsVUFBSUQsS0FBSyxDQUFDQyxDQUFELENBQUwsS0FBYU4sRUFBakIsRUFBcUIsT0FBTyxJQUFQO0FBQ3RCO0FBQ0Y7O0FBQ0QsU0FBTyxLQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5jb25zdCBwcm90byA9IGdsb2JhbC5FbGVtZW50ICYmIGdsb2JhbC5FbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHZlbmRvciA9IHByb3RvICYmIChwcm90by5tYXRjaGVzXG4gIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3IpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXRjaChlbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIGNvbnN0IHtwYXJlbnROb2RlfSA9IGVsO1xuICBpZiAocGFyZW50Tm9kZSAmJiB0eXBlb2YgKHBhcmVudE5vZGU6YW55KS5xdWVyeVNlbGVjdG9yQWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgbm9kZXMgPSAocGFyZW50Tm9kZTphbnkpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChub2Rlc1tpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iXX0=

/***/ }),

/***/ 443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.Z = delay;

function delay(time, value) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve(value);
    }, time);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWxheSIsInRpbWUiLCJ2YWx1ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVlLFNBQVNBLEtBQVQsQ0FBa0JDLElBQWxCLEVBQWdDQyxLQUFoQyxFQUFtRTtBQUNoRixTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFBQyxPQUFPLEVBQUk7QUFDNUJDLElBQUFBLFVBQVUsQ0FBQyxZQUFNO0FBQ2ZELE1BQUFBLE9BQU8sQ0FBQ0YsS0FBRCxDQUFQO0FBQ0QsS0FGUyxFQUVQRCxJQUZPLENBQVY7QUFHRCxHQUpNLENBQVA7QUFLRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlbGF5PFQ+KHRpbWU6IG51bWJlciwgdmFsdWU6IFByb21pc2U8VD4gfCBUKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0sIHRpbWUpO1xuICB9KTtcbn1cbiJdfQ==

/***/ }),

/***/ 9335:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 8795:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ 7735:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_549894__) => {

"use strict";


exports.decode = exports.parse = __nested_webpack_require_549894__(9335);
exports.encode = exports.stringify = __nested_webpack_require_549894__(8795);


/***/ }),

/***/ 1095:
/***/ ((module) => {


// basic protocol helpers

var symbolExists = typeof Symbol !== 'undefined';

var protocols = {
  iterator: symbolExists ? Symbol.iterator : '@@iterator'
};

function throwProtocolError(name, coll) {
  throw new Error("don't know how to " + name + " collection: " +
                  coll);
}

function fulfillsProtocol(obj, name) {
  if(name === 'iterator') {
    // Accept ill-formed iterators that don't conform to the
    // protocol by accepting just next()
    return obj[protocols.iterator] || obj.next;
  }

  return obj[protocols[name]];
}

function getProtocolProperty(obj, name) {
  return obj[protocols[name]];
}

function iterator(coll) {
  var iter = getProtocolProperty(coll, 'iterator');
  if(iter) {
    return iter.call(coll);
  }
  else if(coll.next) {
    // Basic duck typing to accept an ill-formed iterator that doesn't
    // conform to the iterator protocol (all iterators should have the
    // @@iterator method and return themselves, but some engines don't
    // have that on generators like older v8)
    return coll;
  }
  else if(isArray(coll)) {
    return new ArrayIterator(coll);
  }
  else if(isObject(coll)) {
    return new ObjectIterator(coll);
  }
}

function ArrayIterator(arr) {
  this.arr = arr;
  this.index = 0;
}

ArrayIterator.prototype.next = function() {
  if(this.index < this.arr.length) {
    return {
      value: this.arr[this.index++],
      done: false
    };
  }
  return {
    done: true
  }
};

function ObjectIterator(obj) {
  this.obj = obj;
  this.keys = Object.keys(obj);
  this.index = 0;
}

ObjectIterator.prototype.next = function() {
  if(this.index < this.keys.length) {
    var k = this.keys[this.index++];
    return {
      value: [k, this.obj[k]],
      done: false
    };
  }
  return {
    done: true
  }
};

// helpers

var toString = Object.prototype.toString;
var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {
  return toString.call(obj) == '[object Array]';
};

function isFunction(x) {
  return typeof x === 'function';
}

function isObject(x) {
  return x instanceof Object &&
    Object.getPrototypeOf(x) === Object.getPrototypeOf({});
}

function isNumber(x) {
  return typeof x === 'number';
}

function Reduced(value) {
  this['@@transducer/reduced'] = true;
  this['@@transducer/value'] = value;
}

function isReduced(x) {
  return (x instanceof Reduced) || (x && x['@@transducer/reduced']);
}

function deref(x) {
  return x['@@transducer/value'];
}

/**
 * This is for transforms that may call their nested transforms before
 * Reduced-wrapping the result (e.g. "take"), to avoid nested Reduced.
 */
function ensureReduced(val) {
  if(isReduced(val)) {
    return val;
  } else {
    return new Reduced(val);
  }
}

/**
 * This is for tranforms that call their nested transforms when
 * performing completion (like "partition"), to avoid signaling
 * termination after already completing.
 */
function ensureUnreduced(v) {
  if(isReduced(v)) {
    return deref(v);
  } else {
    return v;
  }
}

function reduce(coll, xform, init) {
  if(isArray(coll)) {
    var result = init;
    var index = -1;
    var len = coll.length;
    while(++index < len) {
      result = xform['@@transducer/step'](result, coll[index]);
      if(isReduced(result)) {
        result = deref(result);
        break;
      }
    }
    return xform['@@transducer/result'](result);
  }
  else if(isObject(coll) || fulfillsProtocol(coll, 'iterator')) {
    var result = init;
    var iter = iterator(coll);
    var val = iter.next();
    while(!val.done) {
      result = xform['@@transducer/step'](result, val.value);
      if(isReduced(result)) {
        result = deref(result);
        break;
      }
      val = iter.next();
    }
    return xform['@@transducer/result'](result);
  }
  throwProtocolError('iterate', coll);
}

function transduce(coll, xform, reducer, init) {
  xform = xform(reducer);
  if(init === undefined) {
    init = xform['@@transducer/init']();
  }
  return reduce(coll, xform, init);
}

function compose() {
  var funcs = Array.prototype.slice.call(arguments);
  return function(r) {
    var value = r;
    for(var i=funcs.length-1; i>=0; i--) {
      value = funcs[i](value);
    }
    return value;
  }
}

// transformations

function transformer(f) {
  var t = {};
  t['@@transducer/init'] = function() {
    throw new Error('init value unavailable');
  };
  t['@@transducer/result'] = function(v) {
    return v;
  };
  t['@@transducer/step'] = f;
  return t;
}

function bound(f, ctx, count) {
  count = count != null ? count : 1;

  if(!ctx) {
    return f;
  }
  else {
    switch(count) {
    case 1:
      return function(x) {
        return f.call(ctx, x);
      }
    case 2:
      return function(x, y) {
        return f.call(ctx, x, y);
      }
    default:
      return f.bind(ctx);
    }
  }
}

function arrayMap(arr, f, ctx) {
  var index = -1;
  var length = arr.length;
  var result = Array(length);
  f = bound(f, ctx, 2);

  while (++index < length) {
    result[index] = f(arr[index], index);
  }
  return result;
}

function arrayFilter(arr, f, ctx) {
  var len = arr.length;
  var result = [];
  f = bound(f, ctx, 2);

  for(var i=0; i<len; i++) {
    if(f(arr[i], i)) {
      result.push(arr[i]);
    }
  }
  return result;
}

function Map(f, xform) {
  this.xform = xform;
  this.f = f;
}

Map.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Map.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Map.prototype['@@transducer/step'] = function(res, input) {
  return this.xform['@@transducer/step'](res, this.f(input));
};

function map(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    if(isArray(coll)) {
      return arrayMap(coll, f, ctx);
    }
    return seq(coll, map(f));
  }

  return function(xform) {
    return new Map(f, xform);
  }
}

function Filter(f, xform) {
  this.xform = xform;
  this.f = f;
}

Filter.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Filter.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Filter.prototype['@@transducer/step'] = function(res, input) {
  if(this.f(input)) {
    return this.xform['@@transducer/step'](res, input);
  }
  return res;
};

function filter(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    if(isArray(coll)) {
      return arrayFilter(coll, f, ctx);
    }
    return seq(coll, filter(f));
  }

  return function(xform) {
    return new Filter(f, xform);
  };
}

function remove(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);
  return filter(coll, function(x) { return !f(x); });
}

function keep(coll) {
  return filter(coll, function(x) { return x != null });
}

function Dedupe(xform) {
  this.xform = xform;
  this.last = undefined;
}

Dedupe.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Dedupe.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Dedupe.prototype['@@transducer/step'] = function(result, input) {
  if(input !== this.last) {
    this.last = input;
    return this.xform['@@transducer/step'](result, input);
  }
  return result;
};

function dedupe(coll) {
  if(coll) {
    return seq(coll, dedupe());
  }

  return function(xform) {
    return new Dedupe(xform);
  }
}

function TakeWhile(f, xform) {
  this.xform = xform;
  this.f = f;
}

TakeWhile.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

TakeWhile.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

TakeWhile.prototype['@@transducer/step'] = function(result, input) {
  if(this.f(input)) {
    return this.xform['@@transducer/step'](result, input);
  }
  return new Reduced(result);
};

function takeWhile(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    return seq(coll, takeWhile(f));
  }

  return function(xform) {
    return new TakeWhile(f, xform);
  }
}

function Take(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
}

Take.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Take.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Take.prototype['@@transducer/step'] = function(result, input) {
  if (this.i < this.n) {
    result = this.xform['@@transducer/step'](result, input);
    if(this.i + 1 >= this.n) {
      // Finish reducing on the same step as the final value. TODO:
      // double-check that this doesn't break any semantics
      result = ensureReduced(result);
    }
  }
  this.i++;
  return result;
};

function take(coll, n) {
  if(isNumber(coll)) { n = coll; coll = null }

  if(coll) {
    return seq(coll, take(n));
  }

  return function(xform) {
    return new Take(n, xform);
  }
}

function Drop(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
}

Drop.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Drop.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Drop.prototype['@@transducer/step'] = function(result, input) {
  if(this.i++ < this.n) {
    return result;
  }
  return this.xform['@@transducer/step'](result, input);
};

function drop(coll, n) {
  if(isNumber(coll)) { n = coll; coll = null }

  if(coll) {
    return seq(coll, drop(n));
  }

  return function(xform) {
    return new Drop(n, xform);
  }
}

function DropWhile(f, xform) {
  this.xform = xform;
  this.f = f;
  this.dropping = true;
}

DropWhile.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

DropWhile.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

DropWhile.prototype['@@transducer/step'] = function(result, input) {
  if(this.dropping) {
    if(this.f(input)) {
      return result;
    }
    else {
      this.dropping = false;
    }
  }
  return this.xform['@@transducer/step'](result, input);
};

function dropWhile(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    return seq(coll, dropWhile(f));
  }

  return function(xform) {
    return new DropWhile(f, xform);
  }
}

function Partition(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
  this.part = new Array(n);
}

Partition.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Partition.prototype['@@transducer/result'] = function(v) {
  if (this.i > 0) {
    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, this.i)));
  }
  return this.xform['@@transducer/result'](v);
};

Partition.prototype['@@transducer/step'] = function(result, input) {
  this.part[this.i] = input;
  this.i += 1;
  if (this.i === this.n) {
    var out = this.part.slice(0, this.n);
    this.part = new Array(this.n);
    this.i = 0;
    return this.xform['@@transducer/step'](result, out);
  }
  return result;
};

function partition(coll, n) {
  if (isNumber(coll)) {
    n = coll; coll = null;
  }

  if (coll) {
    return seq(coll, partition(n));
  }

  return function(xform) {
    return new Partition(n, xform);
  };
}

var NOTHING = {};

function PartitionBy(f, xform) {
  // TODO: take an "opts" object that allows the user to specify
  // equality
  this.f = f;
  this.xform = xform;
  this.part = [];
  this.last = NOTHING;
}

PartitionBy.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

PartitionBy.prototype['@@transducer/result'] = function(v) {
  var l = this.part.length;
  if (l > 0) {
    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, l)));
  }
  return this.xform['@@transducer/result'](v);
};

PartitionBy.prototype['@@transducer/step'] = function(result, input) {
  var current = this.f(input);
  if (current === this.last || this.last === NOTHING) {
    this.part.push(input);
  } else {
    result = this.xform['@@transducer/step'](result, this.part);
    this.part = [input];
  }
  this.last = current;
  return result;
};

function partitionBy(coll, f, ctx) {
  if (isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if (coll) {
    return seq(coll, partitionBy(f));
  }

  return function(xform) {
    return new PartitionBy(f, xform);
  };
}

function Interpose(sep, xform) {
  this.sep = sep;
  this.xform = xform;
  this.started = false;
}

Interpose.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Interpose.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Interpose.prototype['@@transducer/step'] = function(result, input) {
  if (this.started) {
    var withSep = this.xform['@@transducer/step'](result, this.sep);
    if (isReduced(withSep)) {
      return withSep;
    } else {
      return this.xform['@@transducer/step'](withSep, input);
    }
  } else {
    this.started = true;
    return this.xform['@@transducer/step'](result, input);
  }
};

/**
 * Returns a new collection containing elements of the given
 * collection, separated by the specified separator. Returns a
 * transducer if a collection is not provided.
 */
function interpose(coll, separator) {
  if (arguments.length === 1) {
    separator = coll;
    return function(xform) {
      return new Interpose(separator, xform);
    };
  }
  return seq(coll, interpose(separator));
}

function Repeat(n, xform) {
  this.xform = xform;
  this.n = n;
}

Repeat.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Repeat.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Repeat.prototype['@@transducer/step'] = function(result, input) {
  var n = this.n;
  var r = result;
  for (var i = 0; i < n; i++) {
    r = this.xform['@@transducer/step'](r, input);
    if (isReduced(r)) {
      break;
    }
  }
  return r;
};

/**
 * Returns a new collection containing elements of the given
 * collection, each repeated n times. Returns a transducer if a
 * collection is not provided.
 */
function repeat(coll, n) {
  if (arguments.length === 1) {
    n = coll;
    return function(xform) {
      return new Repeat(n, xform);
    };
  }
  return seq(coll, repeat(n));
}

function TakeNth(n, xform) {
  this.xform = xform;
  this.n = n;
  this.i = -1;
}

TakeNth.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

TakeNth.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

TakeNth.prototype['@@transducer/step'] = function(result, input) {
  this.i += 1;
  if (this.i % this.n === 0) {
    return this.xform['@@transducer/step'](result, input);
  }
  return result;
};

/**
 * Returns a new collection of every nth element of the given
 * collection. Returns a transducer if a collection is not provided.
 */
function takeNth(coll, nth) {
  if (arguments.length === 1) {
    nth = coll;
    return function(xform) {
      return new TakeNth(nth, xform);
    };
  }
  return seq(coll, takeNth(nth));
}

// pure transducers (cannot take collections)

function Cat(xform) {
  this.xform = xform;
}

Cat.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Cat.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Cat.prototype['@@transducer/step'] = function(result, input) {
  var xform = this.xform;
  var newxform = {};
  newxform['@@transducer/init'] = function() {
    return xform['@@transducer/init']();
  };
  newxform['@@transducer/result'] = function(v) {
    return v;
  };
  newxform['@@transducer/step'] = function(result, input) {
    var val = xform['@@transducer/step'](result, input);
    return isReduced(val) ? deref(val) : val;
  };

  return reduce(input, newxform, result);
};

function cat(xform) {
  return new Cat(xform);
}

function mapcat(f, ctx) {
  f = bound(f, ctx);
  return compose(map(f), cat);
}

// collection helpers

function push(arr, x) {
  arr.push(x);
  return arr;
}

function merge(obj, x) {
  if(isArray(x) && x.length === 2) {
    obj[x[0]] = x[1];
  }
  else {
    var keys = Object.keys(x);
    var len = keys.length;
    for(var i=0; i<len; i++) {
      obj[keys[i]] = x[keys[i]];
    }
  }
  return obj;
}

var arrayReducer = {};
arrayReducer['@@transducer/init'] = function() {
  return [];
};
arrayReducer['@@transducer/result'] = function(v) {
  return v;
};
arrayReducer['@@transducer/step'] = push;

var objReducer = {};
objReducer['@@transducer/init'] = function() {
  return {};
};
objReducer['@@transducer/result'] = function(v) {
  return v;
};
objReducer['@@transducer/step'] = merge;

// building new collections

function toArray(coll, xform) {
  if(!xform) {
    return reduce(coll, arrayReducer, []);
  }
  return transduce(coll, xform, arrayReducer, []);
}

function toObj(coll, xform) {
  if(!xform) {
    return reduce(coll, objReducer, {});
  }
  return transduce(coll, xform, objReducer, {});
}

function toIter(coll, xform) {
  if(!xform) {
    return iterator(coll);
  }
  return new LazyTransformer(xform, coll);
}

function seq(coll, xform) {
  if(isArray(coll)) {
    return transduce(coll, xform, arrayReducer, []);
  }
  else if(isObject(coll)) {
    return transduce(coll, xform, objReducer, {});
  }
  else if(coll['@@transducer/step']) {
    var init;
    if(coll['@@transducer/init']) {
      init = coll['@@transducer/init']();
    }
    else {
      init = new coll.constructor();
    }

    return transduce(coll, xform, coll, init);
  }
  else if(fulfillsProtocol(coll, 'iterator')) {
    return new LazyTransformer(xform, coll);
  }
  throwProtocolError('sequence', coll);
}

function into(to, xform, from) {
  if(isArray(to)) {
    return transduce(from, xform, arrayReducer, to);
  }
  else if(isObject(to)) {
    return transduce(from, xform, objReducer, to);
  }
  else if(to['@@transducer/step']) {
    return transduce(from,
                     xform,
                     to,
                     to);
  }
  throwProtocolError('into', to);
}

// laziness

var stepper = {};
stepper['@@transducer/result'] = function(v) {
  return isReduced(v) ? deref(v) : v;
};
stepper['@@transducer/step'] = function(lt, x) {
  lt.items.push(x);
  return lt.rest;
};

function Stepper(xform, iter) {
  this.xform = xform(stepper);
  this.iter = iter;
}

Stepper.prototype['@@transducer/step'] = function(lt) {
  var len = lt.items.length;
  while(lt.items.length === len) {
    var n = this.iter.next();
    if(n.done || isReduced(n.value)) {
      // finalize
      this.xform['@@transducer/result'](this);
      break;
    }

    // step
    this.xform['@@transducer/step'](lt, n.value);
  }
}

function LazyTransformer(xform, coll) {
  this.iter = iterator(coll);
  this.items = [];
  this.stepper = new Stepper(xform, iterator(coll));
}

LazyTransformer.prototype[protocols.iterator] = function() {
  return this;
}

LazyTransformer.prototype.next = function() {
  this['@@transducer/step']();

  if(this.items.length) {
    return {
      value: this.items.pop(),
      done: false
    }
  }
  else {
    return { done: true };
  }
};

LazyTransformer.prototype['@@transducer/step'] = function() {
  if(!this.items.length) {
    this.stepper['@@transducer/step'](this);
  }
}

// util

function range(n) {
  var arr = new Array(n);
  for(var i=0; i<arr.length; i++) {
    arr[i] = i;
  }
  return arr;
}

module.exports = {
  reduce: reduce,
  transformer: transformer,
  Reduced: Reduced,
  isReduced: isReduced,
  iterator: iterator,
  push: push,
  merge: merge,
  transduce: transduce,
  seq: seq,
  toArray: toArray,
  toObj: toObj,
  toIter: toIter,
  into: into,
  compose: compose,
  map: map,
  filter: filter,
  remove: remove,
  cat: cat,
  mapcat: mapcat,
  keep: keep,
  dedupe: dedupe,
  take: take,
  takeWhile: takeWhile,
  takeNth: takeNth,
  drop: drop,
  dropWhile: dropWhile,
  partition: partition,
  partitionBy: partitionBy,
  interpose: interpose,
  repeat: repeat,
  range: range,

  LazyTransformer: LazyTransformer
};


/***/ }),

/***/ 1010:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_570691__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports.defn = defn;
__webpack_unused_export__ = defobj;
__webpack_unused_export__ = defonce;
__webpack_unused_export__ = markReloadable;
var range = __nested_webpack_require_570691__(3758);
var zipObject = __nested_webpack_require_570691__(3687);
var moduleUsedUdKeys = new WeakMap();
function markReloadable(module) {
  if (module.hot) {
    module.hot.accept();
  }
}
function defonce(module, fn) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  markReloadable(module);
  var usedKeys = moduleUsedUdKeys.get(module);
  if (!usedKeys) {
    usedKeys = new Set();
    moduleUsedUdKeys.set(module, usedKeys);
  }
  if (usedKeys.has(key)) {
    throw new Error('ud functions can only be used once per module with a given key');
  }
  usedKeys.add(key);
  var valueWasSet = false;
  var value = undefined;
  if (module.hot) {
    if (module.hot.data && module.hot.data.__ud__ && Object.prototype.hasOwnProperty.call(module.hot.data.__ud__, key)) {
      value = module.hot.data.__ud__[key];
      valueWasSet = true;
    }
    module.hot.dispose(function (data) {
      if (!data.__ud__) data.__ud__ = {};
      data.__ud__[key] = value;
    });
  }
  if (!valueWasSet) value = fn();
  return value;
}
function defobj(module, object) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var sharedObject = defonce(module, function () {
    return object;
  }, '--defobj-' + key);
  if (sharedObject !== object) {
    cloneOntoTarget(sharedObject, object);
  }
  return sharedObject;
}

// Assigns all properties of object onto target, and deletes any properties
// from target that don't exist on object. The optional blacklist argument
// specifies properties to not assign on target.
function cloneOntoTarget(target, object) {
  Object.getOwnPropertyNames(target).filter(function (name) {
    return !Object.prototype.hasOwnProperty.call(object, name);
  }).forEach(function (name) {
    delete target[name];
  });
  var newPropsChain = Object.getOwnPropertyNames(object);
  Object.defineProperties(target, zipObject(newPropsChain, newPropsChain.map(function (name) {
    return Object.getOwnPropertyDescriptor(object, name);
  }).filter(Boolean).map(function (_ref) {
    var value = _ref.value,
      enumerable = _ref.enumerable;
    return {
      value: value,
      enumerable: enumerable,
      writable: true,
      configurable: true
    };
  })));
  return target;
}
function defn(module, fn) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var shared = defonce(module, function () {
    if (!module.hot) {
      return {
        fn: null,
        wrapper: fn
      };
    }
    var shared = {
      fn: null,
      wrapper: null
    };
    var paramsList = range(fn.length).map(function (x) {
      return 'a' + x;
    }).join(',');
    shared.wrapper = new Function('shared', "\n      'use strict';\n      return function ".concat(fn.name, "__ud_wrapper(").concat(paramsList, ") {\n        if (new.target) {\n          return Reflect.construct(shared.fn, arguments, new.target);\n        } else {\n          return shared.fn.apply(this, arguments);\n        }\n      };\n      "))(shared);
    if (fn.prototype) {
      shared.wrapper.prototype = Object.create(fn.prototype);
      shared.wrapper.prototype.constructor = shared.wrapper;
    } else {
      shared.wrapper.prototype = fn.prototype;
    }
    return shared;
  }, '--defn-shared-' + key);
  shared.fn = fn;
  if (module.hot) {
    if (fn.prototype && shared.wrapper.prototype && Object.getPrototypeOf(shared.wrapper.prototype) !== fn.prototype) {
      Object.setPrototypeOf(shared.wrapper.prototype, fn.prototype);
    }
    Object.setPrototypeOf(shared.wrapper, fn);
  }
  return shared.wrapper;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJyYW5nZSIsInJlcXVpcmUiLCJ6aXBPYmplY3QiLCJtb2R1bGVVc2VkVWRLZXlzIiwiV2Vha01hcCIsIm1hcmtSZWxvYWRhYmxlIiwibW9kdWxlIiwiaG90IiwiYWNjZXB0IiwiZGVmb25jZSIsImZuIiwia2V5IiwidXNlZEtleXMiLCJnZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJFcnJvciIsImFkZCIsInZhbHVlV2FzU2V0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJkYXRhIiwiX191ZF9fIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGlzcG9zZSIsImRlZm9iaiIsIm9iamVjdCIsInNoYXJlZE9iamVjdCIsImNsb25lT250b1RhcmdldCIsInRhcmdldCIsImdldE93blByb3BlcnR5TmFtZXMiLCJmaWx0ZXIiLCJuYW1lIiwiZm9yRWFjaCIsIm5ld1Byb3BzQ2hhaW4iLCJkZWZpbmVQcm9wZXJ0aWVzIiwibWFwIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiQm9vbGVhbiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImRlZm4iLCJzaGFyZWQiLCJ3cmFwcGVyIiwicGFyYW1zTGlzdCIsImxlbmd0aCIsIngiLCJqb2luIiwiRnVuY3Rpb24iLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImdldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiXSwic291cmNlcyI6WyIuLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuY29uc3QgcmFuZ2UgPSByZXF1aXJlKCdhcnJheS1yYW5nZScpO1xuY29uc3QgemlwT2JqZWN0ID0gcmVxdWlyZSgnemlwLW9iamVjdCcpO1xuY29uc3QgbW9kdWxlVXNlZFVkS2V5czogV2Vha01hcDx0eXBlb2YgbW9kdWxlLCBTZXQ8c3RyaW5nPj4gPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFya1JlbG9hZGFibGUobW9kdWxlOiB0eXBlb2YgbW9kdWxlKSB7XG4gIGlmICgobW9kdWxlOmFueSkuaG90KSB7XG4gICAgKG1vZHVsZTphbnkpLmhvdC5hY2NlcHQoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmb25jZTxUPihtb2R1bGU6IHR5cGVvZiBtb2R1bGUsIGZuOiAoKT0+VCwga2V5PzpzdHJpbmc9JycpOiBUIHtcbiAgbWFya1JlbG9hZGFibGUobW9kdWxlKTtcbiAgbGV0IHVzZWRLZXlzID0gbW9kdWxlVXNlZFVkS2V5cy5nZXQobW9kdWxlKTtcbiAgaWYgKCF1c2VkS2V5cykge1xuICAgIHVzZWRLZXlzID0gbmV3IFNldCgpO1xuICAgIG1vZHVsZVVzZWRVZEtleXMuc2V0KG1vZHVsZSwgdXNlZEtleXMpO1xuICB9XG4gIGlmICh1c2VkS2V5cy5oYXMoa2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndWQgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIHVzZWQgb25jZSBwZXIgbW9kdWxlIHdpdGggYSBnaXZlbiBrZXknKTtcbiAgfVxuICB1c2VkS2V5cy5hZGQoa2V5KTtcbiAgbGV0IHZhbHVlV2FzU2V0ID0gZmFsc2U7XG4gIGxldCB2YWx1ZTogYW55ID0gdW5kZWZpbmVkO1xuICBpZiAoKG1vZHVsZTphbnkpLmhvdCkge1xuICAgIGlmIChcbiAgICAgIChtb2R1bGU6YW55KS5ob3QuZGF0YSAmJlxuICAgICAgKG1vZHVsZTphbnkpLmhvdC5kYXRhLl9fdWRfXyAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKChtb2R1bGU6YW55KS5ob3QuZGF0YS5fX3VkX18sIGtleSlcbiAgICApIHtcbiAgICAgIHZhbHVlID0gKG1vZHVsZTphbnkpLmhvdC5kYXRhLl9fdWRfX1trZXldO1xuICAgICAgdmFsdWVXYXNTZXQgPSB0cnVlO1xuICAgIH1cbiAgICAobW9kdWxlOmFueSkuaG90LmRpc3Bvc2UoZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEuX191ZF9fKVxuICAgICAgICBkYXRhLl9fdWRfXyA9IHt9O1xuICAgICAgZGF0YS5fX3VkX19ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGlmICghdmFsdWVXYXNTZXQpXG4gICAgdmFsdWUgPSBmbigpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZvYmo8VDogT2JqZWN0Pihtb2R1bGU6IHR5cGVvZiBtb2R1bGUsIG9iamVjdDogVCwga2V5PzpzdHJpbmc9JycpOiBUIHtcbiAgY29uc3Qgc2hhcmVkT2JqZWN0ID0gZGVmb25jZShtb2R1bGUsICgpPT5vYmplY3QsICctLWRlZm9iai0nK2tleSk7XG4gIGlmIChzaGFyZWRPYmplY3QgIT09IG9iamVjdCkge1xuICAgIGNsb25lT250b1RhcmdldChzaGFyZWRPYmplY3QsIG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHNoYXJlZE9iamVjdDtcbn1cblxuLy8gQXNzaWducyBhbGwgcHJvcGVydGllcyBvZiBvYmplY3Qgb250byB0YXJnZXQsIGFuZCBkZWxldGVzIGFueSBwcm9wZXJ0aWVzXG4vLyBmcm9tIHRhcmdldCB0aGF0IGRvbid0IGV4aXN0IG9uIG9iamVjdC4gVGhlIG9wdGlvbmFsIGJsYWNrbGlzdCBhcmd1bWVudFxuLy8gc3BlY2lmaWVzIHByb3BlcnRpZXMgdG8gbm90IGFzc2lnbiBvbiB0YXJnZXQuXG5mdW5jdGlvbiBjbG9uZU9udG9UYXJnZXQ8VDogT2JqZWN0Pih0YXJnZXQ6IFQsIG9iamVjdDogT2JqZWN0KTogVCB7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAuZmlsdGVyKG5hbWUgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKVxuICAgIC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgZGVsZXRlIHRhcmdldFtuYW1lXTtcbiAgICB9KTtcbiAgY29uc3QgbmV3UHJvcHNDaGFpbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIHRhcmdldCxcbiAgICB6aXBPYmplY3QobmV3UHJvcHNDaGFpbiwgbmV3UHJvcHNDaGFpblxuICAgICAgLm1hcChuYW1lID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lKSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5tYXAoKHt2YWx1ZSxlbnVtZXJhYmxlfSkgPT5cbiAgICAgICAgKHt2YWx1ZSxlbnVtZXJhYmxlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9KVxuICAgICAgKVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZm48VDogRnVuY3Rpb24+KG1vZHVsZTogdHlwZW9mIG1vZHVsZSwgZm46IFQsIGtleT86c3RyaW5nPScnKTogVCB7XG4gIGNvbnN0IHNoYXJlZCA9IGRlZm9uY2UobW9kdWxlLCAoKT0+e1xuICAgIGlmICghKG1vZHVsZTphbnkpLmhvdCkge1xuICAgICAgcmV0dXJuIHtmbjogKG51bGw6ID9UKSwgd3JhcHBlcjogZm59O1xuICAgIH1cbiAgICBjb25zdCBzaGFyZWQ6IE9iamVjdCA9IHtmbjogbnVsbCwgd3JhcHBlcjogbnVsbH07XG4gICAgY29uc3QgcGFyYW1zTGlzdCA9IHJhbmdlKGZuLmxlbmd0aCkubWFwKHggPT4gJ2EnK3gpLmpvaW4oJywnKTtcbiAgICBzaGFyZWQud3JhcHBlciA9IChuZXcgRnVuY3Rpb24oXG4gICAgICAnc2hhcmVkJyxcbiAgICAgIGBcbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAke2ZuLm5hbWV9X191ZF93cmFwcGVyKCR7cGFyYW1zTGlzdH0pIHtcbiAgICAgICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3Qoc2hhcmVkLmZuLCBhcmd1bWVudHMsIG5ldy50YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzaGFyZWQuZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGBcbiAgICApOiBhbnkpKHNoYXJlZCk7XG4gICAgaWYgKGZuLnByb3RvdHlwZSkge1xuICAgICAgKHNoYXJlZC53cmFwcGVyOmFueSkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmbi5wcm90b3R5cGUpO1xuICAgICAgKHNoYXJlZC53cmFwcGVyOmFueSkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc2hhcmVkLndyYXBwZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIChzaGFyZWQud3JhcHBlcjphbnkpLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXJlZDtcbiAgfSwgJy0tZGVmbi1zaGFyZWQtJytrZXkpO1xuICBzaGFyZWQuZm4gPSBmbjtcbiAgaWYgKChtb2R1bGU6YW55KS5ob3QpIHtcbiAgICBpZiAoZm4ucHJvdG90eXBlICYmIChzaGFyZWQud3JhcHBlcjphbnkpLnByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoKHNoYXJlZC53cmFwcGVyOmFueSkucHJvdG90eXBlKSAhPT0gZm4ucHJvdG90eXBlKSB7XG4gICAgICAoT2JqZWN0OiBhbnkpLnNldFByb3RvdHlwZU9mKChzaGFyZWQud3JhcHBlcjphbnkpLnByb3RvdHlwZSwgZm4ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgKE9iamVjdDogYW55KS5zZXRQcm90b3R5cGVPZihzaGFyZWQud3JhcHBlciwgZm4pO1xuICB9XG4gIHJldHVybiBzaGFyZWQud3JhcHBlcjtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUEsSUFBTUEsS0FBSyxHQUFHQyxPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3BDLElBQU1DLFNBQVMsR0FBR0QsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUN2QyxJQUFNRSxn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

/***/ }),

/***/ 3687:
/***/ ((module) => {

var zipObject = function (keys, values) {
  if (arguments.length == 1) {
    values = keys[1];
    keys = keys[0];
  }
    
  var result = {};
  var i = 0;
  
  for (i; i < keys.length; i += 1) {
    result[keys[i]] = values[i];
  }
  
  return result;
};

module.exports = zipObject;

/***/ }),

/***/ 3897:
/***/ ((module) => {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 3405:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586099__) => {

var arrayLikeToArray = __nested_webpack_require_586099__(3897);
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4836:
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 9498:
/***/ ((module) => {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 2281:
/***/ ((module) => {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 861:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587394__) => {

var arrayWithoutHoles = __nested_webpack_require_587394__(3405);
var iterableToArray = __nested_webpack_require_587394__(9498);
var unsupportedIterableToArray = __nested_webpack_require_587394__(6116);
var nonIterableSpread = __nested_webpack_require_587394__(2281);
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 8698:
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6116:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_588548__) => {

var arrayLikeToArray = __nested_webpack_require_588548__(3897);
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_589406__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_589406__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_589406__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_589406__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_589406__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_589406__.o(definition, key) && !__nested_webpack_require_589406__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_589406__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nested_webpack_require_589406__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/* eslint-disable @typescript-eslint/no-var-requires */

if (!__nested_webpack_require_589406__.g.__InboxSDKInjected) {
  __nested_webpack_require_589406__.g.__InboxSDKInjected = true;
  const logger = __nested_webpack_require_589406__(5895);
  let oldDefine;
  try {
    if (  true && __nested_webpack_require_589406__.amdD && __nested_webpack_require_589406__.amdO) {
      // work around amd compatibility issue
      // https://groups.google.com/forum/#!msg/inboxsdk/U_bq82Exmwc/I3iIinxxCAAJ
      oldDefine = __nested_webpack_require_589406__.amdD;
      __nested_webpack_require_589406__.amdD = null;
    }
    const extCorbWorkaroundPageWorld = __nested_webpack_require_589406__(9979);
    const xhrHelper = (__nested_webpack_require_589406__(7640)/* ["default"] */ .Z);
    const setupDataExposer = (__nested_webpack_require_589406__(2726)/* ["default"] */ .Z);
    const setupEventReemitter = (__nested_webpack_require_589406__(7835)/* ["default"] */ .Z);
    const setupErrorSilencer = (__nested_webpack_require_589406__(8892)/* ["default"] */ .Z);
    const setupCustomViewEventAssassin = (__nested_webpack_require_589406__(3060)/* ["default"] */ .Z);
    const setupPushStateListener = (__nested_webpack_require_589406__(7012)/* ["default"] */ .Z);
    const setupInboxCustomViewLinkFixer = (__nested_webpack_require_589406__(5290)/* ["default"] */ .Z);
    const gmailInterceptor = (__nested_webpack_require_589406__(1513)/* ["default"] */ .Z);
    const setupGmonkeyHandler = (__nested_webpack_require_589406__(7131)/* ["default"] */ .Z);
    const pageOrigin =   false || document.location.origin;
    if (pageOrigin === 'https://mail.google.com') {
      gmailInterceptor();
      setupGmonkeyHandler();
    } else {
      throw new Error('Should not happen');
    }
    extCorbWorkaroundPageWorld.init();
    xhrHelper();
    setupDataExposer();
    setupEventReemitter();
    setupErrorSilencer();
    setupCustomViewEventAssassin();
    setupPushStateListener();
    setupInboxCustomViewLinkFixer();
  } catch (err) {
    logger.error(err);
  } finally {
    if (oldDefine) {
      __nested_webpack_require_589406__.amdD = oldDefine;
    }
  }
}
})();

/******/ })()
;
//# sourceMappingURL=pageWorld.js.map
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QWtELGtEQUFrRDtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBOztBQUVBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxRQUFRO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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QUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdEQUFnRCxvQ0FBb0M7QUFDcEY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0NBQXNDLEVBQUUsNEJBQTRCLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFNBQVMsVUFBVTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsU0FBUyxVQUFVO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixTQUFTLFVBQVU7QUFDNUM7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDs7QUFFQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixTQUFTLFVBQVU7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsVUFBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsVUFBVTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFNBQVMsVUFBVTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsU0FBUyxVQUFVO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QUFDLENBQUM7TUFDbEJwUixtQkFBbUIsQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsTUFBTTtNQUNMLE1BQU0sSUFBSTdrQixLQUFLLENBQUMsbUJBQW1CLENBQUM7SUFDdEM7SUFFQSsxQiwwQkFBMEIsQ0FBQ0ssSUFBSSxDQUFDLENBQUM7SUFDakNySyxTQUFTLENBQUMsQ0FBQztJQUNYMUUsZ0JBQWdCLENBQUMsQ0FBQztJQUNsQjJCLG1CQUFtQixDQUFDLENBQUM7SUFDckJOLGtCQUFrQixDQUFDLENBQUM7SUFDcEJ5Qyw0QkFBNEIsQ0FBQyxDQUFDO0lBQzlCTyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hCTiw2QkFBNkIsQ0FBQyxDQUFDO0VBQ2pDLENBQUMsQ0FBQyxPQUFPMXBCLEdBQUcsRUFBRTtJQUNaaUwsTUFBTSxDQUFDNUcsS0FBSyxDQUFDckUsR0FBRyxDQUFDO0VBQ25CLENBQUMsU0FBUztJQUNSLElBQUlrMEIsU0FBUyxFQUFFO01BQ2JDLGlDQUFBQSxLQUFNLEdBQUdELFNBQVM7SUFDcEI7RUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2FycmF5LXJhbmdlL2luZGV4LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9hdXRvLWh0bWwvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2NvbW1vbi9jYWNoZWJ1c3QtdXJsLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9jb21tb24vYWpheC50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvY29tbW9uL2Fzc2VydC50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvY29tbW9uL2h0bWwtdG8tdGV4dC50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvbW9kaWZ5LXN1Z2dlc3Rpb25zLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy94aHItcHJveHktZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvdGhyZWFkLWlkZW50aWZpZXIvdGhyZWFkLXJvdy1wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2luamVjdGVkLWpzL2dtYWlsL3RocmVhZC1pZGVudGlmaWVyL2NsaWNrLWFuZC1nZXQtcG9wdXAtdXJsLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9jb21tb24vZmluZC1wYXJlbnQudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2xpYi9kb20vY3VzdG9tLWV2ZW50cy50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvdGhyZWFkLWlkZW50aWZpZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2xpYi9pc05vdE5pbC50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1zeW5jLXJlc3BvbnNlLXByb2Nlc3Nvci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1kcml2ZXIvZ2V0U3luY1RocmVhZEZyb21TeW5jVGhyZWFkSWQudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2luamVjdGVkLWpzL21lc3NhZ2UtbWV0YWRhdGEtaG9sZGVyLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9jb21tb24vcXVvdGVkLXNwbGl0LnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9jb21tb24vZGVmZXIudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2luamVjdGVkLWpzL2dtYWlsL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvc3luYy1jb21wb3NlLXByb2Nlc3Nvci0yMDIyMDkwOS50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvc3luYy1jb21wb3NlLXJlcXVlc3QtcHJvY2Vzc29yLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9nbWFpbC9zeW5jLWNvbXBvc2UtcHJvY2Vzc29yLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9nbWFpbC9zZXR1cC1nbWFpbC1pbnRlcmNlcHRvci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvZ21haWwvc2V0dXAtZ21vbmtleS1oYW5kbGVyLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9pbmplY3RlZC1sb2dnZXIudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2xpYi93YWl0LWZvci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvc2V0dXAtZGF0YS1leHBvc2VyLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9zZXR1cC1lcnJvci1zaWxlbmNlci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvc2V0dXAtZXZlbnQtcmVlbWl0dGVyLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9zZXR1cEN1c3RvbVZpZXdFdmVudEFzc2Fzc2luLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL3NyYy9pbmplY3RlZC1qcy9zZXR1cEluYm94Q3VzdG9tVmlld0xpbmtGaXhlci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMvc2V0dXBQdXNoU3RhdGVMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvaW5qZWN0ZWQtanMveGhyLWhlbHBlci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1yZXNwb25zZS1wcm9jZXNzb3IudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RyaXZlci1jb21tb24vZ2V0QWNjb3VudFVybFBhcnQudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2xpYi9pbWFnZVJlcXVlc3QudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2NvbW1vbi9yYXRlLWxpbWl0LXF1ZXVlci50cyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9zcmMvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZHJpdmVyLWNvbW1vbi9nbWFpbEFqYXgudHMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RyaXZlci1jb21tb24vcmVxdWVzdEdtYWlsVGhyZWFkLnRzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9jbG9zZXN0LW5nL2pzL2luZGV4LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9leHQtY29yYi13b3JrYXJvdW5kL2Rpc3Qvc3JjL21vZHVsZUlkLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9leHQtY29yYi13b3JrYXJvdW5kL2Rpc3Qvc3JjL3BhZ2VXb3JsZC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvZXh0LWNvcmItd29ya2Fyb3VuZC9kaXN0L3NyYy90cmFuc2ZlcnJhYmxlcy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMva2VmaXIvZGlzdC9rZWZpci5lc20uanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsYW1wLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5T2YuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTb3J0QnkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0QXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUZpbmQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXNjYXBlSHRtbENoYXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RyaW1tZWRFbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2JlZm9yZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xhc3QuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL29uY2UuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0YXJ0c1dpdGguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL21hdGNoZXMtc2VsZWN0b3ItbmcvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL3BkZWxheS9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy90cmFuc2R1Y2Vycy5qcy90cmFuc2R1Y2Vycy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvdWQvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL3ppcC1vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9oZWxsby13b3JsZC9pbmJveHNka18yLjEuOS0xNjk3MTEwOTQ0MjExLWJjYzMyYjRmZjc1Y2MxNjIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9hbWQgZGVmaW5lIiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi93ZWJwYWNrL3J1bnRpbWUvYW1kIG9wdGlvbnMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2hlbGxvLXdvcmxkL2luYm94c2RrXzIuMS45LTE2OTcxMTA5NDQyMTEtYmNjMzJiNGZmNzVjYzE2Mi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vaGVsbG8td29ybGQvaW5ib3hzZGtfMi4xLjktMTY5NzExMDk0NDIxMS1iY2MzMmI0ZmY3NWNjMTYyLy4vc3JjL2luamVjdGVkLWpzL21haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld0FycmF5KHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbjAgPSB0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLFxuICAgICAgICBuMSA9IHR5cGVvZiBlbmQgPT09ICdudW1iZXInXG5cbiAgICBpZiAobjAgJiYgIW4xKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgIH0gZWxzZSBpZiAoIW4wICYmICFuMSkge1xuICAgICAgICBzdGFydCA9IDBcbiAgICAgICAgZW5kID0gMFxuICAgIH1cblxuICAgIHN0YXJ0ID0gc3RhcnR8MFxuICAgIGVuZCA9IGVuZHwwXG4gICAgdmFyIGxlbiA9IGVuZC1zdGFydFxuICAgIGlmIChsZW48MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZScpXG4gICAgXG4gICAgdmFyIGEgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvciAodmFyIGk9MCwgYz1zdGFydDsgaTxsZW47IGkrKywgYysrKVxuICAgICAgICBhW2ldID0gY1xuICAgIHJldHVybiBhXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhdXRvSHRtbDtcblxudmFyIF9lc2NhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZXNjYXBlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXV0b0h0bWwodGVtcGxhdGVQYXJ0cykge1xuICB2YXIgcGFydHMgPSBuZXcgQXJyYXkodGVtcGxhdGVQYXJ0cy5sZW5ndGggKiAyIC0gMSk7XG4gIHBhcnRzWzBdID0gdGVtcGxhdGVQYXJ0c1swXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSBpICsgMSA8IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgcGFydHNbMiAqIGkgKyAxXSA9IHZhbHVlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19faHRtbCcpID8gdmFsdWUuX19odG1sIDogKDAsIF9lc2NhcGUuZGVmYXVsdCkodmFsdWUpO1xuICAgIHBhcnRzWzIgKiBpICsgMl0gPSB0ZW1wbGF0ZVBhcnRzW2kgKyAxXTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2V3lKaGRYUnZTSFJ0YkNJc0luUmxiWEJzWVhSbFVHRnlkSE1pTENKd1lYSjBjeUlzSWtGeWNtRjVJaXdpYkdWdVozUm9JaXdpYVNJc0lteGxiaUlzSW5aaGJIVmxJaXdpVDJKcVpXTjBJaXdpY0hKdmRHOTBlWEJsSWl3aWFHRnpUM2R1VUhKdmNHVnlkSGtpTENKallXeHNJaXdpWDE5b2RHMXNJaXdpYW05cGJpSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenRCUVVWQk96czdPMEZCU1dVc1UwRkJVMEVzVVVGQlZDeERRVUZyUWtNc1lVRkJiRUlzUlVGQmRVVTdRVUZEY0VZc1RVRkJUVU1zUzBGQlpTeEhRVUZITEVsQlFVbERMRXRCUVVvc1EwRkJWVVlzWVVGQllTeERRVUZEUnl4TlFVRmtMRWRCUVhGQ0xFTkJRWEpDTEVkQlFYVkNMRU5CUVdwRExFTkJRWGhDTzBGQlEwRkdMRVZCUVVGQkxFdEJRVXNzUTBGQlF5eERRVUZFTEVOQlFVd3NSMEZCVjBRc1lVRkJZU3hEUVVGRExFTkJRVVFzUTBGQmVFSTdPMEZCUTBFc1QwRkJTeXhKUVVGSlNTeERRVUZETEVkQlFVTXNRMEZCVGl4RlFVRlRReXhIUVVGSExHMUVRVUZxUWl4RlFVRnBRMFFzUTBGQlF5eEhRVUZEUXl4SFFVRnVReXhGUVVGM1EwUXNRMEZCUXl4RlFVRjZReXhGUVVFMlF6dEJRVU16UXl4UlFVRk5SU3hMUVVGTExFZEJRVlZHTEVOQlFWWXNaME5CUVZWQkxFTkJRVllzTmtKQlFWVkJMRU5CUVZZc1MwRkJXRHRCUVVOQlNDeEpRVUZCUVN4TFFVRkxMRU5CUVVNc1NVRkJSVWNzUTBGQlJpeEhRVUZKTEVOQlFVd3NRMEZCVEN4SFFVRmxSU3hMUVVGTExFbEJRVWxETEUxQlFVMHNRMEZCUTBNc1UwRkJVQ3hEUVVGcFFrTXNZMEZCYWtJc1EwRkJaME5ETEVsQlFXaERMRU5CUVhGRFNpeExRVUZ5UXl4RlFVRTBReXhSUVVFMVF5eERRVUZVTEVkQlFXdEZRU3hMUVVGRUxFTkJRVmxMTEUxQlFUZEZMRWRCUVhOR0xIRkNRVUZQVEN4TFFVRlFMRU5CUVhKSE8wRkJRMEZNTEVsQlFVRkJMRXRCUVVzc1EwRkJReXhKUVVGRlJ5eERRVUZHTEVkQlFVa3NRMEZCVEN4RFFVRk1MRWRCUVdWS0xHRkJRV0VzUTBGQlEwa3NRMEZCUXl4SFFVRkRMRU5CUVVnc1EwRkJOVUk3UVVGRFJEczdRVUZEUkN4VFFVRlBTQ3hMUVVGTExFTkJRVU5YTEVsQlFVNHNRMEZCVnl4RlFVRllMRU5CUVZBN1FVRkRSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUlFQm1iRzkzSUNvdlhHNWNibWx0Y0c5eWRDQmxjMk5oY0dVZ1puSnZiU0FuYkc5a1lYTm9MMlZ6WTJGd1pTYzdYRzVjYm1WNGNHOXlkQ0IwZVhCbElGWmhiSFZsSUQwZ2MzUnlhVzVuSUh3Z2UxOWZhSFJ0YkRvZ2MzUnlhVzVuZlR0Y2JseHVaWGh3YjNKMElHUmxabUYxYkhRZ1puVnVZM1JwYjI0Z1lYVjBiMGgwYld3b2RHVnRjR3hoZEdWUVlYSjBjem9nYzNSeWFXNW5XMTBzSUM0dUxuWmhiSFZsY3pvZ1ZtRnNkV1ZiWFNrNklITjBjbWx1WnlCN1hHNGdJR052Ym5OMElIQmhjblJ6T2lCemRISnBibWRiWFNBOUlHNWxkeUJCY25KaGVTaDBaVzF3YkdGMFpWQmhjblJ6TG14bGJtZDBhQ295TFRFcE8xeHVJQ0J3WVhKMGMxc3dYU0E5SUhSbGJYQnNZWFJsVUdGeWRITmJNRjA3WEc0Z0lHWnZjaUFvYkdWMElHazlNQ3dnYkdWdVBYWmhiSFZsY3k1c1pXNW5kR2c3SUdrOGJHVnVPeUJwS3lzcElIdGNiaUFnSUNCamIyNXpkQ0IyWVd4MVpTQTlJSFpoYkhWbGMxdHBYVHRjYmlBZ0lDQndZWEowYzFzeUtta3JNVjBnUFNCMllXeDFaU0FtSmlCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG1oaGMwOTNibEJ5YjNCbGNuUjVMbU5oYkd3b2RtRnNkV1VzSUNkZlgyaDBiV3duS1NBL0lDaDJZV3gxWlRwaGJua3BMbDlmYUhSdGJDQTZJR1Z6WTJGd1pTaDJZV3gxWlNrN1hHNGdJQ0FnY0dGeWRITmJNaXBwS3pKZElEMGdkR1Z0Y0d4aGRHVlFZWEowYzF0cEt6RmRPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQndZWEowY3k1cWIybHVLQ2NuS1R0Y2JuMWNiaUpkZlE9PSIsImNvbnN0IHIgPSAvKFs/Jl0pXz1bXiZdKi87XG5sZXQgbm9uY2UgPSBEYXRlLm5vdygpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgMzIpKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FjaGVidXN0VXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHIudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKHIsICckMV89JyArIG5vbmNlKyspO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBub25jZSsrO1xuICB9XG59XG4iLCJpbXBvcnQgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0IGRlbGF5IGZyb20gJ3BkZWxheSc7XG5pbXBvcnQgY2FjaGVidXN0VXJsIGZyb20gJy4vY2FjaGVidXN0LXVybCc7XG5cbmNvbnN0IE1BWF9USU1FT1VUID0gNjQgKiAxMDAwOyAvLzY0IHNlY29uZHNcbmNvbnN0IE1BWF9SRVRSSUVTID0gNTtcbmNvbnN0IHNlcnZlcnNUb0lnbm9yZTogeyBbZG9tYWluOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuLy8gU2ltcGxlIGFqYXggaGVscGVyLlxuLy8gb3B0czpcbi8vICogdXJsXG4vLyAqIFttZXRob2RdXG4vLyAqIFtjYWNoZWJ1c3RdIC0gYm9vbGVhblxuLy8gKiBbaGVhZGVyc10gLSBvYmplY3Rcbi8vICogW3hockZpZWxkc10gLSBvYmplY3Rcbi8vICogW2RhdGFdXG5leHBvcnQgaW50ZXJmYWNlIENvbW1vbkFqYXhPcHRzIHtcbiAgdXJsOiBzdHJpbmc7XG4gIG1ldGhvZD86IHN0cmluZztcbiAgY2FjaGVidXN0PzogYm9vbGVhbjtcbiAgaGVhZGVycz86IHsgW2luZGV4OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgeGhyRmllbGRzPzogb2JqZWN0O1xuICBkYXRhPzogeyBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB9IHwgc3RyaW5nO1xuICBjYW5SZXRyeT86IGJvb2xlYW47XG4gIHJldHJ5TnVtPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFqYXhPcHRzIGV4dGVuZHMgQ29tbW9uQWpheE9wdHMge1xuICBYTUxIdHRwUmVxdWVzdD86IHR5cGVvZiBYTUxIdHRwUmVxdWVzdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBamF4UmVzcG9uc2Uge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHhocjogWE1MSHR0cFJlcXVlc3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFqYXgob3B0czogQWpheE9wdHMpOiBQcm9taXNlPEFqYXhSZXNwb25zZT4ge1xuICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMudXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJMIG11c3QgYmUgZ2l2ZW4nKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdHMubWV0aG9kID8gb3B0cy5tZXRob2QgOiAnR0VUJztcbiAgICBsZXQgdXJsID0gb3B0cy51cmw7XG4gICAgbGV0IHN0cmluZ0RhdGE6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIHN0cmluZ0RhdGEgPVxuICAgICAgICB0eXBlb2Ygb3B0cy5kYXRhID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gb3B0cy5kYXRhXG4gICAgICAgICAgOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0cy5kYXRhKTtcbiAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIHVybCArPSAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHN0cmluZ0RhdGE7XG4gICAgICAgIHN0cmluZ0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYW5SZXRyeTogYm9vbGVhbiA9XG4gICAgICBvcHRzLmNhblJldHJ5ICE9IG51bGxcbiAgICAgICAgPyBvcHRzLmNhblJldHJ5XG4gICAgICAgIDogbWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJztcblxuICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKC8oPzooPzpbYS16XSs6KT9cXC9cXC8pPyhbXi9dKilcXC8vKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCB1cmwnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyID0gbWF0Y2hbMV07XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXJ2ZXJzVG9JZ25vcmUsIHNlcnZlcikpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYFNlcnZlciBhdCAke3VybH0gaGFzIHRvbGQgdXMgdG8gc3RvcCBjb25uZWN0aW5nYCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNhY2hlYnVzdCkge1xuICAgICAgdXJsID0gY2FjaGVidXN0VXJsKHVybCk7XG4gICAgfVxuXG4gICAgY29uc3QgWE1MSHR0cFJlcXVlc3QgPSBvcHRzLlhNTEh0dHBSZXF1ZXN0IHx8IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBPYmplY3QuYXNzaWduKHhociwgb3B0cy54aHJGaWVsZHMpO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoKG9wdHMucmV0cnlOdW0gfHwgMCkgPCBNQVhfUkVUUklFUykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeGhyLnN0YXR1cyA9PT0gNTAyIHx8XG4gICAgICAgICAgKCh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPj0gNTAwKSAmJiBjYW5SZXRyeSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVzb2x2ZShfcmV0cnkob3B0cykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnIgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt1cmx9YCksIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHhocixcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGdpdmUgYSB3YXkgZm9yIGEgc2VydmVyIHRvIHRlbGwgdXMgdG8gZ28gYXdheSBmb3Igbm93LiBHb29kIGZhbGxiYWNrXG4gICAgICAvLyBpbiBjYXNlIGEgYnVnIGV2ZXIgY2F1c2VzIGNsaWVudHMgdG8gc3BhbSBhIHNlcnZlciB3aXRoIHJlcXVlc3RzLlxuICAgICAgaWYgKHhoci5zdGF0dXMgPT0gNDkwKSB7XG4gICAgICAgIHNlcnZlcnNUb0lnbm9yZVtzZXJ2ZXJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICB4aHIsXG4gICAgICAgICAgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4aHIub25lcnJvciEoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmIChvcHRzLmhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gb3B0cztcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXJzW25hbWVdO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgeGhyLnNlbmQoc3RyaW5nRGF0YSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBfcmV0cnkob3B0czogQWpheE9wdHMpOiBQcm9taXNlPEFqYXhSZXNwb25zZT4ge1xuICBjb25zdCByZXRyeU51bSA9IChvcHRzLnJldHJ5TnVtIHx8IDApICsgMTtcblxuICAvLyAyMDAwIDQwMDAgODAwMC4uLlxuICBjb25zdCByZXRyeVRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeU51bSkgKiAxMDAwLCBNQVhfVElNRU9VVCk7XG5cbiAgcmV0dXJuIGRlbGF5KHJldHJ5VGltZW91dCkudGhlbigoKSA9PlxuICAgIGFqYXgoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgeyByZXRyeU51bSB9KSksXG4gICk7XG59XG4iLCJleHBvcnQgY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/PyAnYXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uOiB1bmtub3duLCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3QgLS0gdGhpcyBpcyB0byBtaW1pYyBOb2RlJ3MgYXNzZXJ0IGJlaGF2aW9yXG4gIGlmICghIWNvbmRpdGlvbikge1xuICAgIC8vIG9rXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iLCIvLyBRdWljayBmdW5jdGlvbiBmb3IgY29udmVydGluZyBIVE1MIHdpdGggZW50aXRpZXMgaW50byB0ZXh0IHdpdGhvdXRcbi8vIGludHJvZHVjaW5nIGFuIFhTUyB2dWxuZXJhYmlsaXR5LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHRtbFRvVGV4dChodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvPFtePl0qPj8vZywgJycpO1xuICByZXR1cm4gZGl2LnRleHRDb250ZW50ITtcbn1cbiIsImltcG9ydCBlc2NhcGUgZnJvbSAnbG9kYXNoL2VzY2FwZSc7XG5pbXBvcnQgYXV0b0h0bWwgZnJvbSAnYXV0by1odG1sJztcbmltcG9ydCB7IGRlZm4gfSBmcm9tICd1ZCc7XG5pbXBvcnQgaHRtbFRvVGV4dCBmcm9tICcuLi8uLi9jb21tb24vaHRtbC10by10ZXh0JztcbmltcG9ydCAqIGFzIEdSUCBmcm9tICcuLi8uLi9wbGF0Zm9ybS1pbXBsZW1lbnRhdGlvbi1qcy9kb20tZHJpdmVyL2dtYWlsL2dtYWlsLXJlc3BvbnNlLXByb2Nlc3Nvcic7XG5cbi8vIFRoaXMgaXMgdGhlIHR5cGUgdGhhdCB0aGUgdXNlciBwcm92aWRlcy5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlU2VhcmNoUmVzdWx0IHtcbiAgbmFtZT86IG51bGwgfCBzdHJpbmc7XG4gIG5hbWVIVE1MPzogbnVsbCB8IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBudWxsIHwgc3RyaW5nO1xuICBkZXNjcmlwdGlvbkhUTUw/OiBudWxsIHwgc3RyaW5nO1xuICByb3V0ZU5hbWU/OiBudWxsIHwgc3RyaW5nO1xuICByb3V0ZVBhcmFtcz86IG51bGwgfCB7IFtpeDogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH07XG4gIGV4dGVybmFsVVJMPzogbnVsbCB8IHN0cmluZztcbiAgc2VhcmNoVGVybT86IG51bGwgfCBzdHJpbmc7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgaWNvblVybCBpbnN0ZWFkICovXG4gIGljb25VUkw/OiBudWxsIHwgc3RyaW5nO1xuICBpY29uVXJsPzogbnVsbCB8IHN0cmluZztcbiAgaWNvbkNsYXNzPzogbnVsbCB8IHN0cmluZztcbiAgaWNvbkhUTUw/OiBudWxsIHwgc3RyaW5nO1xuICBvbkNsaWNrPzogbnVsbCB8ICgoKSA9PiB2b2lkKTtcbn1cblxuLy8gVGhlc2UgaWRzIGFyZSBwYXJ0IG9mIHRoZSBvYmplY3QgY29uc3RydWN0ZWQgYnkgdGhlIFNESyB1c2VkIHRvIHJlZmVyIHRvIGFcbi8vIHN1Z2dlc3Rpb24gdG8gdGhlIGluamVjdGVkIHNjcmlwdC5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlU2VhcmNoUmVzdWx0V2l0aElkXG4gIGV4dGVuZHMgQXV0b2NvbXBsZXRlU2VhcmNoUmVzdWx0IHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvdmlkZXJJZDogc3RyaW5nO1xufVxuXG4vKlxuTm90ZXMgYWJvdXQgdGhlIEdtYWlsIHN1Z2dlc3Rpb25zIHJlc3BvbnNlOlxuVGhlIHJlc3BvbnNlIG1heSBiZSBtYWRlIHVwIG9mIG11bHRpcGxlIHNlY3Rpb25zLiBFYWNoIHNlY3Rpb24gY2FuIHNwZWNpZnlcbnJlc3VsdHMuIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiByZXN1bHRzOiBzZWFyY2ggdGVybXMvY29udGFjdHMsIGRyaXZlIGZpbGVzLFxuYW5kIGVtYWlscy4gRWFjaCBzZWN0aW9uIG1heSBvbmx5IGNvbnRhaW4gb25lIHR5cGUgb2YgcmVzdWx0LiBUaGUgc2VjdGlvbnMgY2FuXG5iZSBpbiBhbnkgb3JkZXIsIHRob3VnaCBHbWFpbCBhcHBlYXJzIHRvIGFsd2F5cyBwdXQgdGhlIHNlYXJjaCB0ZXJtcy9jb250YWN0c1xuc2VjdGlvbiBmaXJzdC5cblxuU29tZSBmaWVsZHMgb2YgYSBzZWN0aW9uOlxuMDogVGhlIGNvbnN0YW50IFwiYXNvLnNycFwiXG4xOiBUaGUgdXNlcidzIHNlYXJjaCBxdWVyeVxuMzogQXJyYXkgb2Ygc2VhcmNoIHRlcm0vY29udGFjdCBzdWdnZXN0aW9ucy5cbjQ6IEFycmF5IG9mIGVtYWlsIHN1Z2dlc3Rpb25zLlxuNTogQXJyYXkgb2YgZHJpdmUgc3VnZ2VzdGlvbnMuXG42LTk6IENvbnN0YW50cyBzaWduaWZ5aW5nIHR5cGUgb2Ygc2VjdGlvbig/KVxuICBzZWFyY2ggdGVybXMvY29udGFjdHM6IDEsMCwwLDFcbiAgZHJpdmU6ICAgICAgICAgICAgICAgICAwLDAsMSwzXG4gIGVtYWlsOiAgICAgICAgICAgICAgICAgMCwxLDAsMlxuMTE6IFRpbWVzdGFtcCBpbiBtaWNyb3NlY29uZHMuIEVhY2ggc2VjdGlvbiBzaG91bGQgaGF2ZSB0aGUgc2FtZSB0aW1lc3RhbXAuXG4xMjogVHlwaW5nIGF1dG9jb21wbGV0ZSB2YWx1ZSBvciBlbXB0eSBhcnJheS5cbjEzOiBUaGUgbGVuZ3RoIG9mIHRoZSB1c2VyJ3Mgc2VhcmNoIHF1ZXJ5IHRpbWVzIDQgdGhlbiBjYXN0IHRvIGEgc3RyaW5nLlxuXG5DdXJyZW50bHkgbW9kaWZ5U3VnZ2VzdGlvbnMgbW9kaWZpZXMgdGhlIGZpcnN0IHNlY3Rpb24gYW5kIGFkZHMgdGhlXG5hcHAtcHJvdmlkZWQgc3VnZ2VzdGlvbnMgaW50byB0aGUgc2VhcmNoIHRlcm0vY29udGFjdCBzdWdnZXN0aW9ucyBhcnJheS5cbiovXG5cbmZ1bmN0aW9uIG1vZGlmeVN1Z2dlc3Rpb25zKFxuICByZXNwb25zZVRleHQ6IHN0cmluZyxcbiAgbW9kaWZpY2F0aW9uczogQXV0b2NvbXBsZXRlU2VhcmNoUmVzdWx0V2l0aElkW10sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IHZhbHVlOiBwYXJzZWQsIG9wdGlvbnMgfSA9IEdSUC5kZXNlcmlhbGl6ZShyZXNwb25zZVRleHQpO1xuICBjb25zdCBxdWVyeSA9IHBhcnNlZFswXVsxXTtcbiAgZm9yIChjb25zdCBtb2RpZmljYXRpb24gb2YgbW9kaWZpY2F0aW9ucykge1xuICAgIGxldCBuYW1lLCBuYW1lSFRNTDtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWNhdGlvbi5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IG1vZGlmaWNhdGlvbi5uYW1lO1xuICAgICAgbmFtZUhUTUwgPSBlc2NhcGUobmFtZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9uLm5hbWVIVE1MID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZUhUTUwgPSBtb2RpZmljYXRpb24ubmFtZUhUTUw7XG4gICAgICBuYW1lID0gaHRtbFRvVGV4dChuYW1lSFRNTCk7XG4gICAgfVxuICAgIGlmIChuYW1lID09IG51bGwgfHwgbmFtZUhUTUwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG9yIG5hbWVIVE1MIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgbGV0IGRlc2NyaXB0aW9uLCBkZXNjcmlwdGlvbkhUTUw7XG4gICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb24uZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IG1vZGlmaWNhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICAgIGRlc2NyaXB0aW9uSFRNTCA9IGVzY2FwZShkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9uLmRlc2NyaXB0aW9uSFRNTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRlc2NyaXB0aW9uSFRNTCA9IG1vZGlmaWNhdGlvbi5kZXNjcmlwdGlvbkhUTUw7XG4gICAgICBkZXNjcmlwdGlvbiA9IGh0bWxUb1RleHQoZGVzY3JpcHRpb25IVE1MKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGlkOiBtb2RpZmljYXRpb24uaWQsXG4gICAgICByb3V0ZU5hbWU6IG1vZGlmaWNhdGlvbi5yb3V0ZU5hbWUsXG4gICAgICByb3V0ZVBhcmFtczogbW9kaWZpY2F0aW9uLnJvdXRlUGFyYW1zLFxuICAgICAgZXh0ZXJuYWxVUkw6IG1vZGlmaWNhdGlvbi5leHRlcm5hbFVSTCxcbiAgICB9O1xuICAgIG5hbWVIVE1MICs9IGF1dG9IdG1sYCA8c3BhbiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGRhdGEtaW5ib3hzZGstc3VnZ2VzdGlvbj1cIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBkYXRhLFxuICAgICl9XCI+PC9zcGFuPmA7XG5cbiAgICBpZiAobW9kaWZpY2F0aW9uLmljb25IVE1MICE9IG51bGwpIHtcbiAgICAgIG5hbWVIVE1MID0gYDxkaXYgY2xhc3M9XCJpbmJveHNka19fY3VzdG9tX3N1Z2dlc3Rpb25faWNvbkhUTUxcIj4ke21vZGlmaWNhdGlvbi5pY29uSFRNTH08L2Rpdj4ke25hbWVIVE1MfWA7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3SXRlbSA9IFtcbiAgICAgICdhc28uc3VnJyxcbiAgICAgIG1vZGlmaWNhdGlvbi5zZWFyY2hUZXJtIHx8IHF1ZXJ5LFxuICAgICAgbmFtZUhUTUwsXG4gICAgICBudWxsIGFzXG4gICAgICAgIHwgW1xuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgXVxuICAgICAgICB8IG51bGwsXG4gICAgICBbXSxcblxuICAgICAgLy8gc2NyZWVuIGhlaWdodCBlc3RpbWF0ZS4gQ3VycmVudGx5IEdtYWlsIGJ1Z3Mgb3V0IGlmIHRoZSBzY3JlZW4gaGVpZ2h0XG4gICAgICAvLyBlc3RpbWF0ZXMgYWRkIHVwIHRvIGFib3ZlIHRoZSBzY3JlZW4gaGVpZ2h0LCBzbyBsZXQncyBhdm9pZCBtYWtpbmcgdGhlXG4gICAgICAvLyBpc3N1ZSBtb3JlIGxpa2VseSBieSB0ZWxsaW5nIGl0IG91ciBlbnRyaWVzIGFyZSB6ZXJvLWhlaWdodC5cbiAgICAgIDAsXG5cbiAgICAgIG51bGwgYXMgW3N0cmluZywgc3RyaW5nXSB8IG51bGwsXG4gICAgICAnYXNvciBpbmJveHNka19fY3VzdG9tX3N1Z2dlc3Rpb24gJyArXG4gICAgICAgIG1vZGlmaWNhdGlvbi5wcm92aWRlcklkICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgKG1vZGlmaWNhdGlvbi5pY29uQ2xhc3MgfHwgJycpLFxuICAgICAgMCxcbiAgICBdO1xuICAgIGlmIChkZXNjcmlwdGlvbkhUTUwgIT0gbnVsbCkge1xuICAgICAgbmV3SXRlbVszXSA9IFsnYXNvLmVtZScsIGRlc2NyaXB0aW9uLCBuYW1lLCBkZXNjcmlwdGlvbkhUTUwsIG5hbWVIVE1MXTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBpY29uSHRtbCB0byBiZSBwYXNzZWQsIGFuZCBpZ25vcmUgaWNvblVybCBpZiBpY29uSHRtbCBpcyBwcmVzZW50c1xuICAgIGlmIChtb2RpZmljYXRpb24uaWNvbkhUTUwgIT0gbnVsbCkge1xuICAgICAgLy8gc2V0IGVtcHR5IGltYWdlXG4gICAgICBuZXdJdGVtWzZdID0gW1xuICAgICAgICAnYXNvLnRobicsXG4gICAgICAgICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PScsXG4gICAgICBdO1xuICAgICAgbmV3SXRlbVs3XSArPSAnIGluYm94c2RrX19ub19iZyc7XG4gICAgfSBlbHNlIGlmIChtb2RpZmljYXRpb24uaWNvblVybCkge1xuICAgICAgbmV3SXRlbVs2XSA9IFsnYXNvLnRobicsIG1vZGlmaWNhdGlvbi5pY29uVXJsXTtcbiAgICAgIG5ld0l0ZW1bN10gKz0gJyBpbmJveHNka19fbm9fYmcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdJdGVtWzddICs9ICcgYXNvcl9pNCc7XG4gICAgfVxuXG4gICAgcGFyc2VkWzBdWzNdLnB1c2gobmV3SXRlbSk7XG4gIH1cbiAgcmV0dXJuIEdSUC5zZXJpYWxpemUocGFyc2VkLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmbihtb2R1bGUsIG1vZGlmeVN1Z2dlc3Rpb25zKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuaW1wb3J0IGhhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBub29wIGZyb20gJ2xvZGFzaC9ub29wJztcbmltcG9ydCBlYWNoIGZyb20gJ2xvZGFzaC9lYWNoJztcbmltcG9ydCBmaWx0ZXIgZnJvbSAnbG9kYXNoL2ZpbHRlcic7XG5pbXBvcnQgaW5jbHVkZXMgZnJvbSAnbG9kYXNoL2luY2x1ZGVzJztcbmltcG9ydCBvbmNlIGZyb20gJ2xvZGFzaC9vbmNlJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL2NvbW1vbi9hc3NlcnQnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgcGFyc2UgYXMgZGVwYXJhbSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmV4cG9ydCB0eXBlIE9wdHMgPSB7XG4gIGxvZ0Vycm9yOiAoZXJyb3I6IHVua25vd24sIGRldGFpbHM/OiBhbnkpID0+IHZvaWQ7XG59O1xuY29uc3QgV0FSTklOR19USU1FT1VUID0gNjAgKiAxMDAwO1xuXG4vKipcbiAqIE9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb25uZWN0aW9uIGluIHByb2dyZXNzLiBJdHMgZmllbGRzIGFyZVxuICogcG9wdWxhdGVkIGFzIHRoZSBjb25uZWN0aW9uIGdvZXMgb24uIFRoZSBvYmplY3QgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdFxuICogYXJndW1lbnQgdG8gYWxsIG9mIHRoZSB3cmFwcGVycy4gVGhlIG9iamVjdCBpcyBtdXRhYmxlIHNvIHRoZSB3cmFwcGVycyBjYW5cbiAqIGFkZCBwcm9wZXJ0aWVzIHRvIGl0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGRlY29kZWQgZnJvbSB0aGUgVVJMXG4gKiBAcHJvcGVydHkge09iamVjdH0gaGVhZGVycyAtIHJlcXVlc3QgaGVhZGVycyBzZXQgb24gdGhlIFhIUlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc3BvbnNlVHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbmFsU2VuZEJvZHkgLSBkYXRhIHBhc3NlZCB0byBzZW5kIG1ldGhvZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXR1cyAtIEhUVFAgcmVzcG9uc2Ugc3RhdHVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29yaWdpbmFsUmVzcG9uc2VUZXh0XSAtIElzIG5vdCBzZXQgaWYgcmVzcG9uc2VUeXBlIGlzIHNldFxuICogIHRvIGEgdmFsdWUgYmVzaWRlcyAndGV4dCcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGlmaWVkUmVzcG9uc2VUZXh0XVxuICovXG5leHBvcnQgdHlwZSBYSFJQcm94eUNvbm5lY3Rpb25EZXRhaWxzID0ge1xuICBtZXRob2Q6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgcmVzcG9uc2VUeXBlOiBzdHJpbmc7XG4gIG9yaWdpbmFsU2VuZEJvZHk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IHR5cGUgWEhSUHJveHlDb25uZWN0aW9uRGV0YWlsc1dpdGhSZXNwb25zZSA9XG4gIFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHMgJiB7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgb3JpZ2luYWxSZXNwb25zZVRleHQ6IHN0cmluZztcbiAgICBtb2RpZmllZFJlc3BvbnNlVGV4dDogc3RyaW5nO1xuICB9O1xuZXhwb3J0IHR5cGUgWEhSUHJveHlDb25uZWN0aW9uRGV0YWlsc0FmdGVyTGlzdGVuZXJzID1cbiAgWEhSUHJveHlDb25uZWN0aW9uRGV0YWlscyAmIHtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICBvcmlnaW5hbFJlc3BvbnNlVGV4dDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICBtb2RpZmllZFJlc3BvbnNlVGV4dDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgfTtcblxuLyoqXG4gKiBUaGluZ1xuICpcbiAqIEBjYWxsYmFjayBYSFJQcm94eVdyYXBwZXJDYWxsYmFja1xuICogQHBhcmFtIHtYSFJQcm94eUNvbm5lY3Rpb25EZXRhaWxzfSBjb25uZWN0aW9uXG4gKi9cbnR5cGUgUmVxdWVzdCA9IHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICBib2R5OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFdyYXBwZXIgb2JqZWN0IGNvbnRhaW5zIG9wdGlvbmFsIGNhbGxiYWNrcyB0aGF0IGdldCBydW4gZm9yIGNvbXBsZXRlZFxuICogcmVxdWVzdHMsIGFuZCBhIHJlcXVpcmVkIGlzUmVsZXZhbnRUbyBtZXRob2QgdGhhdCBmaWx0ZXJzIHdoYXQgdHlwZXMgb2ZcbiAqIHJlcXVlc3RzIHRoZSBtZXRob2RzIHNob3VsZCBiZSBjYWxsZWQgZm9yLiBBbGwgbWV0aG9kcyBhcmUgcGFzc2VkIGFuIG9iamVjdFxuICogd2l0aCBkZXRhaWxzIGFib3V0IHRoZSBjb25uZWN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gU29tZSBtZXRob2RzIGFyZVxuICogY2FsbGVkIHdpdGggYSByZWxldmFudCBzZWNvbmQgYXJndW1lbnQgKHdoaWNoIGlzIGFsc28gcHJlc2VudCB3aXRoaW4gdGhlXG4gKiBjb25uZWN0aW9uIGFyZ3VtZW50KS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYSFJQcm94eVdyYXBwZXJcbiAqIEBwcm9wZXJ0eSB7WEhSUHJveHlXcmFwcGVyQ2FsbGJhY2t9IGlzUmVsZXZhbnRUbyAtIHJldHVybnMgdHJ1ZSBpZiB3cmFwcGVyIHNob3VsZCBiZSB1c2VkXG4gKiAgZm9yIHJlcXVlc3QuXG4gKiBAcHJvcGVydHkge1hIUlByb3h5V3JhcHBlckNhbGxiYWNrfSBbb3JpZ2luYWxTZW5kQm9keUxvZ2dlcl0gLSBjYWxsZWQgd2l0aCB2YWx1ZSBwYXNzZWQgdG9cbiAqICBzZW5kLlxuICogQHByb3BlcnR5IHtYSFJQcm94eVdyYXBwZXJDYWxsYmFja30gW3JlcXVlc3RDaGFuZ2VyXSAtIEFsbG93cyB0aGUgcHJvdG9jb2wsIFVSTCwgYW5kIGJvZHlcbiAqICB0byBiZSBjaGFuZ2VkIHRvZ2V0aGVyIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWQgYW5kIHNlbnQuXG4gKiBAcHJvcGVydHkge1hIUlByb3h5V3JhcHBlckNhbGxiYWNrfSBbb3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXJdIC0gY2FsbGVkIHdpdGggdGhlIHJlc3BvbnNlVGV4dCBhc1xuICogIGdpdmVuIGJ5IHRoZSBzZXJ2ZXIuIElzIG5vdCBjYWxsZWQgaWYgcmVzcG9uc2VUeXBlIGlzIHNldCB0byBhIHZhbHVlIGJlc2lkZXMgJ3RleHQnLlxuICogQHByb3BlcnR5IHtYSFJQcm94eVdyYXBwZXJDYWxsYmFja30gW3Jlc3BvbnNlVGV4dENoYW5nZXJdIC0gY2FsbGVkIHdpdGggdGhlIHJlc3BvbnNlVGV4dCBhcyBnaXZlblxuICogIGJ5IHRoZSBzZXJ2ZXIgYW5kIHJldHVybnMgbmV3IHJlc3BvbnNlVGV4dCB2YWx1ZS4gSXMgbm90IGNhbGxlZCBpZiByZXNwb25zZVR5cGVcbiAqIGlzIHNldCB0byBhIHZhbHVlIGJlc2lkZXMgJ3RleHQnLlxuICogQHByb3BlcnR5IHtYSFJQcm94eVdyYXBwZXJDYWxsYmFja30gW2ZpbmFsUmVzcG9uc2VUZXh0TG9nZ2VyXSAtIGNhbGxlZCB3aXRoIHRoZSByZXNwb25zZVRleHQgYXNcbiAqICBkZWxpdmVyZWQgdG8gYXBwbGljYXRpb24gY29kZS4gSXMgbm90IGNhbGxlZCBpZiByZXNwb25zZVR5cGUgaXMgc2V0IHRvIGEgdmFsdWUgYmVzaWRlcyAndGV4dCcuXG4gKiBAcHJvcGVydHkge1hIUlByb3h5V3JhcHBlckNhbGxiYWNrfSBbYWZ0ZXJMaXN0ZW5lcnNdIC0gY2FsbGVkIGFmdGVyIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAqICBmb3IgcmVhZHlzdGF0ZWNoYW5nZSBoYXZlIHJ1blxuICovXG5leHBvcnQgdHlwZSBXcmFwcGVyID0ge1xuICBpc1JlbGV2YW50VG86IChjb25uZWN0aW9uOiBYSFJQcm94eUNvbm5lY3Rpb25EZXRhaWxzKSA9PiBib29sZWFuO1xuICBvcmlnaW5hbFNlbmRCb2R5TG9nZ2VyPzogKFxuICAgIGNvbm5lY3Rpb246IFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHMsXG4gICAgYm9keTogc3RyaW5nLFxuICApID0+IHZvaWQ7XG4gIHJlcXVlc3RDaGFuZ2VyPzogKFxuICAgIGNvbm5lY3Rpb246IFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHMsXG4gICAgcmVxdWVzdDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKSA9PiBSZXF1ZXN0IHwgUHJvbWlzZTxSZXF1ZXN0PjtcbiAgb3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXI/OiAoXG4gICAgY29ubmVjdGlvbjogWEhSUHJveHlDb25uZWN0aW9uRGV0YWlsc1dpdGhSZXNwb25zZSxcbiAgICBvcmlnaW5hbFJlc3BvbnNlVGV4dDogc3RyaW5nLFxuICApID0+IHZvaWQ7XG4gIHJlc3BvbnNlVGV4dENoYW5nZXI/OiAoXG4gICAgY29ubmVjdGlvbjogWEhSUHJveHlDb25uZWN0aW9uRGV0YWlsc1dpdGhSZXNwb25zZSxcbiAgICBvcmlnaW5hbFJlc3BvbnNlVGV4dDogc3RyaW5nLFxuICApID0+IHN0cmluZyB8IFByb21pc2U8c3RyaW5nPjtcbiAgZmluYWxSZXNwb25zZVRleHRMb2dnZXI/OiAoXG4gICAgY29ubmVjdGlvbjogWEhSUHJveHlDb25uZWN0aW9uRGV0YWlsc1dpdGhSZXNwb25zZSxcbiAgICBmaW5hbFJlc3BvbnNlVGV4dDogc3RyaW5nLFxuICApID0+IHZvaWQ7XG4gIGFmdGVyTGlzdGVuZXJzPzogKFxuICAgIGNvbm5lY3Rpb246IFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHNBZnRlckxpc3RlbmVycyxcbiAgKSA9PiB2b2lkO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBYTUxIdHRwUmVxdWVzdCBjb25zdHJ1Y3RvciB0aGF0IGNhblxuICogaGF2ZSB3cmFwcGVycyB3aGljaCBtYXkgbG9nIG9yIG1vZGlmeSBzZXJ2ZXIgcmVzcG9uc2VzLiBTZWVcbiAqIHRlc3QveGhycHJveHkuanMgZm9yIHVzYWdlIGV4YW1wbGVzIGFuZCB0ZXN0cy5cbiAqIEBmdW5jdGlvbiBYSFJQcm94eUZhY3RvcnlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFhIUiAtIG9yaWdpbmFsIFhNTEh0dHBSZXF1ZXN0IGNvbnN0cnVjdG9yIHRvIHdyYXBcbiAqIEBwYXJhbSB7WEhSUHJveHlXcmFwcGVyW119IHdyYXBwZXJzIC0gbXV0YWJsZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIENhbiBzcGVjaWZ5IGEgbG9nRXJyb3IgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBYTUxIdHRwUmVxdWVzdC1saWtlIGNvbnN0cnVjdG9yXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWEhSUHJveHlGYWN0b3J5KFxuICBYSFI6IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCxcbiAgd3JhcHBlcnM6IFdyYXBwZXJbXSxcbiAgb3B0czogT3B0cyxcbik6IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCB7XG4gIGNvbnN0IGxvZ0Vycm9yID1cbiAgICAob3B0cyAmJiBvcHRzLmxvZ0Vycm9yKSB8fFxuICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGxldCB3aW5kb3cub25lcnJvciBsb2cgdGhpc1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0sIDEpO1xuICAgIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtRXZlbnQoXG4gICAgb2xkVGFyZ2V0OiB1bmtub3duLFxuICAgIG5ld1RhcmdldDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBldmVudDogYW55LFxuICApIHtcbiAgICBjb25zdCBuZXdFdmVudDogYW55ID0ge307XG4gICAgT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAuY29uY2F0KFtcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsQnViYmxlJyxcbiAgICAgICAgJ2NhbmNlbGFibGUnLFxuICAgICAgICAnZGVmYXVsdFByZXZlbnRlZCcsXG4gICAgICAgICdwcmV2ZW50RGVmYXVsdCcsXG4gICAgICAgICdzdG9wUHJvcGFnYXRpb24nLFxuICAgICAgICAnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJyxcbiAgICAgICAgJ2xlbmd0aENvbXB1dGFibGUnLFxuICAgICAgICAnbG9hZGVkJyxcbiAgICAgICAgJ3RvdGFsJyxcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAnY3VycmVudFRhcmdldCcsXG4gICAgICAgICd0YXJnZXQnLFxuICAgICAgICAnc3JjRWxlbWVudCcsXG4gICAgICAgICdOT05FJyxcbiAgICAgICAgJ0NBUFRVUklOR19QSEFTRScsXG4gICAgICAgICdBVF9UQVJHRVQnLFxuICAgICAgICAnQlVCQkxJTkdfUEhBU0UnLFxuICAgICAgICAnZXZlbnRQaGFzZScsXG4gICAgICBdKVxuICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSBpbiBldmVudClcbiAgICAgIC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnRbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBvbGRUYXJnZXQpIHtcbiAgICAgICAgICBuZXdFdmVudFtuYW1lXSA9IG5ld1RhcmdldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBuZXdFdmVudFtuYW1lXSA9IHZhbHVlLmJpbmQoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0V2ZW50W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBuZXdFdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBFdmVudExpc3RlbmVyKG9sZFRhcmdldDogYW55LCBuZXdUYXJnZXQ6IGFueSwgbGlzdGVuZXI6IGFueSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQ6IGFueSkge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwoXG4gICAgICAgIG5ld1RhcmdldCxcbiAgICAgICAgdHJhbnNmb3JtRXZlbnQob2xkVGFyZ2V0LCBuZXdUYXJnZXQsIGV2ZW50KSxcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBcHBsaWNhYmxlV3JhcHBlcnMoXG4gICAgd3JhcHBlcnM6IFdyYXBwZXJbXSxcbiAgICBjb25uZWN0aW9uOiBYSFJQcm94eUNvbm5lY3Rpb25EZXRhaWxzLFxuICApIHtcbiAgICByZXR1cm4gZmlsdGVyKHdyYXBwZXJzLCBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuaXNSZWxldmFudFRvKGNvbm5lY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHR5cGUgWEhSUHJveHlUaGlzID0ge1xuICAgIF9hY3RpdmVXcmFwcGVyczogYW55W107XG4gICAgX2JvdW5kTGlzdGVuZXJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIF9jbGllbnRTdGFydGVkU2VuZDogYm9vbGVhbjtcbiAgICBfY29ubmVjdGlvbjogYW55O1xuICAgIF9ldmVudHM6IHVua25vd247XG4gICAgX2Zha2VSc2NFdmVudCgpOiB2b2lkO1xuICAgIF9saXN0ZW5lcnM6IHVua25vd247XG4gICAgX29wZW5TdGF0ZTogdW5rbm93bjtcbiAgICBfcmVhbFN0YXJ0ZWRTZW5kOiB1bmtub3duO1xuICAgIF9yZWFseGhyOiBYTUxIdHRwUmVxdWVzdDtcbiAgICBfcmVxdWVzdENoYW5nZXJzOiB1bmtub3duW107XG4gICAgX3Jlc3BvbnNlVGV4dENoYW5nZXJzOiBhbnlbXTtcbiAgICBfd3JhcHBlcnM6IFdyYXBwZXJbXTtcbiAgICByZWFkeVN0YXRlOiB1bmtub3duO1xuICAgIHJlc3BvbnNlVGV4dDogdW5rbm93bjtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICBba2V5OiBgb24ke3N0cmluZ31gXTogYW55O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFhIUlByb3h5KHRoaXM6IFhIUlByb3h5VGhpcykge1xuICAgIHRoaXMuX3dyYXBwZXJzID0gd3JhcHBlcnM7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fYm91bmRMaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vIHVzZWQgZm9yIGludGVybmFsIHN0dWZmLCBub3QgdXNlci12aXNpYmxlIGV2ZW50c1xuXG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSAnJztcbiAgICB0aGlzLl9vcGVuU3RhdGUgPSBmYWxzZTtcblxuICAgIGlmIChYSFIuYmluZCAmJiAoWEhSLmJpbmQuYXBwbHkgYXMgYW55KSkge1xuICAgICAgLy8gY2FsbCBjb25zdHJ1Y3RvciB3aXRoIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgIHRoaXMuX3JlYWx4aHIgPSBuZXcgKChYSFIgYXMgYW55KS5iaW5kLmFwcGx5KFxuICAgICAgICBYSFIsXG4gICAgICAgIFtudWxsXS5jb25jYXQoYXJndW1lbnRzIGFzIGFueSksXG4gICAgICApKSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTYWZhcmkncyBYTUxIdHRwUmVxdWVzdCBsYWNrcyBhIGJpbmQgbWV0aG9kLCBidXQgaXRzIGNvbnN0cnVjdG9yXG4gICAgICAvLyBkb2Vzbid0IHN1cHBvcnQgZXh0cmEgYXJndW1lbnRzIGFueXdheSwgc28gZG9uJ3QgYm90aGVyIGxvZ2dpbmcgYW5cbiAgICAgIC8vIGVycm9yIGhlcmUuXG4gICAgICB0aGlzLl9yZWFseGhyID0gbmV3IFhIUigpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgY29uc3QgdHJpZ2dlckV2ZW50TGlzdGVuZXJzID0gKG5hbWU6IHN0cmluZywgZXZlbnQ6IHVua25vd24pID0+IHtcbiAgICAgIGlmICgodGhpcyBhcyBhbnkpWydvbicgKyBuYW1lXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdyYXBFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgdGhpcy5fcmVhbHhocixcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAodGhpcyBhcyBhbnkpWydvbicgKyBuYW1lXSxcbiAgICAgICAgICApLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZSwgJ1hNTEh0dHBSZXF1ZXN0IGV2ZW50IGxpc3RlbmVyIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWFjaCh0aGlzLl9ib3VuZExpc3RlbmVyc1tuYW1lXSwgKGJvdW5kTGlzdGVuZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBib3VuZExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ0Vycm9yKGUsICdYTUxIdHRwUmVxdWVzdCBldmVudCBsaXN0ZW5lciBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcnVuUnNjTGlzdGVuZXJzID0gKGV2ZW50OiB1bmtub3duKSA9PiB7XG4gICAgICB0cmlnZ2VyRXZlbnRMaXN0ZW5lcnMoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBldmVudCk7XG4gICAgfTtcblxuICAgIHRoaXMuX2Zha2VSc2NFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJ1blJzY0xpc3RlbmVycyhcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogbm9vcCxcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IG5vb3AsXG4gICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBub29wLFxuICAgICAgICAgIHR5cGU6ICdyZWFkeXN0YXRlY2hhbmdlJyxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICBzcmNFbGVtZW50OiB0aGlzLFxuICAgICAgICAgIE5PTkU6IDAsXG4gICAgICAgICAgQ0FQVFVSSU5HX1BIQVNFOiAxLFxuICAgICAgICAgIEFUX1RBUkdFVDogMixcbiAgICAgICAgICBCVUJCTElOR19QSEFTRTogMyxcbiAgICAgICAgICBldmVudFBoYXNlOiAwLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGl2ZXJGaW5hbFJzYyA9IChldmVudDogdW5rbm93bikgPT4ge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gNDtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBzdGF0dXMgbm93IGJlZm9yZSBhbnkgZXZlbnQgaGFuZGxlcnMgYXJlIGNhbGxlZCwganVzdCBpblxuICAgICAgLy8gY2FzZSBvbmUgYWJvcnRzIHRoZSByZXF1ZXN0LlxuICAgICAgdmFyIHdhc1N1Y2Nlc3MgPSB0aGlzLnN0YXR1cyA9PSAyMDA7XG4gICAgICB2YXIgcHJvZ3Jlc3NFdmVudCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB0cmFuc2Zvcm1FdmVudCh0aGlzLl9yZWFseGhyLCB0aGlzLCBldmVudCksXG4gICAgICAgIHtcbiAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdmFyIHN1cHBvcnRzUmVzcG9uc2VUZXh0ID1cbiAgICAgICAgIXRoaXMuX3JlYWx4aHIucmVzcG9uc2VUeXBlIHx8IHRoaXMuX3JlYWx4aHIucmVzcG9uc2VUeXBlID09ICd0ZXh0JztcblxuICAgICAgaWYgKHN1cHBvcnRzUmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIGVhY2godGhpcy5fYWN0aXZlV3JhcHBlcnMsICh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgaWYgKHdyYXBwZXIuZmluYWxSZXNwb25zZVRleHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIuZmluYWxSZXNwb25zZVRleHRMb2dnZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcnVuUnNjTGlzdGVuZXJzKGV2ZW50KTtcblxuICAgICAgaWYgKHdhc1N1Y2Nlc3MpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50TGlzdGVuZXJzKCdsb2FkJywgcHJvZ3Jlc3NFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyRXZlbnRMaXN0ZW5lcnMoJ2Vycm9yJywgcHJvZ3Jlc3NFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudExpc3RlbmVycygnbG9hZGVuZCcsIHByb2dyZXNzRXZlbnQpO1xuICAgICAgZWFjaCh0aGlzLl9hY3RpdmVXcmFwcGVycywgKHdyYXBwZXIpID0+IHtcbiAgICAgICAgaWYgKHdyYXBwZXIuYWZ0ZXJMaXN0ZW5lcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd3JhcHBlci5hZnRlckxpc3RlbmVycyh0aGlzLl9jb25uZWN0aW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZWFseGhyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAncmVhZHlzdGF0ZWNoYW5nZScsXG4gICAgICAoZXZlbnQ6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlYWx4aHIucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zdGF0dXMgPSB0aGlzLl9yZWFseGhyLnN0YXR1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN1cHBvcnRzUmVzcG9uc2VUZXh0ID1cbiAgICAgICAgICAhdGhpcy5fcmVhbHhoci5yZXNwb25zZVR5cGUgfHwgdGhpcy5fcmVhbHhoci5yZXNwb25zZVR5cGUgPT0gJ3RleHQnO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3BvbnNlIHRleHQuXG4gICAgICAgIGlmICh0aGlzLl9yZWFseGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX2Nvbm5lY3Rpb24sICdvcmlnaW5hbFJlc3BvbnNlVGV4dCcsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogc2VsZi5fcmVhbHhoci5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVhY2godGhpcy5fYWN0aXZlV3JhcHBlcnMsICh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh3cmFwcGVyLm9yaWdpbmFsUmVzcG9uc2VUZXh0TG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHdyYXBwZXIub3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ub3JpZ2luYWxSZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmaW5pc2ggPSBvbmNlKGRlbGl2ZXJGaW5hbFJzYy5iaW5kKG51bGwsIGV2ZW50KSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBYSFIgb2JqZWN0IGlzIHJlLXVzZWQgZm9yIGFub3RoZXIgY29ubmVjdGlvbiwgdGhlbiB3ZSBuZWVkXG4gICAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciB1cGNvbWluZyBhc3luYyBjYWxscyBoZXJlIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gb2JqZWN0LCBhbmQgZG8gbm90aGluZyBpbiBvdXIgYXN5bmNcbiAgICAgICAgICAgICAgLy8gY2FsbHMgaWYgaXQgbm8gbG9uZ2VyIG1hdGNoZXMuXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkUmVzcG9uc2VUZXh0OiBzdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgc3RhcnRDb25uZWN0aW9uLm9yaWdpbmFsUmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29ubmVjdGlvbi5tb2RpZmllZFJlc3BvbnNlVGV4dCA9IG1vZGlmaWVkUmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNwb25zZVRleHRDaGFuZ2VyIG9mIHRoaXMuX3Jlc3BvbnNlVGV4dENoYW5nZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsb25nUnVuV2FybmluZ1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAncmVzcG9uc2VUZXh0Q2hhbmdlciBpcyB0YWtpbmcgdG9vIGxvbmcnLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dENoYW5nZXIsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSwgV0FSTklOR19USU1FT1VUKTtcblxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRSZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZVRleHRDaGFuZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nUnVuV2FybmluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFJlc3BvbnNlVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICdyZXNwb25zZVRleHRDaGFuZ2VyIHJldHVybmVkIG5vbi1zdHJpbmcgdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc3RhcnRDb25uZWN0aW9uLm1vZGlmaWVkUmVzcG9uc2VUZXh0ID0gbW9kaWZpZWRSZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb25uZWN0aW9uICE9PSB0aGlzLl9jb25uZWN0aW9uKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kaWZpZWRSZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgIChtb2RpZmllZFJlc3BvbnNlVGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb25uZWN0aW9uID09PSBzZWxmLl9jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBtb2RpZmllZFJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb25uZWN0aW9uID09PSB0aGlzLl9jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSB0aGlzLl9yZWFseGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBzZWxmLl9yZWFseGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxpdmVyRmluYWxSc2MoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxmLl9yZWFseGhyLnJlYWR5U3RhdGUgPT0gMSAmJiBzZWxmLnJlYWR5U3RhdGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRGVsYXllZCBvcGVuK3NlbmQganVzdCBoYXBwZW5lZC4gV2UgYWxyZWFkeSBkZWxpdmVyZWQgYW4gZXZlbnRcbiAgICAgICAgICAgIC8vIGZvciB0aGlzLCBzbyBkcm9wIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9yZWFseGhyLnJlYWR5U3RhdGUgPj0gMyAmJiBzdXBwb3J0c1Jlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3Jlc3BvbnNlVGV4dENoYW5nZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byB0cmFuc2Zvcm0gdGhlIGZpbmFsIHJlc3BvbnNlLCB0aGVuIHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIHdhbnQgdG8gZXhwb3NlIGFueSBwYXJ0aWFsIHVudHJhbnNmb3JtZWQgcmVzcG9uc2VzIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyB3YW50IHRvIGJvdGhlciB0cnlpbmcgdG8gdHJhbnNmb3JtIHBhcnRpYWwgcmVzcG9uc2VzLiBPbmx5IHNob3dcbiAgICAgICAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIGFzIHRoZSBsb2FkZWQgcmVzcG9uc2UgdW50aWwgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgICAgICAgICAgLy8gZG9uZS5cbiAgICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gc2VsZi5fcmVhbHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5yZWFkeVN0YXRlID0gc2VsZi5fcmVhbHhoci5yZWFkeVN0YXRlO1xuICAgICAgICAgIHJ1blJzY0xpc3RlbmVycyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgW1xuICAgICAgJ2Rpc3BhdGNoRXZlbnQnLFxuICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycsXG4gICAgICAnZ2V0UmVzcG9uc2VIZWFkZXInLFxuICAgICAgJ292ZXJyaWRlTWltZVR5cGUnLFxuICAgICAgJ3Jlc3BvbnNlVHlwZScsXG4gICAgICAncmVzcG9uc2VYTUwnLFxuICAgICAgJ3Jlc3BvbnNlVVJMJyxcbiAgICAgICdzdGF0dXMnLFxuICAgICAgJ3N0YXR1c1RleHQnLFxuICAgICAgJ3RpbWVvdXQnLFxuICAgICAgJ29udGltZW91dCcsXG4gICAgICAnb25sb2Fkc3RhcnQnLFxuICAgICAgJ29ucHJvZ3Jlc3MnLFxuICAgICAgJ29uYWJvcnQnLFxuICAgICAgJ3VwbG9hZCcsXG4gICAgICAnd2l0aENyZWRlbnRpYWxzJyxcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBwcm9wLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIElmIHdlIGdpdmUgdGhlIG9yaWdpbmFsIG5hdGl2ZSBtZXRob2RzIGRpcmVjdGx5LCB0aGV5J2xsIGJlIGNhbGxlZFxuICAgICAgICAgIC8vIHdpdGggYHRoaXNgIGFzIHRoZSBYSFJQcm94eSBvYmplY3QsIHdoaWNoIHRoZXkgYXJlbid0IG1hZGUgZm9yLlxuICAgICAgICAgIGlmICh0eXBlb2YgKHNlbGYuX3JlYWx4aHIgYXMgYW55KVtwcm9wXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKHNlbGYuX3JlYWx4aHIgYXMgYW55KVtwcm9wXS5iaW5kKHNlbGYuX3JlYWx4aHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoc2VsZi5fcmVhbHhociBhcyBhbnkpW3Byb3BdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHYgPSB3cmFwRXZlbnRMaXN0ZW5lcih0aGlzLl9yZWFseGhyLCB0aGlzLCB2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoc2VsZi5fcmVhbHhociBhcyBhbnkpW3Byb3BdID0gdjtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIChPYmplY3QgYXMgYW55KS5kZWZpbmVQcm9wZXJ0eShzZWxmLCAncmVzcG9uc2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuX3JlYWx4aHIucmVzcG9uc2VUeXBlIHx8XG4gICAgICAgICAgdGhpcy5fcmVhbHhoci5yZXNwb25zZVR5cGUgPT0gJ3RleHQnXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSdyZSBub3QgdHJ5aW5nIHRvIHRyYW5zZm9ybSBub24tdGV4dCByZXNwb25zZXMgY3VycmVudGx5LlxuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFseGhyLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9IHNlbGYuX3JlYWx4aHIucmVhZHlTdGF0ZTtcbiAgfVxuXG4gIFhIUlByb3h5LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJbXBvcnRhbnQ6IElmIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gc2VudCwgdGhlIFhIUiB3aWxsIGNoYW5nZVxuICAgIC8vIGl0cyByZWFkeVN0YXRlIHRvIDQgYWZ0ZXIgYWJvcnQuIEhvd2V2ZXIsIHdlIHNvbWV0aW1lcyBhc3luY2hyb25vdXNseVxuICAgIC8vIGRlbGF5IHNlbmQgY2FsbHMuIElmIHRoZSBhcHBsaWNhdGlvbiBoYXMgYWxyZWFkeSBjYWxsZWQgc2VuZCBidXQgd2VcbiAgICAvLyBoYXZlbid0IHNlbnQgb2ZmIHRoZSByZWFsIGNhbGwgeWV0LCB0aGVuIHdlIG5lZWQgdG8gaHVycnkgdXAgYW5kIHNlbmRcbiAgICAvLyBzb21ldGhpbmcgYmVmb3JlIHRoZSBhYm9ydCBzbyB0aGF0IHRoZSByZWFkeVN0YXRlIGNoYW5nZSBoYXBwZW5zLlxuICAgIGlmICh0aGlzLl9jbGllbnRTdGFydGVkU2VuZCAmJiAhdGhpcy5fcmVhbFN0YXJ0ZWRTZW5kKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IDAgJiYgdGhpcy5fcmVhbHhoci5yZWFkeVN0YXRlID09IDApIHtcbiAgICAgICAgdGhpcy5fcmVhbHhoci5vcGVuKHRoaXMuX2Nvbm5lY3Rpb24ubWV0aG9kLCB0aGlzLl9jb25uZWN0aW9uLnVybCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWxTdGFydGVkU2VuZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3JlYWx4aHIuc2VuZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWx4aHIuYWJvcnQoKTtcbiAgfTtcblxuICBYSFJQcm94eS5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHVua25vd24sXG4gICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gMSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnc2V0UmVxdWVzdEhlYWRlciBpbXByb3Blcmx5IGNhbGxlZCBhdCByZWFkeVN0YXRlICcgKyB0aGlzLnJlYWR5U3RhdGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fb3BlblN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBoZWFkZXJzIGFmdGVyIG9wZW4gYW5kIGJlZm9yZSBzZW5kJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5oZWFkZXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbi5hc3luYyAmJiB0aGlzLl9yZXF1ZXN0Q2hhbmdlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9ldmVudHMub25jZSgncmVhbE9wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX3JlYWx4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVhbHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgWEhSUHJveHkucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiB1bmtub3duLFxuICApIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gW107XG4gICAgICB0aGlzLl9ib3VuZExpc3RlbmVyc1tuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGlmICghaW5jbHVkZXModGhpcy5fbGlzdGVuZXJzW25hbWVdLCBsaXN0ZW5lcikpIHtcbiAgICAgIHZhciBib3VuZExpc3RlbmVyID0gd3JhcEV2ZW50TGlzdGVuZXIodGhpcy5fcmVhbHhociwgdGhpcywgbGlzdGVuZXIpO1xuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIHRoaXMuX2JvdW5kTGlzdGVuZXJzW25hbWVdLnB1c2goYm91bmRMaXN0ZW5lcik7XG5cbiAgICAgIGlmICghaW5jbHVkZXMoWydyZWFkeXN0YXRlY2hhbmdlJywgJ2xvYWQnLCAnZXJyb3InLCAnbG9hZGVuZCddLCBuYW1lKSkge1xuICAgICAgICAvLyBjZXJ0YWluIGxpc3RlbmVycyBhcmUgY2FsbGVkIG1hbnVhbGx5IHNvIHRoYXQgdGhlIGZpbmFsXG4gICAgICAgIC8vIGNhbGwgKHdoZW4gcmVhZHlTdGF0ZT09NCkgY2FuIGJlIGRlbGF5ZWQuXG4gICAgICAgIHRoaXMuX3JlYWx4aHIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBib3VuZExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFhIUlByb3h5LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBsaXN0ZW5lcjogdW5rbm93bixcbiAgKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgIGlmIChpID09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdLnNwbGljZShpLCAxKTtcblxuICAgIHZhciBib3VuZExpc3RlbmVyID0gdGhpcy5fYm91bmRMaXN0ZW5lcnNbbmFtZV0uc3BsaWNlKGksIDEpWzBdO1xuXG4gICAgaWYgKG5hbWUgIT0gJ3JlYWR5c3RhdGVjaGFuZ2UnKSB7XG4gICAgICB0aGlzLl9yZWFseGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgYm91bmRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBYSFJQcm94eS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChcbiAgICB0aGlzOiBYSFJQcm94eVRoaXMsXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXN5bmM6IGJvb2xlYW4sXG4gICkge1xuICAgIC8vIFdvcmsgYXJvdW5kIE1haWxUcmFjayBpc3N1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBYSFJQcm94eSkpIHtcbiAgICAgIHJldHVybiBYSFIucHJvdG90eXBlLm9wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzIGFzIGFueSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgcGFyYW1zOiBkZXBhcmFtKHVybC5zcGxpdCgnPycpWzFdIHx8ICcnKSxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgYXN5bmM6IGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8ICEhYXN5bmMsXG4gICAgfTtcbiAgICB0aGlzLl9jbGllbnRTdGFydGVkU2VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWxTdGFydGVkU2VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZVdyYXBwZXJzID0gZmluZEFwcGxpY2FibGVXcmFwcGVycyhcbiAgICAgIHRoaXMuX3dyYXBwZXJzLFxuICAgICAgdGhpcy5fY29ubmVjdGlvbixcbiAgICApO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGV4dENoYW5nZXJzID0gdGhpcy5fYWN0aXZlV3JhcHBlcnNcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB3cmFwcGVyLnJlc3BvbnNlVGV4dENoYW5nZXIgJiZcbiAgICAgICAgICB3cmFwcGVyLnJlc3BvbnNlVGV4dENoYW5nZXIuYmluZCh3cmFwcGVyKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSAnJztcbiAgICB0aGlzLl9vcGVuU3RhdGUgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoKG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHNlbGYuX3JlYWx4aHIub3BlbihtZXRob2QsIHVybCwgc2VsZi5fY29ubmVjdGlvbi5hc3luYyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24uYXN5bmMpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RDaGFuZ2VycyA9IHRoaXMuX2FjdGl2ZVdyYXBwZXJzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlci5yZXF1ZXN0Q2hhbmdlciAmJiB3cmFwcGVyLnJlcXVlc3RDaGFuZ2VyLmJpbmQod3JhcHBlcik7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0Q2hhbmdlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gMSkge1xuICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IDE7XG5cbiAgICAgICAgICB0aGlzLl9mYWtlUnNjRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoKG1ldGhvZCwgdXJsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKG1ldGhvZCwgdXJsKTtcbiAgICB9XG4gIH07XG5cbiAgWEhSUHJveHkucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoYm9keTogdW5rbm93bikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9jbGllbnRTdGFydGVkU2VuZCA9IHRydWU7XG4gICAgdGhpcy5fb3BlblN0YXRlID0gZmFsc2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX2Nvbm5lY3Rpb24sICdvcmlnaW5hbFNlbmRCb2R5Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogYm9keSxcbiAgICB9KTtcbiAgICB0aGlzLl9jb25uZWN0aW9uLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3JlYWx4aHIucmVzcG9uc2VUeXBlIHx8ICd0ZXh0JztcbiAgICBlYWNoKHNlbGYuX2FjdGl2ZVdyYXBwZXJzLCBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIub3JpZ2luYWxTZW5kQm9keUxvZ2dlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdyYXBwZXIub3JpZ2luYWxTZW5kQm9keUxvZ2dlcihzZWxmLl9jb25uZWN0aW9uLCBib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goYm9keTogdW5rbm93bikge1xuICAgICAgc2VsZi5fcmVhbFN0YXJ0ZWRTZW5kID0gdHJ1ZTtcblxuICAgICAgc2VsZi5fcmVhbHhoci5zZW5kKGJvZHkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uLmFzeW5jICYmIHRoaXMuX3JlcXVlc3RDaGFuZ2Vycy5sZW5ndGgpIHtcbiAgICAgIC8vIElmIHRoZSBYSFIgb2JqZWN0IGlzIHJlLXVzZWQgZm9yIGFub3RoZXIgY29ubmVjdGlvbiwgdGhlbiB3ZSBuZWVkXG4gICAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCBvdXIgdXBjb21pbmcgYXN5bmMgY2FsbHMgaGVyZSBkbyBub3RoaW5nLlxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBvYmplY3QsIGFuZCBkbyBub3RoaW5nIGluIG91ciBhc3luY1xuICAgICAgLy8gY2FsbHMgaWYgaXQgbm8gbG9uZ2VyIG1hdGNoZXMuIEFsc28gY2hlY2sgZm9yIGFib3J0cy5cbiAgICAgIGNvbnN0IHN0YXJ0Q29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuX2Nvbm5lY3Rpb24ubWV0aG9kLFxuICAgICAgICB1cmw6IHRoaXMuX2Nvbm5lY3Rpb24udXJsLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBtb2RpZmllZFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDaGFuZ2VyIG9mIHRoaXMuX3JlcXVlc3RDaGFuZ2Vycykge1xuICAgICAgICAgIGNvbnN0IGxvbmdSdW5XYXJuaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ3JlcXVlc3RDaGFuZ2VyIGlzIHRha2luZyB0b28gbG9uZycsXG4gICAgICAgICAgICAgIHJlcXVlc3RDaGFuZ2VyLFxuICAgICAgICAgICAgICBzdGFydENvbm5lY3Rpb24sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIFdBUk5JTkdfVElNRU9VVCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9kaWZpZWRSZXF1ZXN0ID0gYXdhaXQgcmVxdWVzdENoYW5nZXIoXG4gICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUobW9kaWZpZWRSZXF1ZXN0KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChsb25nUnVuV2FybmluZ1RpbWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQoaGFzKG1vZGlmaWVkUmVxdWVzdCwgJ21ldGhvZCcpLCAnbW9kaWZpZWRSZXF1ZXN0IGhhcyBtZXRob2QnKTtcbiAgICAgICAgICBhc3NlcnQoaGFzKG1vZGlmaWVkUmVxdWVzdCwgJ3VybCcpLCAnbW9kaWZpZWRSZXF1ZXN0IGhhcyB1cmwnKTtcbiAgICAgICAgICBhc3NlcnQoaGFzKG1vZGlmaWVkUmVxdWVzdCwgJ2JvZHknKSwgJ21vZGlmaWVkUmVxdWVzdCBoYXMgYm9keScpO1xuICAgICAgICAgIGlmIChzdGFydENvbm5lY3Rpb24gIT09IHRoaXMuX2Nvbm5lY3Rpb24gfHwgdGhpcy5fcmVhbFN0YXJ0ZWRTZW5kKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZWRSZXF1ZXN0O1xuICAgICAgfSkoKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGxvZ0Vycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChtb2RpZmllZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICBpZiAoc3RhcnRDb25uZWN0aW9uID09PSB0aGlzLl9jb25uZWN0aW9uICYmICF0aGlzLl9yZWFsU3RhcnRlZFNlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWx4aHIub3Blbihtb2RpZmllZFJlcXVlc3QubWV0aG9kLCBtb2RpZmllZFJlcXVlc3QudXJsKTtcblxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ3JlYWxPcGVuJyk7XG5cbiAgICAgICAgICAgIGZpbmlzaChtb2RpZmllZFJlcXVlc3QuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKGJvZHkpO1xuICAgIH1cbiAgfTtcblxuICBbWEhSUHJveHksIFhIUlByb3h5LnByb3RvdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgT2JqZWN0LmFzc2lnbihvYmosIHtcbiAgICAgIFVOU0VOVDogMCxcbiAgICAgIE9QRU5FRDogMSxcbiAgICAgIEhFQURFUlNfUkVDRUlWRUQ6IDIsXG4gICAgICBMT0FESU5HOiAzLFxuICAgICAgRE9ORTogNCxcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBYSFJQcm94eSBhcyBhbnk7XG59XG4iLCJpbXBvcnQgaW50ZXJzZWN0aW9uIGZyb20gJ2xvZGFzaC9pbnRlcnNlY3Rpb24nO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4uLy4uL2luamVjdGVkLWxvZ2dlcic7XG5pbXBvcnQgeyBjbGVhbnVwUGVvcGxlTGluZSB9IGZyb20gJy4uLy4uLy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RvbS1kcml2ZXIvZ21haWwvZ21haWwtcmVzcG9uc2UtcHJvY2Vzc29yJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9hc3NlcnQnO1xuXG5leHBvcnQgdHlwZSBUaHJlYWRSb3dNZXRhZGF0YSA9IHtcbiAgdGltZVN0cmluZzogc3RyaW5nO1xuICBzdWJqZWN0OiBzdHJpbmc7XG4gIHBlb3BsZUh0bWw6IHN0cmluZztcbn07XG5cbi8qKlxuICogQWRzIGluIHRoZSBQcm9tb3Rpb25zIHRhYiBhcmVuJ3QgaW5jbHVkZWQgd2l0aCBvdGhlciB0aHJlYWQgcm93IGRhdGEuXG4gKi9cbmV4cG9ydCBjb25zdCBUaHJlYWRSb3dBZCA9IFN5bWJvbChgVGhyZWFkUm93QWRgKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RNZXRhZGF0YUZyb21UaHJlYWRSb3coXG4gIHRocmVhZFJvdzogSFRNTEVsZW1lbnQsXG4pOiBUaHJlYWRSb3dNZXRhZGF0YSB8IHR5cGVvZiBUaHJlYWRSb3dBZCB7XG4gIHZhciB0aW1lU3Bhbiwgc3ViamVjdFNwYW4sIHBlb3BsZURpdjtcbiAgYXNzZXJ0KHRocmVhZFJvdy5oYXNBdHRyaWJ1dGUoJ2lkJyksICdjaGVjayBlbGVtZW50IGlzIG1haW4gdGhyZWFkIHJvdycpO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB0aHJlYWRSb3dJc1ZlcnRpY2FsID1cbiAgICBpbnRlcnNlY3Rpb24oQXJyYXkuZnJvbSh0aHJlYWRSb3cuY2xhc3NMaXN0KSwgWyd6QScsICdhcHYnXSkubGVuZ3RoID09PSAyO1xuICBjb25zdCBpc1RocmVhZFJvd0FkID0gdGhyZWFkUm93LnF1ZXJ5U2VsZWN0b3IoJy5hbTAsLmJ2QScpO1xuXG4gIGlmIChpc1RocmVhZFJvd0FkKSB7XG4gICAgcmV0dXJuIFRocmVhZFJvd0FkO1xuICB9IGVsc2UgaWYgKHRocmVhZFJvd0lzVmVydGljYWwpIHtcbiAgICB2YXIgdGhyZWFkUm93MiA9IHRocmVhZFJvdy5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICBpZiAoIXRocmVhZFJvdzIpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdmYWlsZWQgdG8gZmluZCB0aHJlYWRSb3cyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0aHJlYWRSb3czID0gdGhyZWFkUm93Mi5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgIGlmICghdGhyZWFkUm93MyB8fCAhdGhyZWFkUm93My5jbGFzc0xpc3QuY29udGFpbnMoJ2FwdycpKSB7XG4gICAgICAgIHRocmVhZFJvdzMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aW1lU3BhbiA9IHRocmVhZFJvdy5xdWVyeVNlbGVjdG9yKCd0ZC5hcHQgPiBkaXYuYXBtID4gc3Bhblt0aXRsZV0nKTtcbiAgICAgIHN1YmplY3RTcGFuID0gdGhyZWFkUm93Mi5xdWVyeVNlbGVjdG9yKCd0ZCBkaXYueFMgZGl2LnhUIGRpdi55NiA+IHNwYW4nKTtcbiAgICAgIHBlb3BsZURpdiA9IHRocmVhZFJvdy5xdWVyeVNlbGVjdG9yKCd0ZC5hcHkgPiBkaXYueVcsIHRkLmFweCA+IGRpdi55VycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lU3BhbiA9IHRocmVhZFJvdy5xdWVyeVNlbGVjdG9yKCd0ZC54VyA+IHNwYW5bdGl0bGVdJyk7XG4gICAgdmFyIHN1YmplY3RBcmVhRGl2ID0gdGhyZWFkUm93LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAndGQuYTRXIGRpdltyb2xlPWxpbmtdIGRpdi55NicsXG4gICAgKTtcblxuICAgIGlmIChzdWJqZWN0QXJlYURpdiAmJiBzdWJqZWN0QXJlYURpdi5jaGlsZHJlbi5sZW5ndGggPj0gMSkge1xuICAgICAgc3ViamVjdFNwYW4gPSBzdWJqZWN0QXJlYURpdi5jaGlsZHJlblswXTsgLy8gYm9keSBzbmlwcGV0IGlzIG5vdCBhbHdheXMgcHJlc2VudC5cbiAgICAgIC8vdmFyIGJvZHlTbmlwcGV0U3BhbiA9IHN1YmplY3RBcmVhRGl2LmNoaWxkcmVuWzFdO1xuICAgIH1cblxuICAgIHBlb3BsZURpdiA9IHRocmVhZFJvdy5xdWVyeVNlbGVjdG9yKCd0ZC55WCA+IGRpdi55VycpO1xuICB9XG5cbiAgaWYgKCF0aW1lU3Bhbikge1xuICAgIGVycm9ycy5wdXNoKCdmYWlsZWQgdG8gZmluZCB0aW1lU3BhbicpO1xuICB9XG5cbiAgaWYgKCFzdWJqZWN0U3Bhbikge1xuICAgIGVycm9ycy5wdXNoKCdmYWlsZWQgdG8gZmluZCBzdWJqZWN0U3BhbicpO1xuICB9XG5cbiAgaWYgKCFwZW9wbGVEaXYpIHtcbiAgICBlcnJvcnMucHVzaCgnZmFpbGVkIHRvIGZpbmQgcGVvcGxlRGl2Jyk7XG4gIH1cblxuICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgIGxvZ2dlci5lcnJvcihuZXcgRXJyb3IoJ0Vycm9ycyBpbiB0aHJlYWQgcm93IHBhcnNpbmcnKSwge1xuICAgICAgZXJyb3JzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RyaW5nOiB0aW1lU3BhbiA/IHRpbWVTcGFuLmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJyA6ICcnLFxuICAgIHN1YmplY3Q6IHN1YmplY3RTcGFuID8gc3ViamVjdFNwYW4udGV4dENvbnRlbnQhIDogJycsXG4gICAgcGVvcGxlSHRtbDogcGVvcGxlRGl2ID8gY2xlYW51cFBlb3BsZUxpbmUocGVvcGxlRGl2LmlubmVySFRNTCkgOiAnJyxcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tICdsb2Rhc2gvY29uc3RhbnQnO1xuaW1wb3J0IG5vb3AgZnJvbSAnbG9kYXNoL25vb3AnO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4uLy4uL2luamVjdGVkLWxvZ2dlcic7XG5jb25zdCBpZ25vcmVFcnJvcnMgPSBjb25zdGFudCh0cnVlKTtcblxuZnVuY3Rpb24gZ2V0SWZPd24ob2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wOiBzdHJpbmcpOiBhbnkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHtcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFNpbXVsYXRlcyBhIGNvbnRyb2wrbWV0YSBjbGljayBvbiBhbiBlbGVtZW50LCBpbnRlcmNlcHRzIHRoZSBjYWxsIHRvXG4vLyB3aW5kb3cub3BlbiwgYW5kIHJldHVybnMgdGhlIGF0dGVtcHRlZCBwb3B1cCdzIFVSTC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpY2tBbmRHZXRQb3B1cFVybChcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4pOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgYnV0dG9uOiAwLFxuICAgIHBvaW50ZXJYOiAwLFxuICAgIHBvaW50ZXJZOiAwLFxuICAgIGN0cmxLZXk6IHRydWUsXG4gICAgYWx0S2V5OiBmYWxzZSxcbiAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgbWV0YUtleTogdHJ1ZSxcbiAgfTtcbiAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoXG4gICAgJ2NsaWNrJyxcbiAgICBvcHRpb25zLmJ1YmJsZXMsXG4gICAgb3B0aW9ucy5jYW5jZWxhYmxlLFxuICAgIGRvY3VtZW50LmRlZmF1bHRWaWV3ISxcbiAgICBvcHRpb25zLmJ1dHRvbixcbiAgICBvcHRpb25zLnBvaW50ZXJYLFxuICAgIG9wdGlvbnMucG9pbnRlclksXG4gICAgb3B0aW9ucy5wb2ludGVyWCxcbiAgICBvcHRpb25zLnBvaW50ZXJZLFxuICAgIG9wdGlvbnMuY3RybEtleSxcbiAgICBvcHRpb25zLmFsdEtleSxcbiAgICBvcHRpb25zLnNoaWZ0S2V5LFxuICAgIG9wdGlvbnMubWV0YUtleSxcbiAgICBvcHRpb25zLmJ1dHRvbixcbiAgICBudWxsLFxuICApO1xuICBsZXQgdXJsO1xuICBjb25zdCBvbGRXaW5kb3dPcGVuID0gd2luZG93Lm9wZW4sXG4gICAgb2xkV2luZG93T25lcnJvciA9IHdpbmRvdy5vbmVycm9yLFxuICAgIG9sZEZvY3VzID0gZ2V0SWZPd24od2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2ZvY3VzJyksXG4gICAgb2xkQmx1ciA9IGdldElmT3duKHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsICdibHVyJyk7XG5cbiAgdHJ5IHtcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzID0gbm9vcDtcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmJsdXIgPSBub29wO1xuICAgIHdpbmRvdy5vbmVycm9yID0gaWdub3JlRXJyb3JzO1xuXG4gICAgY29uc3QgbmV3T3BlbiA9IGZ1bmN0aW9uIChfdXJsOiBzdHJpbmcsIF90aXRsZTogc3RyaW5nLCBfb3B0aW9uczogYW55KSB7XG4gICAgICB1cmwgPSBfdXJsO1xuICAgICAgLy8gR21haWwgY2hlY2tzIHRoZSByZXR1cm5lZCBvYmplY3QgZm9yIHRoZXNlIHR3byB2YWx1ZXMgc3BlY2lmaWNhbGx5LlxuICAgICAgY29uc3QgbmV3V2luID0ge1xuICAgICAgICBjbG9zZWQ6IGZhbHNlLFxuICAgICAgICBmb2N1czogbm9vcCxcbiAgICAgIH07XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV3V2luLmNsb3NlZCA9IHRydWU7XG4gICAgICB9LCA1KTtcbiAgICAgIHJldHVybiBuZXdXaW47XG4gICAgfTtcblxuICAgIHdpbmRvdy5vcGVuID0gbmV3T3BlbiBhcyBhbnk7XG5cbiAgICAvLyBJZiBhbm90aGVyIGV4dGVuc2lvbiBjcmVhdGVkIGEgc2V0dGVyIG9uIHdpbmRvdy5vcGVuLCB0aGVuIHNldHRpbmcgaXRcbiAgICAvLyBjb3VsZCBoYXZlIGZhaWxlZC4gTG9nIHRvIHNlZSBpZiB0aGlzIGlzIGEgdGhpbmcgdGhhdCBldmVyIGhhcHBlbnMsIGFuZFxuICAgIC8vIGF2b2lkIGxldHRpbmcgd2luZG93cyBiZSBvcGVuZWQuXG4gICAgaWYgKHdpbmRvdy5vcGVuICE9PSBuZXdPcGVuKSB7XG4gICAgICBsb2dnZXIuZXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gb3ZlcnJpZGUgd2luZG93Lm9wZW4nKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvbGRGb2N1cykge1xuICAgICAgd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9IG9sZEZvY3VzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgKHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUgYXMgYW55KS5mb2N1cztcbiAgICB9XG5cbiAgICBpZiAob2xkQmx1cikge1xuICAgICAgd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5ibHVyID0gb2xkQmx1cjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlICh3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlIGFzIGFueSkuYmx1cjtcbiAgICB9XG5cbiAgICB3aW5kb3cub25lcnJvciA9IG9sZFdpbmRvd09uZXJyb3I7XG4gICAgd2luZG93Lm9wZW4gPSBvbGRXaW5kb3dPcGVuO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsIi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIEBzZWUgRWxlbWVudC5jbG9zZXN0IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQYXJlbnQoXG4gIGVsOiBIVE1MRWxlbWVudCxcbiAgY2I6IChlbDogRWxlbWVudCkgPT4gYm9vbGVhbixcbik6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gIGxldCBjYW5kaWRhdGUgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoY2FuZGlkYXRlKSB7XG4gICAgaWYgKGNiKGNhbmRpZGF0ZSkpIHtcbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiZXhwb3J0IGNvbnN0IGVudW0gQ3VzdG9tRG9tRXZlbnQge1xuICB0ZWxsTWVUaGlzVGhyZWFkSWRCeURhdGFiYXNlID0gJ2luYm94U0RLdGVsbE1lVGhpc1RocmVhZElkQnlEYXRhYmFzZScsXG4gIHRlbGxNZVRoaXNUaHJlYWRJZEJ5Q2xpY2sgPSAnaW5ib3hTREt0ZWxsTWVUaGlzVGhyZWFkSWRCeUNsaWNrJyxcbn1cbiIsImltcG9ydCBmaW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCAqIGFzIEdtYWlsUmVzcG9uc2VQcm9jZXNzb3IgZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1yZXNwb25zZS1wcm9jZXNzb3InO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnLi4vLi4vaW5qZWN0ZWQtbG9nZ2VyJztcbmltcG9ydCAqIGFzIHRocmVhZFJvd1BhcnNlciBmcm9tICcuL3RocmVhZC1yb3ctcGFyc2VyJztcbmltcG9ydCBjbGlja0FuZEdldFBvcHVwVXJsIGZyb20gJy4vY2xpY2stYW5kLWdldC1wb3B1cC11cmwnO1xuaW1wb3J0IGZpbmRQYXJlbnQgZnJvbSAnLi4vLi4vLi4vY29tbW9uL2ZpbmQtcGFyZW50JztcbmltcG9ydCB7IEN1c3RvbURvbUV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvbGliL2RvbS9jdXN0b20tZXZlbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwKCkge1xuICB0cnkge1xuICAgIHByb2Nlc3NQcmVsb2FkZWRUaHJlYWRzKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihlcnIsICdGYWlsZWQgdG8gcHJvY2VzcyBwcmVsb2FkZWQgdGhyZWFkIGlkZW50aWZpZXJzJyk7XG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgIEN1c3RvbURvbUV2ZW50LnRlbGxNZVRoaXNUaHJlYWRJZEJ5RGF0YWJhc2UsXG4gICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZW50LnRhcmdldCBpcyBub3QgYW4gSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGdldEdtYWlsVGhyZWFkSWRGb3JUaHJlYWRSb3dCeURhdGFiYXNlKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKHRocmVhZElkKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1pbmJveHNkay10aHJlYWRpZCcsIHRocmVhZElkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnIsICdFcnJvciBpbiBpbmJveFNES3RlbGxNZVRoaXNUaHJlYWRJZEJ5RGF0YWJhc2UnKTtcbiAgICAgIH1cbiAgICB9LFxuICApO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgIEN1c3RvbURvbUV2ZW50LnRlbGxNZVRoaXNUaHJlYWRJZEJ5Q2xpY2ssXG4gICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZW50LnRhcmdldCBpcyBub3QgYW4gSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRocmVhZElkID0gZ2V0R21haWxUaHJlYWRJZEZvclRocmVhZFJvd0J5Q2xpY2soZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAodGhyZWFkSWQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLXRocmVhZGlkJywgdGhyZWFkSWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVyciwgJ0Vycm9yIGluIGluYm94U0RLdGVsbE1lVGhpc1RocmVhZElkQnlDbGljaycpO1xuICAgICAgfVxuICAgIH0sXG4gICk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1RocmVhZExpc3RSZXNwb25zZSh0aHJlYWRMaXN0UmVzcG9uc2U6IHN0cmluZykge1xuICBwcm9jZXNzVGhyZWFkcyhHbWFpbFJlc3BvbnNlUHJvY2Vzc29yLmV4dHJhY3RUaHJlYWRzKHRocmVhZExpc3RSZXNwb25zZSkpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVGhyZWFkcyh0aHJlYWRzOiBHbWFpbFJlc3BvbnNlUHJvY2Vzc29yLlRocmVhZFtdKSB7XG4gIHRocmVhZHMuZm9yRWFjaChzdG9yZVRocmVhZE1ldGFkYXRhKTtcbn1cblxudHlwZSBBbWJpZ3VvdXNNYXJrZXIgPSB7XG4gIG5hbWU6ICdBTUJJR1VPVVMnO1xufTtcbmNvbnN0IEFNQklHVU9VUzogQW1iaWd1b3VzTWFya2VyID0ge1xuICBuYW1lOiAnQU1CSUdVT1VTJyxcbn07XG5jb25zdCB0aHJlYWRJZHNCeUtleTogTWFwPHN0cmluZywgc3RyaW5nIHwgQW1iaWd1b3VzTWFya2VyPiA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gc3RvcmVUaHJlYWRNZXRhZGF0YSh0aHJlYWRNZXRhZGF0YTogR21haWxSZXNwb25zZVByb2Nlc3Nvci5UaHJlYWQpIHtcbiAgdmFyIGtleSA9IHRocmVhZE1ldGFkYXRhS2V5KHRocmVhZE1ldGFkYXRhKTtcblxuICBpZiAodGhyZWFkSWRzQnlLZXkuaGFzKGtleSkpIHtcbiAgICBpZiAodGhyZWFkSWRzQnlLZXkuZ2V0KGtleSkgIT09IHRocmVhZE1ldGFkYXRhLmdtYWlsVGhyZWFkSWQpIHtcbiAgICAgIHRocmVhZElkc0J5S2V5LnNldChrZXksIEFNQklHVU9VUyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocmVhZElkc0J5S2V5LnNldChrZXksIHRocmVhZE1ldGFkYXRhLmdtYWlsVGhyZWFkSWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocmVhZE1ldGFkYXRhS2V5KFxuICB0aHJlYWRSb3dNZXRhZGF0YTogdGhyZWFkUm93UGFyc2VyLlRocmVhZFJvd01ldGFkYXRhLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIChcbiAgICB0aHJlYWRSb3dNZXRhZGF0YS5zdWJqZWN0LnRyaW0oKSArXG4gICAgJzonICtcbiAgICB0aHJlYWRSb3dNZXRhZGF0YS50aW1lU3RyaW5nLnRyaW0oKSArXG4gICAgJzonICtcbiAgICB0aHJlYWRSb3dNZXRhZGF0YS5wZW9wbGVIdG1sLnRyaW0oKVxuICApO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlbG9hZGVkVGhyZWFkcygpIHtcbiAgY29uc3QgcHJlbG9hZFNjcmlwdCA9IGZpbmQoXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MU2NyaXB0RWxlbWVudD4oJ3NjcmlwdDpub3QoW3NyY10pJyksXG4gICAgKHNjcmlwdCkgPT5cbiAgICAgIHNjcmlwdC50ZXh0ICYmIHNjcmlwdC50ZXh0LnNsaWNlKDAsIDUwMCkuaW5kZXhPZigndmFyIFZJRVdfREFUQT1bWycpID4gLTEsXG4gICkgYXMgSFRNTFNjcmlwdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG5cbiAgaWYgKCFwcmVsb2FkU2NyaXB0KSB7XG4gICAgLy8gcHJlbG9hZFNjcmlwdCBpcyBub3QgYXZhaWxhYmxlIGluIGdtYWlsIHYyLCBzbyBsZXQncyBzdG9wIGxvZ2dpbmcgYW4gZXJyb3JcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlyc3RCcmFja2V0ID0gcHJlbG9hZFNjcmlwdC50ZXh0LmluZGV4T2YoJ1snKTtcbiAgICBjb25zdCBsYXN0QnJhY2tldCA9IHByZWxvYWRTY3JpcHQudGV4dC5sYXN0SW5kZXhPZignXScpO1xuICAgIGNvbnN0IHZpZXdEYXRhU3RyaW5nID0gcHJlbG9hZFNjcmlwdC50ZXh0LnNsaWNlKFxuICAgICAgZmlyc3RCcmFja2V0LFxuICAgICAgbGFzdEJyYWNrZXQgKyAxLFxuICAgICk7XG4gICAgcHJvY2Vzc1RocmVhZHMoXG4gICAgICBHbWFpbFJlc3BvbnNlUHJvY2Vzc29yLmV4dHJhY3RUaHJlYWRzRnJvbURlc2VyaWFsaXplZChbXG4gICAgICAgIEdtYWlsUmVzcG9uc2VQcm9jZXNzb3IuZGVzZXJpYWxpemVBcnJheSh2aWV3RGF0YVN0cmluZyksXG4gICAgICBdKSxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRocmVhZElkRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQge1xuICB2YXIgdGlkID0gcGFyc2UodXJsKS50aDtcblxuICBpZiAoIXRpZCkge1xuICAgIC8vIGRyYWZ0cyBpbiBzeW5jIHdvcmxkIGNhbiBoYXZlIHdlaXJkIHVybHMgdGhhdCBraW5kIG9mXG4gICAgLy8gbG9vayBsaWtlIG9sZCBzdHlsZSB1cmxzLCBhbmQgZ2V0IGhhbmRsZWQgcHJvcGVybHkgaGVyZVxuICAgIHZhciB1cmxIYXNoTWF0Y2ggPSB1cmwubWF0Y2goLyMoLiopLyk7XG5cbiAgICBpZiAodXJsSGFzaE1hdGNoKSB7XG4gICAgICAvLyBkcmFmdHMgaGF2ZSB0aGUgaGFzaCBpbiB0aGVtIHdpdGhvdXQgdGhlIHRoPVxuICAgICAgdXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmxIYXNoTWF0Y2hbMV0pKTtcbiAgICAgIHRpZCA9IHBhcnNlKHVybCkudGg7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UncmUgaW4gc3luYyB3b3JsZCBhbmQgaXQncyBhXG4gIC8vIGRyYWZ0IHRoZW4gYSBoYXNoIGNhbiBjb21lIHRocm91Z2ggaW4gdGhlIGJlZ2lubmluZ1xuICByZXR1cm4gKHRpZCBhcyBzdHJpbmcpIS5yZXBsYWNlKCcjJywgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRHbWFpbFRocmVhZElkRm9yVGhyZWFkUm93QnlEYXRhYmFzZShcbiAgdGhyZWFkUm93OiBIVE1MRWxlbWVudCxcbik6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQge1xuICBjb25zdCBkb21Sb3dNZXRhZGF0YSA9XG4gICAgdGhyZWFkUm93UGFyc2VyLmV4dHJhY3RNZXRhZGF0YUZyb21UaHJlYWRSb3codGhyZWFkUm93KTtcblxuICBpZiAoZG9tUm93TWV0YWRhdGEgPT09IHRocmVhZFJvd1BhcnNlci5UaHJlYWRSb3dBZCkge1xuICAgIC8vIFRPRE8gZG8gd2Ugd2FudCB0byBkbyBhbnl0aGluZyBoZXJlP1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IHRocmVhZE1ldGFkYXRhS2V5KGRvbVJvd01ldGFkYXRhKTtcbiAgY29uc3QgdmFsdWUgPSB0aHJlYWRJZHNCeUtleS5nZXQoa2V5KTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRHbWFpbFRocmVhZElkRm9yVGhyZWFkUm93QnlDbGljayhcbiAgdGhyZWFkUm93OiBIVE1MRWxlbWVudCxcbik6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQge1xuICAvLyBTaW11bGF0ZSBhIGN0cmwtY2xpY2sgb24gdGhlIHRocmVhZCByb3cgdG8gZ2V0IHRoZSB0aHJlYWQgaWQsIHRoZW5cbiAgLy8gc2ltdWxhdGUgYSBjdHJsLWNsaWNrIG9uIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHRocmVhZCByb3cgKG9yIHRoZVxuICAvLyBmaXJzdCB0aHJlYWQgcm93KSB0byBwdXQgdGhlIGN1cnNvciBiYWNrIHdoZXJlIGl0IHdhcy5cbiAgdGhyZWFkUm93UGFyc2VyLmV4dHJhY3RNZXRhZGF0YUZyb21UaHJlYWRSb3codGhyZWFkUm93KTtcbiAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudChcbiAgICB0aHJlYWRSb3csXG4gICAgKGVsKSA9PiBlbC5ub2RlTmFtZSA9PT0gJ0RJVicgJiYgZWwuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdtYWluJyxcbiAgKTtcblxuICBpZiAoIXBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IG9wZXJhdGUgb24gZGlzY29ubmVjdGVkIHRocmVhZCByb3dcIik7XG4gIH1cblxuICBjb25zdCBjdXJyZW50Um93U2VsZWN0aW9uID1cbiAgICBwYXJlbnQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJ3RkLlBFJykgfHxcbiAgICBwYXJlbnQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJ3RyJyk7XG4gIGNvbnN0IHVybCA9IGNsaWNrQW5kR2V0UG9wdXBVcmwodGhyZWFkUm93KTtcbiAgY29uc3QgdGhyZWFkSWQgPSB1cmwgJiYgZ2V0VGhyZWFkSWRGcm9tVXJsKHVybCk7XG5cbiAgaWYgKGN1cnJlbnRSb3dTZWxlY3Rpb24pIHtcbiAgICBjbGlja0FuZEdldFBvcHVwVXJsKGN1cnJlbnRSb3dTZWxlY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIHRocmVhZElkO1xufVxuIiwiLy8gVHlwZSBwcmVkaWNhdGUgdG8gYXZvaWQgb3B0aW5nIG91dCBvZiBzdHJpY3QgdHlwZSBjaGVja2luZyBpbiBmaWx0ZXIgb3BlcmF0aW9ucy5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDY3MDA3OTFcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTm90TmlsPFRWYWx1ZT4oXG4gIHZhbHVlOiBUVmFsdWUgfCBudWxsIHwgdW5kZWZpbmVkLFxuKTogdmFsdWUgaXMgVFZhbHVlIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG59XG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgaXNOb3ROaWwgZnJvbSAnLi4vLi4vbGliL2lzTm90TmlsJztcblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGVtYWlsQWRkcmVzczogc3RyaW5nO1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNUaHJlYWQge1xuICBzdWJqZWN0OiBzdHJpbmc7XG4gIHNuaXBwZXQ6IHN0cmluZztcbiAgc3luY1RocmVhZElEOiBzdHJpbmc7XG4gIG9sZEdtYWlsVGhyZWFkSUQ6IHN0cmluZztcbiAgcmF3UmVzcG9uc2U6IGFueTtcbiAgZXh0cmFNZXRhRGF0YToge1xuICAgIHNuaXBwZXQ6IHN0cmluZztcbiAgICBzeW5jTWVzc2FnZURhdGE6IEFycmF5PHtcbiAgICAgIHN5bmNNZXNzYWdlSUQ6IHN0cmluZztcbiAgICAgIG9sZE1lc3NhZ2VJRD86IHN0cmluZztcbiAgICAgIGRhdGU6IG51bWJlcjtcbiAgICAgIHJlY2lwaWVudHM/OiBSZWNpcGllbnRbXTtcbiAgICB9PjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaW5pbWFsU3luY1RocmVhZCB7XG4gIHN5bmNUaHJlYWRJRDogc3RyaW5nO1xuICBleHRyYU1ldGFEYXRhOiB7XG4gICAgc3luY01lc3NhZ2VEYXRhOiBBcnJheTx7XG4gICAgICBzeW5jTWVzc2FnZUlEOiBzdHJpbmc7XG4gICAgICBkYXRlOiBudW1iZXI7XG4gICAgICByZWNpcGllbnRzPzogUmVjaXBpZW50W107XG4gICAgfT47XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGhyZWFkc0Zyb21TZWFyY2hSZXNwb25zZShcbiAgcmVzcG9uc2U6IHN0cmluZyxcbik6IFN5bmNUaHJlYWRbXSB7XG4gIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUmVzcG9uc2UpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBleHRyYWN0VGhyZWFkc0Zyb21TZWFyY2hSZXNwb25zZV8yMDIyMDkwOShwYXJzZWRSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGhyZWFkRGVzY3JpcHRvcnM6IGFueVtdIHwgbnVsbCA9IHBhcnNlZFJlc3BvbnNlICYmIHBhcnNlZFJlc3BvbnNlWzNdO1xuXG4gIGlmICghdGhyZWFkRGVzY3JpcHRvcnMpIHJldHVybiBbXTtcblxuICByZXR1cm4gdGhyZWFkRGVzY3JpcHRvcnNcbiAgICAubWFwKChkZXNjcmlwdG9yV3JhcHBlciwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yV3JhcHBlclsxXTtcbiAgICAgIGlmICghZGVzY3JpcHRvcikgcmV0dXJuIG51bGw7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1YmplY3Q6IGRlc2NyaXB0b3JbMV0sXG4gICAgICAgIHNuaXBwZXQ6IGRlc2NyaXB0b3JbMl0sXG4gICAgICAgIHN5bmNUaHJlYWRJRDogZGVzY3JpcHRvcls0XSxcbiAgICAgICAgLy8gSXQgc2VlbXMgR21haWwgaXMgQS9CIHRlc3RpbmcgaW5jbHVkaW5nIGdtYWlsVGhyZWFkSUQgaW4gZGVzY3JpcHRvclsyMF0gYW5kIG5vdCBpbmNsdWRpbmdcbiAgICAgICAgLy8gdGhlIGVuY29kZWQgdmVyc2lvbiBvZiBpdCBpbiBkZXNjcmlwdG9yWzE4XSwgc28gcHVsbCBpdCBmcm9tIFsyMF0gaWYgWzE4XSBpcyBub3Qgc2V0LlxuICAgICAgICBvbGRHbWFpbFRocmVhZElEOlxuICAgICAgICAgIGRlc2NyaXB0b3JbMThdICE9IG51bGxcbiAgICAgICAgICAgID8gbmV3IEJpZ051bWJlcihkZXNjcmlwdG9yWzE4XSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICA6IGRlc2NyaXB0b3JbMjBdLFxuICAgICAgICByYXdSZXNwb25zZTogZGVzY3JpcHRvcldyYXBwZXIsXG4gICAgICAgIGV4dHJhTWV0YURhdGE6IHtcbiAgICAgICAgICBzbmlwcGV0OlxuICAgICAgICAgICAgKHBhcnNlZFJlc3BvbnNlWzE1XSAmJlxuICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZVsxNV1bMV0gJiZcbiAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2VbMTVdWzFdW2luZGV4XSkgfHxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgIHN5bmNNZXNzYWdlRGF0YTogZGVzY3JpcHRvcls1XS5tYXAoKG1kOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBzeW5jTWVzc2FnZUlEOiBtZFsxXSxcbiAgICAgICAgICAgIG9sZE1lc3NhZ2VJRDogbWRbNTZdLFxuICAgICAgICAgICAgZGF0ZTogK21kWzddLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAuZmlsdGVyKGlzTm90TmlsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUaHJlYWRzRnJvbVNlYXJjaFJlc3BvbnNlXzIwMjIwOTA5KFxuICBwYXJzZWRSZXNwb25zZTogYW55W10sXG4pOiBTeW5jVGhyZWFkW10ge1xuICBjb25zdCB0aHJlYWREZXNjcmlwdG9yczogYW55W10gfCBudWxsID0gcGFyc2VkUmVzcG9uc2UgJiYgcGFyc2VkUmVzcG9uc2VbMl07XG5cbiAgaWYgKCF0aHJlYWREZXNjcmlwdG9ycykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiB0aHJlYWREZXNjcmlwdG9yc1xuICAgIC5tYXAoKGRlc2NyaXB0b3JXcmFwcGVyLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JXcmFwcGVyWzBdO1xuICAgICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm4gbnVsbDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ViamVjdDogZGVzY3JpcHRvclswXSxcbiAgICAgICAgc25pcHBldDogZGVzY3JpcHRvclsxXSxcbiAgICAgICAgc3luY1RocmVhZElEOiBkZXNjcmlwdG9yWzNdLFxuICAgICAgICAvLyBJdCBzZWVtcyBHbWFpbCBpcyBBL0IgdGVzdGluZyBpbmNsdWRpbmcgZ21haWxUaHJlYWRJRCBpbiBkZXNjcmlwdG9yWzIwXSBhbmQgbm90IGluY2x1ZGluZ1xuICAgICAgICAvLyB0aGUgZW5jb2RlZCB2ZXJzaW9uIG9mIGl0IGluIGRlc2NyaXB0b3JbMThdLCBzbyBwdWxsIGl0IGZyb20gWzIwXSBpZiBbMThdIGlzIG5vdCBzZXQuXG4gICAgICAgIG9sZEdtYWlsVGhyZWFkSUQ6XG4gICAgICAgICAgZGVzY3JpcHRvclsxN10gIT0gbnVsbFxuICAgICAgICAgICAgPyBuZXcgQmlnTnVtYmVyKGRlc2NyaXB0b3JbMTddKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIDogZGVzY3JpcHRvclsxOV0sXG4gICAgICAgIHJhd1Jlc3BvbnNlOiBkZXNjcmlwdG9yV3JhcHBlcixcbiAgICAgICAgZXh0cmFNZXRhRGF0YToge1xuICAgICAgICAgIHNuaXBwZXQ6XG4gICAgICAgICAgICAocGFyc2VkUmVzcG9uc2VbMTRdICYmXG4gICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlWzE0XVswXSAmJlxuICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZVsxNF1bMF1baW5kZXhdKSB8fFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgc3luY01lc3NhZ2VEYXRhOiBkZXNjcmlwdG9yWzRdLm1hcCgobWQ6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlSUQ6IG1kWzBdLFxuICAgICAgICAgICAgb2xkTWVzc2FnZUlEOiBtZFs1NV0sXG4gICAgICAgICAgICBkYXRlOiArbWRbNl0sXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KVxuICAgIC5maWx0ZXIoaXNOb3ROaWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRocmVhZHNGcm9tVGhyZWFkUmVzcG9uc2UoXG4gIHJlc3BvbnNlOiBzdHJpbmcsXG4pOiBBcnJheTxTeW5jVGhyZWFkIHwgTWluaW1hbFN5bmNUaHJlYWQ+IHtcbiAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRSZXNwb25zZSkpIHtcbiAgICByZXR1cm4gZXh0cmFjdFRocmVhZHNGcm9tVGhyZWFkUmVzcG9uc2VfMjAyMjA5MDkocGFyc2VkUmVzcG9uc2UpO1xuICB9XG5cbiAgY29uc3QgdGhyZWFkRGVzY3JpcHRvcnM6IGFueVtdIHwgbnVsbCA9IHBhcnNlZFJlc3BvbnNlICYmIHBhcnNlZFJlc3BvbnNlWzJdO1xuXG4gIGlmICghdGhyZWFkRGVzY3JpcHRvcnMpIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgdGhyZWFkIHJlc3BvbnNlJyk7XG5cbiAgcmV0dXJuIHRocmVhZERlc2NyaXB0b3JzXG4gICAgLm1hcCgoZGVzY3JpcHRvcldyYXBwZXIpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGRlc2NyaXB0b3JXcmFwcGVyWzFdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGRlc2NyaXB0b3JXcmFwcGVyWzNdKSAmJlxuICAgICAgICAhKFxuICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzJdICYmXG4gICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl1bMV0gJiZcbiAgICAgICAgICBkZXNjcmlwdG9yV3JhcHBlclsyXVsxXVsxNF0gJiZcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGRlc2NyaXB0b3JXcmFwcGVyWzJdWzJdKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzeW5jVGhyZWFkSUQ6IGRlc2NyaXB0b3JXcmFwcGVyWzFdLFxuICAgICAgICAgIG9sZEdtYWlsVGhyZWFkSUQ6XG4gICAgICAgICAgICAoZGVzY3JpcHRvcldyYXBwZXJbMl0gJiZcbiAgICAgICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl1bMV0gJiZcbiAgICAgICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl1bMV1bMTZdKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGV4dHJhTWV0YURhdGE6IHtcbiAgICAgICAgICAgIHNuaXBwZXQ6XG4gICAgICAgICAgICAgIChkZXNjcmlwdG9yV3JhcHBlclsyXSAmJlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzJdWzFdICYmXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl1bMV1bM10pIHx8XG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlRGF0YTogKGRlc2NyaXB0b3JXcmFwcGVyWzNdIHx8IFtdKVxuICAgICAgICAgICAgICAuZmlsdGVyKChtZCkgPT4gQm9vbGVhbihtZFsyXSkpXG4gICAgICAgICAgICAgIC5tYXAoKG1kKSA9PiAoe1xuICAgICAgICAgICAgICAgIHN5bmNNZXNzYWdlSUQ6IG1kWzFdLFxuICAgICAgICAgICAgICAgIGRhdGU6ICttZFsyXVsxN10sXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50czogZ2V0UmVjaXBpZW50c0Zyb21NZXNzYWdlRGVzY3JpcHRvcihtZCksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIE1pbmltYWxTeW5jVGhyZWFkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGhyZWFkRGVzY3JpcHRvciA9XG4gICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl0gJiYgZGVzY3JpcHRvcldyYXBwZXJbMl1bMV07XG5cbiAgICAgICAgaWYgKCF0aHJlYWREZXNjcmlwdG9yKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgc3luY01lc3NhZ2VEYXRhO1xuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZURlc2NyaXB0b3JzID1cbiAgICAgICAgICBBcnJheS5pc0FycmF5KGRlc2NyaXB0b3JXcmFwcGVyWzNdKSAmJiBkZXNjcmlwdG9yV3JhcHBlclszXTtcblxuICAgICAgICBpZiAoZnVsbE1lc3NhZ2VEZXNjcmlwdG9ycykge1xuICAgICAgICAgIHN5bmNNZXNzYWdlRGF0YSA9IGZ1bGxNZXNzYWdlRGVzY3JpcHRvcnMubWFwKChtZCkgPT4gKHtcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlSUQ6IG1kWzFdLFxuICAgICAgICAgICAgZGF0ZTogK21kWzJdWzE3XSxcbiAgICAgICAgICAgIHJlY2lwaWVudHM6IGdldFJlY2lwaWVudHNGcm9tTWVzc2FnZURlc2NyaXB0b3IobWQpLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlRGVzY3JpcHRvcnMgPVxuICAgICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMl0gJiYgZGVzY3JpcHRvcldyYXBwZXJbMl1bMl07XG5cbiAgICAgICAgICBzeW5jTWVzc2FnZURhdGEgPSBtZXNzYWdlRGVzY3JpcHRvcnMubWFwKChtZDogYW55KSA9PiAoe1xuICAgICAgICAgICAgc3luY01lc3NhZ2VJZDogbWRbMV0sXG4gICAgICAgICAgICBkYXRlOiArbWRbMTZdLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3ViamVjdDogdGhyZWFkRGVzY3JpcHRvclsyXSxcbiAgICAgICAgICBzbmlwcGV0OiB0aHJlYWREZXNjcmlwdG9yWzNdLFxuICAgICAgICAgIHN5bmNUaHJlYWRJRDogdGhyZWFkRGVzY3JpcHRvclsxXSxcbiAgICAgICAgICBvbGRHbWFpbFRocmVhZElEOiBuZXcgQmlnTnVtYmVyKHRocmVhZERlc2NyaXB0b3JbMTRdKS50b1N0cmluZygxNiksXG4gICAgICAgICAgcmF3UmVzcG9uc2U6IGRlc2NyaXB0b3JXcmFwcGVyLFxuICAgICAgICAgIGV4dHJhTWV0YURhdGE6IHtcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlRGF0YSxcbiAgICAgICAgICAgIHNuaXBwZXQ6ICcnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgU3luY1RocmVhZDtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoaXNOb3ROaWwpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VGhyZWFkc0Zyb21UaHJlYWRSZXNwb25zZV8yMDIyMDkwOShcbiAgcGFyc2VkUmVzcG9uc2U6IGFueVtdLFxuKTogQXJyYXk8U3luY1RocmVhZCB8IE1pbmltYWxTeW5jVGhyZWFkPiB7XG4gIGNvbnN0IHRocmVhZERlc2NyaXB0b3JzOiBhbnlbXSB8IG51bGwgPSBwYXJzZWRSZXNwb25zZSAmJiBwYXJzZWRSZXNwb25zZVsxXTtcblxuICBpZiAoIXRocmVhZERlc2NyaXB0b3JzKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHRocmVhZCByZXNwb25zZScpO1xuXG4gIHJldHVybiB0aHJlYWREZXNjcmlwdG9yc1xuICAgIC5tYXAoKGRlc2NyaXB0b3JXcmFwcGVyKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBkZXNjcmlwdG9yV3JhcHBlclswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkZXNjcmlwdG9yV3JhcHBlclsyXSkgJiZcbiAgICAgICAgIShcbiAgICAgICAgICBkZXNjcmlwdG9yV3JhcHBlclsxXSAmJlxuICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzBdICYmXG4gICAgICAgICAgZGVzY3JpcHRvcldyYXBwZXJbMV1bMF1bMTNdICYmXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShkZXNjcmlwdG9yV3JhcHBlclsxXVsxXSlcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3luY1RocmVhZElEOiBkZXNjcmlwdG9yV3JhcHBlclswXSxcbiAgICAgICAgICBvbGRHbWFpbFRocmVhZElEOlxuICAgICAgICAgICAgKGRlc2NyaXB0b3JXcmFwcGVyWzFdICYmXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzBdICYmXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzBdWzE1XSkgfHxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBleHRyYU1ldGFEYXRhOiB7XG4gICAgICAgICAgICBzbmlwcGV0OlxuICAgICAgICAgICAgICAoZGVzY3JpcHRvcldyYXBwZXJbMV0gJiZcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yV3JhcHBlclsxXVswXSAmJlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzBdWzJdKSB8fFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBzeW5jTWVzc2FnZURhdGE6IChkZXNjcmlwdG9yV3JhcHBlclsyXSB8fCBbXSlcbiAgICAgICAgICAgICAgLmZpbHRlcigobWQpID0+IEJvb2xlYW4obWRbMV0pKVxuICAgICAgICAgICAgICAubWFwKChtZCkgPT4gKHtcbiAgICAgICAgICAgICAgICBzeW5jTWVzc2FnZUlEOiBtZFswXSxcbiAgICAgICAgICAgICAgICBkYXRlOiArbWRbMV1bMTZdLFxuICAgICAgICAgICAgICAgIHJlY2lwaWVudHM6IGdldFJlY2lwaWVudHNGcm9tTWVzc2FnZURlc2NyaXB0b3JfMjAyMjA5MDkobWQpLFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSBhcyBNaW5pbWFsU3luY1RocmVhZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRocmVhZERlc2NyaXB0b3IgPVxuICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdICYmIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzBdO1xuXG4gICAgICAgIGlmICghdGhyZWFkRGVzY3JpcHRvcikgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IHN5bmNNZXNzYWdlRGF0YTtcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2VEZXNjcmlwdG9ycyA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShkZXNjcmlwdG9yV3JhcHBlclsyXSkgJiYgZGVzY3JpcHRvcldyYXBwZXJbMl07XG5cbiAgICAgICAgaWYgKGZ1bGxNZXNzYWdlRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICBzeW5jTWVzc2FnZURhdGEgPSBmdWxsTWVzc2FnZURlc2NyaXB0b3JzLm1hcCgobWQpID0+ICh7XG4gICAgICAgICAgICBzeW5jTWVzc2FnZUlEOiBtZFswXSxcbiAgICAgICAgICAgIGRhdGU6ICttZFsxXVsxNl0sXG4gICAgICAgICAgICByZWNpcGllbnRzOiBnZXRSZWNpcGllbnRzRnJvbU1lc3NhZ2VEZXNjcmlwdG9yXzIwMjIwOTA5KG1kKSxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3JzID1cbiAgICAgICAgICAgIGRlc2NyaXB0b3JXcmFwcGVyWzFdICYmIGRlc2NyaXB0b3JXcmFwcGVyWzFdWzFdO1xuXG4gICAgICAgICAgc3luY01lc3NhZ2VEYXRhID0gbWVzc2FnZURlc2NyaXB0b3JzLm1hcCgobWQ6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlSWQ6IG1kWzBdLFxuICAgICAgICAgICAgZGF0ZTogK21kWzE1XSxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1YmplY3Q6IHRocmVhZERlc2NyaXB0b3JbMV0sXG4gICAgICAgICAgc25pcHBldDogdGhyZWFkRGVzY3JpcHRvclsyXSxcbiAgICAgICAgICBzeW5jVGhyZWFkSUQ6IHRocmVhZERlc2NyaXB0b3JbMF0sXG4gICAgICAgICAgb2xkR21haWxUaHJlYWRJRDogbmV3IEJpZ051bWJlcih0aHJlYWREZXNjcmlwdG9yWzEzXSkudG9TdHJpbmcoMTYpLFxuICAgICAgICAgIHJhd1Jlc3BvbnNlOiBkZXNjcmlwdG9yV3JhcHBlcixcbiAgICAgICAgICBleHRyYU1ldGFEYXRhOiB7XG4gICAgICAgICAgICBzeW5jTWVzc2FnZURhdGEsXG4gICAgICAgICAgICBzbmlwcGV0OiAnJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIFN5bmNUaHJlYWQ7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKGlzTm90TmlsKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjaXBpZW50c0Zyb21NZXNzYWdlRGVzY3JpcHRvcihcbiAgbWVzc2FnZURlc2NyaXB0b3I6IEFycmF5PGFueT4sXG4pOiBSZWNpcGllbnRbXSB8IHZvaWQge1xuICBpZiAoIW1lc3NhZ2VEZXNjcmlwdG9yWzJdKSByZXR1cm47XG5cbiAgY29uc3QgdG8gPSBtZXNzYWdlRGVzY3JpcHRvclsyXVsxXSB8fCBbXTtcbiAgY29uc3QgY2MgPSBtZXNzYWdlRGVzY3JpcHRvclsyXVsyXSB8fCBbXTtcbiAgY29uc3QgYmNjID0gbWVzc2FnZURlc2NyaXB0b3JbMl1bM10gfHwgW107XG5cbiAgcmV0dXJuIHRvXG4gICAgLmNvbmNhdChjYylcbiAgICAuY29uY2F0KGJjYylcbiAgICAubWFwKChyZWNpcGllbnREZXNjcmlwdG9yOiBhbnkpID0+ICh7XG4gICAgICBlbWFpbEFkZHJlc3M6IHJlY2lwaWVudERlc2NyaXB0b3JbMl0sXG4gICAgICBuYW1lOiByZWNpcGllbnREZXNjcmlwdG9yWzNdLFxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjaXBpZW50c0Zyb21NZXNzYWdlRGVzY3JpcHRvcl8yMDIyMDkwOShcbiAgbWVzc2FnZURlc2NyaXB0b3I6IEFycmF5PGFueT4sXG4pOiBSZWNpcGllbnRbXSB8IHZvaWQge1xuICBpZiAoIW1lc3NhZ2VEZXNjcmlwdG9yWzFdKSByZXR1cm47XG5cbiAgY29uc3QgdG8gPSBtZXNzYWdlRGVzY3JpcHRvclsxXVswXSB8fCBbXTtcbiAgY29uc3QgY2MgPSBtZXNzYWdlRGVzY3JpcHRvclsxXVsxXSB8fCBbXTtcbiAgY29uc3QgYmNjID0gbWVzc2FnZURlc2NyaXB0b3JbMV1bMl0gfHwgW107XG5cbiAgcmV0dXJuIHRvXG4gICAgLmNvbmNhdChjYylcbiAgICAuY29uY2F0KGJjYylcbiAgICAubWFwKChyZWNpcGllbnREZXNjcmlwdG9yOiBhbnkpID0+ICh7XG4gICAgICBlbWFpbEFkZHJlc3M6IHJlY2lwaWVudERlc2NyaXB0b3JbMV0sXG4gICAgICBuYW1lOiByZWNpcGllbnREZXNjcmlwdG9yWzJdLFxuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VUaHJlYWRzSW5TZWFyY2hSZXNwb25zZShcbiAgcmVzcG9uc2U6IHN0cmluZyxcbiAgcmVwbGFjZW1lbnRUaHJlYWRzOiBTeW5jVGhyZWFkW10sXG4gIF91bnVzZWQ6IHsgc3RhcnQ6IG51bWJlcjsgdG90YWw/OiBudW1iZXIgfCAnTUFOWScgfSwgLy8gVE9ETyB3aHkgaXMgdGhpcyB1bnVzZWQ/XG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVRocmVhZHNJblNlYXJjaFJlc3BvbnNlXzIwMjIwOTA5KFxuICAgICAgICBwYXJzZWRSZXNwb25zZSxcbiAgICAgICAgcmVwbGFjZW1lbnRUaHJlYWRzLFxuICAgICAgICBfdW51c2VkLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnIgaW4gcmVwbGFjZVRocmVhZHNJblNlYXJjaFJlc3BvbnNlJywgZXJyKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkUmVzcG9uc2VbM10gfHwgcmVwbGFjZW1lbnRUaHJlYWRzLmxlbmd0aCkge1xuICAgIHBhcnNlZFJlc3BvbnNlWzNdID0gcmVwbGFjZW1lbnRUaHJlYWRzLm1hcCgoeyByYXdSZXNwb25zZSB9LCBpbmRleCkgPT4gKHtcbiAgICAgIC4uLnJhd1Jlc3BvbnNlLFxuICAgICAgJzInOiBpbmRleCxcbiAgICB9KSk7XG4gIH1cblxuICBpZiAocGFyc2VkUmVzcG9uc2VbMTVdIHx8IHJlcGxhY2VtZW50VGhyZWFkcy5sZW5ndGgpIHtcbiAgICBwYXJzZWRSZXNwb25zZVsxNV0gPSB7XG4gICAgICAuLi5wYXJzZWRSZXNwb25zZVsxNV0sXG4gICAgICAnMSc6IHJlcGxhY2VtZW50VGhyZWFkcy5tYXAoKHsgZXh0cmFNZXRhRGF0YSB9KSA9PiBleHRyYU1ldGFEYXRhLnNuaXBwZXQpLFxuICAgICAgJzInOiByZXBsYWNlbWVudFRocmVhZHMubWFwKCh7IGV4dHJhTWV0YURhdGEgfSkgPT5cbiAgICAgICAgZXh0cmFNZXRhRGF0YS5zeW5jTWVzc2FnZURhdGEubWFwKCh7IHN5bmNNZXNzYWdlSUQgfSkgPT4gc3luY01lc3NhZ2VJRCksXG4gICAgICApLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUmVzcG9uc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVRocmVhZHNJblNlYXJjaFJlc3BvbnNlXzIwMjIwOTA5KFxuICBwYXJzZWRSZXNwb25zZTogYW55W10sXG4gIHJlcGxhY2VtZW50VGhyZWFkczogU3luY1RocmVhZFtdLFxuICBfdW51c2VkOiB7IHN0YXJ0OiBudW1iZXI7IHRvdGFsPzogbnVtYmVyIHwgJ01BTlknIH0sIC8vIFRPRE8gd2h5IGlzIHRoaXMgdW51c2VkP1xuKTogc3RyaW5nIHtcbiAgaWYgKHBhcnNlZFJlc3BvbnNlWzJdIHx8IHJlcGxhY2VtZW50VGhyZWFkcy5sZW5ndGgpIHtcbiAgICBwYXJzZWRSZXNwb25zZVsyXSA9IHJlcGxhY2VtZW50VGhyZWFkcy5tYXAoKHsgcmF3UmVzcG9uc2UgfSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IFsuLi5yYXdSZXNwb25zZV07XG4gICAgICByZXNbMV0gPSBpbmRleDtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGFyc2VkUmVzcG9uc2VbMTRdIHx8IHJlcGxhY2VtZW50VGhyZWFkcy5sZW5ndGgpIHtcbiAgICBwYXJzZWRSZXNwb25zZVsxNF0gPSBbLi4ucGFyc2VkUmVzcG9uc2VbMTRdXTtcbiAgICBwYXJzZWRSZXNwb25zZVsxNF1bMF0gPSByZXBsYWNlbWVudFRocmVhZHMubWFwKFxuICAgICAgKHsgZXh0cmFNZXRhRGF0YSB9KSA9PiBleHRyYU1ldGFEYXRhLnNuaXBwZXQsXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkUmVzcG9uc2VbMTRdWzFdKSAmJlxuICAgICAgcGFyc2VkUmVzcG9uc2VbMTRdWzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkUmVzcG9uc2VbMTRdWzFdWzBdWzBdKVxuICAgICkge1xuICAgICAgLy8gMjAyMy0wNC0xOSBnbWFpbCBjaGFuZ2VcbiAgICAgIHBhcnNlZFJlc3BvbnNlWzE0XVsxXSA9IHJlcGxhY2VtZW50VGhyZWFkcy5tYXAoKHsgZXh0cmFNZXRhRGF0YSB9KSA9PiBbXG4gICAgICAgIFtleHRyYU1ldGFEYXRhLnN5bmNNZXNzYWdlRGF0YVswXS5zeW5jTWVzc2FnZUlEXSxcbiAgICAgIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRSZXNwb25zZVsxNF1bMV0gPSByZXBsYWNlbWVudFRocmVhZHMubWFwKCh7IGV4dHJhTWV0YURhdGEgfSkgPT5cbiAgICAgICAgZXh0cmFNZXRhRGF0YS5zeW5jTWVzc2FnZURhdGEubWFwKCh7IHN5bmNNZXNzYWdlSUQgfSkgPT4gc3luY01lc3NhZ2VJRCksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWRSZXNwb25zZSk7XG59XG4iLCJpbXBvcnQgZ21haWxBamF4IGZyb20gJy4uLy4uLy4uL2RyaXZlci1jb21tb24vZ21haWxBamF4JztcbmltcG9ydCB7IGV4dHJhY3RUaHJlYWRzRnJvbVRocmVhZFJlc3BvbnNlIH0gZnJvbSAnLi4vZ21haWwtc3luYy1yZXNwb25zZS1wcm9jZXNzb3InO1xuaW1wb3J0IGdldEFjY291bnRVcmxQYXJ0IGZyb20gJy4uLy4uLy4uL2RyaXZlci1jb21tb24vZ2V0QWNjb3VudFVybFBhcnQnO1xuaW1wb3J0IHR5cGUgR21haWxEcml2ZXIgZnJvbSAnLi4vZ21haWwtZHJpdmVyJztcbmltcG9ydCB0eXBlIHsgU3luY1RocmVhZCB9IGZyb20gJy4uL2dtYWlsLXN5bmMtcmVzcG9uc2UtcHJvY2Vzc29yJztcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZEZyb21TeW5jVGhyZWFkSWQoXG4gIGRyaXZlcjogR21haWxEcml2ZXIsXG4gIHN5bmNUaHJlYWRJZDogc3RyaW5nLFxuKTogUHJvbWlzZTxTeW5jVGhyZWFkIHwgbnVsbCB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBbYnRhaUhlYWRlciwgeHNyZlRva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBkcml2ZXIuZ2V0UGFnZUNvbW11bmljYXRvcigpLmdldEJ0YWlIZWFkZXIoKSxcbiAgICBkcml2ZXIuZ2V0UGFnZUNvbW11bmljYXRvcigpLmdldFhzcmZUb2tlbigpLFxuICBdKTtcbiAgcmV0dXJuIGdldFRocmVhZEZyb21TeW5jVGhyZWFkSWRVc2luZ0hlYWRlcnMoXG4gICAgc3luY1RocmVhZElkLFxuICAgIGJ0YWlIZWFkZXIsXG4gICAgeHNyZlRva2VuLFxuICApO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZEZyb21TeW5jVGhyZWFkSWRVc2luZ0hlYWRlcnMoXG4gIHN5bmNUaHJlYWRJZDogc3RyaW5nLFxuICBidGFpSGVhZGVyOiBzdHJpbmcsXG4gIHhzcmZUb2tlbjogc3RyaW5nLFxuKTogUHJvbWlzZTxTeW5jVGhyZWFkIHwgbnVsbCB8IHVuZGVmaW5lZD4ge1xuICBsZXQgcmVzcG9uc2VUZXh0ID0gbnVsbDtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgZ21haWxBamF4KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiBgaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vc3luYyR7Z2V0QWNjb3VudFVybFBhcnQoKX0vaS9mZGAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdYLUZyYW1ld29yay1Yc3JmLVRva2VuJzogeHNyZlRva2VuLFxuICAgICAgICAnWC1HbWFpbC1CVEFJJzogYnRhaUhlYWRlcixcbiAgICAgICAgJ1gtR29vZ2xlLUJURCc6ICcxJyxcbiAgICAgIH0sXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICcxJzogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgICcxJzogc3luY1RocmVhZElkLFxuICAgICAgICAgICAgJzInOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICB9KTtcbiAgICByZXNwb25zZVRleHQgPSB0ZXh0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyB0cnkgc2VuZGluZyByZXF1ZXN0IHdpdGggbmV3IGZvcm1hdCAyMDIyXzA5XzA5XG4gICAgY29uc3QgeyB0ZXh0IH0gPSBhd2FpdCBnbWFpbEFqYXgoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6IGBodHRwczovL21haWwuZ29vZ2xlLmNvbS9zeW5jJHtnZXRBY2NvdW50VXJsUGFydCgpfS9pL2ZkP3J0PXImcHQ9amlgLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnWC1GcmFtZXdvcmstWHNyZi1Ub2tlbic6IHhzcmZUb2tlbixcbiAgICAgICAgJ1gtR21haWwtQlRBSSc6IGJ0YWlIZWFkZXIsXG4gICAgICAgICdYLUdvb2dsZS1CVEQnOiAnMScsXG4gICAgICB9LFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoW1tbc3luY1RocmVhZElkLCAxXV0sIDJdKSxcbiAgICB9KTtcbiAgICByZXNwb25zZVRleHQgPSB0ZXh0O1xuICB9XG5cbiAgY29uc3QgdGhyZWFkRGVzY3JpcHRvcnMgPSBleHRyYWN0VGhyZWFkc0Zyb21UaHJlYWRSZXNwb25zZShyZXNwb25zZVRleHQpO1xuXG4gIGlmICh0aHJlYWREZXNjcmlwdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdGhyZWFkID0gdGhyZWFkRGVzY3JpcHRvcnNbMF0gYXMgYW55O1xuXG4gICAgaWYgKHRocmVhZC5vbGRHbWFpbFRocmVhZElEKSB7XG4gICAgICByZXR1cm4gdGhyZWFkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHN0YXJ0c1dpdGggZnJvbSAnbG9kYXNoL3N0YXJ0c1dpdGgnO1xuaW1wb3J0IHR5cGUgeyBNZXNzYWdlIH0gZnJvbSAnLi4vcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1yZXNwb25zZS1wcm9jZXNzb3InO1xuaW1wb3J0IHsgZXh0cmFjdE1lc3NhZ2VzIH0gZnJvbSAnLi4vcGxhdGZvcm0taW1wbGVtZW50YXRpb24tanMvZG9tLWRyaXZlci9nbWFpbC9nbWFpbC1yZXNwb25zZS1wcm9jZXNzb3InO1xuaW1wb3J0IHsgZ2V0VGhyZWFkRnJvbVN5bmNUaHJlYWRJZFVzaW5nSGVhZGVycyB9IGZyb20gJy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RvbS1kcml2ZXIvZ21haWwvZ21haWwtZHJpdmVyL2dldFN5bmNUaHJlYWRGcm9tU3luY1RocmVhZElkJztcbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICcuL2luamVjdGVkLWxvZ2dlcic7XG5pbXBvcnQgcmVxdWVzdEdtYWlsVGhyZWFkIGZyb20gJy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RyaXZlci1jb21tb24vcmVxdWVzdEdtYWlsVGhyZWFkJztcbmNvbnN0IHRocmVhZElkVG9NZXNzYWdlczogTWFwPHN0cmluZywgTWVzc2FnZVtdPiA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAnaW5ib3hTREt0ZWxsTWVUaGlzTWVzc2FnZURhdGUnLFxuICAgIGZ1bmN0aW9uIChldmVudDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgZXhwb3NlTWV0YWRhdGEoZXZlbnQsICdkYXRhLWluYm94c2RrLXNvcnRkYXRlJywgKG06IGFueSkgPT4gbS5kYXRlKTtcbiAgICB9LFxuICApO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICdpbmJveFNES3RlbGxNZVRoaXNNZXNzYWdlUmVjaXBpZW50cycsXG4gICAgZnVuY3Rpb24gKGV2ZW50OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICBleHBvc2VNZXRhZGF0YShldmVudCwgJ2RhdGEtaW5ib3hzZGstcmVjaXBpZW50cycsIChtOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKG0ucmVjaXBpZW50cykgcmV0dXJuIG0ucmVjaXBpZW50cztcbiAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIGV4cG9zZU1ldGFkYXRhKGV2ZW50OiBhbnksIGF0dHJpYnV0ZTogc3RyaW5nLCBwcm9jZXNzb3I6IGFueSkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0LFxuICAgIGRldGFpbDogeyB0aHJlYWRJZCwgaWtWYWx1ZSwgYnRhaUhlYWRlciwgeHNyZlRva2VuIH0sXG4gIH0gPSBldmVudDtcbiAgKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBBcnJheS5mcm9tKHRhcmdldC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcihcbiAgICAgICAgKGVsKSA9PlxuICAgICAgICAgICEoZWwgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucyhcbiAgICAgICAgICAgICdpbmJveHNka19fY3VzdG9tX21lc3NhZ2VfdmlldycsXG4gICAgICAgICAgKSxcbiAgICAgIClcbiAgICAgIC5pbmRleE9mKHRhcmdldCk7XG5cbiAgICBpZiAobWVzc2FnZUluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGhhcHBlbicpO1xuICAgIH1cblxuICAgIGxldCBtZXNzYWdlID0gZ2V0TWVzc2FnZSh0aHJlYWRJZCwgbWVzc2FnZUluZGV4KTtcblxuICAgIGlmIChtZXNzYWdlID09IG51bGwgfHwgIW1lc3NhZ2UucmVjaXBpZW50cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYWRkRGF0YUZvclRocmVhZCh0aHJlYWRJZCwgaWtWYWx1ZSwgYnRhaUhlYWRlciwgeHNyZlRva2VuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbWVzc2FnZSA9IGdldE1lc3NhZ2UodGhyZWFkSWQsIG1lc3NhZ2VJbmRleCk7XG5cbiAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gZmluZCBtZXNzYWdlIGRhdGUgYWZ0ZXIgcmUtcmVxdWVzdGluZyB0aHJlYWQnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBKU09OLnN0cmluZ2lmeShwcm9jZXNzb3IobWVzc2FnZSkpKTtcbiAgfSkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsICdlcnJvcicpO1xuICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShcbiAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgbWVzc2FnZUluZGV4OiBudW1iZXIsXG4pOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gdGhyZWFkSWRUb01lc3NhZ2VzLmdldCh0aHJlYWRJZCk7XG5cbiAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VJbmRleF07XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQoXG4gIGdyb3VwZWRNZXNzYWdlczogQXJyYXk8e1xuICAgIHRocmVhZElEOiBzdHJpbmc7XG4gICAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgfT4sXG4pIHtcbiAgZ3JvdXBlZE1lc3NhZ2VzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgdGhyZWFkSWRUb01lc3NhZ2VzLnNldChncm91cC50aHJlYWRJRCwgZ3JvdXAubWVzc2FnZXMpO1xuICB9KTtcbn1cbmNvbnN0IGFjdGl2ZVRocmVhZFJlcXVlc3RQcm9taXNlczogTWFwPHN0cmluZywgUHJvbWlzZTx2b2lkPj4gPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGFkZERhdGFGb3JUaHJlYWQoXG4gIHRocmVhZElkOiBzdHJpbmcsXG4gIGlrVmFsdWU6IHN0cmluZyxcbiAgYnRhaUhlYWRlcjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgeHNyZlRva2VuOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGV4aXN0aW5nUmVxdWVzdFByb21pc2UgPSBhY3RpdmVUaHJlYWRSZXF1ZXN0UHJvbWlzZXMuZ2V0KHRocmVhZElkKTtcblxuICBpZiAoZXhpc3RpbmdSZXF1ZXN0UHJvbWlzZSkge1xuICAgIHJldHVybiBleGlzdGluZ1JlcXVlc3RQcm9taXNlO1xuICB9XG5cbiAgY29uc3QgbmV3UHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdGFydHNXaXRoKHRocmVhZElkLCAndGhyZWFkJykpIHtcbiAgICAgICAgLy8gbmV3IGRhdGEgbGF5ZXJcbiAgICAgICAgaWYgKCFidGFpSGVhZGVyIHx8ICF4c3JmVG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnTmVlZCBidGFpSGVhZGVyIGFuZCB4c3JmVG9rZW4gd2hlbiBpbiBuZXcgZGF0YSBsYXllcicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN5bmNUaHJlYWQgPSBhd2FpdCBnZXRUaHJlYWRGcm9tU3luY1RocmVhZElkVXNpbmdIZWFkZXJzKFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIGJ0YWlIZWFkZXIsXG4gICAgICAgICAgeHNyZlRva2VuLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzeW5jVGhyZWFkKSB7XG4gICAgICAgICAgYWRkKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyZWFkSUQ6IHN5bmNUaHJlYWQuc3luY1RocmVhZElELFxuICAgICAgICAgICAgICBtZXNzYWdlczogc3luY1RocmVhZC5leHRyYU1ldGFEYXRhLnN5bmNNZXNzYWdlRGF0YS5tYXAoXG4gICAgICAgICAgICAgICAgKHN5bmNNZXNzYWdlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgZGF0ZTogc3luY01lc3NhZ2UuZGF0ZSxcbiAgICAgICAgICAgICAgICAgIHJlY2lwaWVudHM6IHN5bmNNZXNzYWdlLnJlY2lwaWVudHMgYXMgYW55LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGVnYWN5IGdtYWlsXG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXF1ZXN0R21haWxUaHJlYWQoaWtWYWx1ZSwgdGhyZWFkSWQpO1xuICAgICAgICBhZGQoZXh0cmFjdE1lc3NhZ2VzKHRleHQpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVUaHJlYWRSZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHRocmVhZElkKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgYWN0aXZlVGhyZWFkUmVxdWVzdFByb21pc2VzLnNldCh0aHJlYWRJZCwgbmV3UHJvbWlzZSk7XG4gIHJldHVybiBuZXdQcm9taXNlO1xufVxuIiwiLy8gU3BsaXRzIGEgc3RyaW5nIG9uIHNwYWNlcywgYnV0IGlnbm9yZXMgc3BhY2VzIGluc2lkZSBxdW90ZXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1b3RlZFNwbGl0KHM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgbGV0IHNwbGl0OiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgbGFzdEVuZCA9IDA7XG4gIGNvbnN0IHF1b3RlUmUgPSAvXCJbXlwiXSpcIi9nO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBxdW90ZVJlLmV4ZWMocyk7XG4gICAgc3BsaXQgPSBzcGxpdC5jb25jYXQoXG4gICAgICAobWF0Y2ggPyBzLnN1YnN0cmluZyhsYXN0RW5kLCBtYXRjaC5pbmRleCkgOiBzLnN1YnN0cmluZyhsYXN0RW5kKSlcbiAgICAgICAgLnNwbGl0KC8gKy8pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbiksXG4gICAgKTtcbiAgICBpZiAoIW1hdGNoKSBicmVhaztcbiAgICBsYXN0RW5kID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgc3BsaXQucHVzaChtYXRjaFswXSk7XG4gIH1cbiAgcmV0dXJuIHNwbGl0O1xufVxuIiwiLy8gVGhpcyBpcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIFJTVlAuZGVmZXIoKS4gTmV3IGNvZGUgc2hvdWxkIGF2b2lkIHVzaW5nXG4vLyB0aGlzLCBhbmQgc2hvdWxkIHVzZSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmVyPFQ+IHtcbiAgcmVhZG9ubHkgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICByZWFkb25seSByZWplY3Q6IChlcnI6IGFueSkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmZXI8VD4oKTogRGVmZXI8VD4ge1xuICBsZXQgcmVzb2x2ZTogYW55ID0gdW5kZWZpbmVkO1xuICBsZXQgcmVqZWN0OiBhbnkgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IHByb21pc2U6IFByb21pc2U8YW55PiA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICByZWplY3QgPSBfcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIHsgcmVzb2x2ZSwgcmVqZWN0LCBwcm9taXNlIH07XG59XG4iLCJpbXBvcnQgeyBDb250YWN0IH0gZnJvbSAnLi4vLi4vaW5ib3hzZGsnO1xuXG5leHBvcnQgdHlwZSBDb21wb3NlUmVxdWVzdFR5cGUgPSAnRklSU1RfRFJBRlRfU0FWRScgfCAnRFJBRlRfU0FWRScgfCAnU0VORCc7XG5cbmV4cG9ydCB0eXBlIENvbXBvc2VSZXF1ZXN0ID0ge1xuICBkcmFmdElEOiBzdHJpbmc7XG4gIHRvOiBDb250YWN0W10gfCBudWxsO1xuICBjYzogQ29udGFjdFtdIHwgbnVsbDtcbiAgYmNjOiBDb250YWN0W10gfCBudWxsO1xuICBib2R5OiBzdHJpbmc7XG4gIHN1YmplY3Q6IHN0cmluZztcbiAgdHlwZTogQ29tcG9zZVJlcXVlc3RUeXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IFNFTkRfQUNUSU9OUyA9IFsnXnBmZyddO1xuZXhwb3J0IGNvbnN0IERSQUZUX1NBVklOR19BQ1RJT05TID0gWydecicsICdecl9idCddO1xuIiwiaW1wb3J0IHNvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JztcbmltcG9ydCBpbnRlcnNlY3Rpb24gZnJvbSAnbG9kYXNoL2ludGVyc2VjdGlvbic7XG5cbmltcG9ydCBpc05vdE5pbCBmcm9tICcuLi8uLi9wbGF0Zm9ybS1pbXBsZW1lbnRhdGlvbi1qcy9saWIvaXNOb3ROaWwnO1xuaW1wb3J0IHtcbiAgQ29tcG9zZVJlcXVlc3RUeXBlLFxuICBEUkFGVF9TQVZJTkdfQUNUSU9OUyxcbiAgU0VORF9BQ1RJT05TLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb250YWN0IH0gZnJvbSAnLi4vLi4vaW5ib3hzZGsnO1xuXG5jb25zdCBBQ1RJT05fVFlQRV9QUklPUklUWV9SQU5LOiBbQ29tcG9zZVJlcXVlc3RUeXBlLCBDb21wb3NlUmVxdWVzdFR5cGVdID0gW1xuICAnU0VORCcsXG4gICdEUkFGVF9TQVZFJyxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbXBvc2VSZXF1ZXN0Qm9keV8yMDIyXzA5XzA5KHJlcXVlc3Q6IEFycmF5PGFueT4pIHtcbiAgcmV0dXJuIHBhcnNlQ3JlYXRlVXBkYXRlU2VuZERyYWZ0UmVxdWVzdEJvZHkocmVxdWVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbXBvc2VSZXNwb25zZUJvZHlfMjAyMl8wOV8wOShyZXNwb25zZTogQXJyYXk8YW55Pikge1xuICByZXR1cm4gcGFyc2VDcmVhdGVVcGRhdGVTZW5kRHJhZnRSZXNwb25zZUJvZHkocmVzcG9uc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUJvZHlDb250ZW50SW5Db21wb3NlU2VuZFJlcXVlc3RCb2R5XzIwMjJfMDlfMDkoXG4gIHJlcXVlc3Q6IEFycmF5PGFueT4sXG4gIG5ld0JvZHlIdG1sQ29udGVudDogc3RyaW5nLFxuKTogQXJyYXk8YW55PiB8IG51bGwge1xuICByZXR1cm4gcmVwbGFjZUJvZHlDb250ZW50SW5TZW5kUmVxdWVzdEJvZHkocmVxdWVzdCwgbmV3Qm9keUh0bWxDb250ZW50KTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgcmVxdWVzdCBib2R5IHdoZW4gY29tcG9zZSB3aW5kb3cgZWl0aGVyIHNhdmVzIGEgZHJhZnQgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogdXBkYXRlcyB0aGUgZHJhZnQgb3Igc2VuZHMgdGhlIGRyYWZ0LlxuICogTk9URTogcmVxdWVzdCBjb3VsZCBjb250YWluIG11bHRpcGxlIHRocmVhZHMgYW5kIG1lc3NhZ2VzIHdpdGhpbiBpdCxcbiAqIHByaW9yaXRpemUgU0VORCB0byBEUkFGVF9TQVZFIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ3JlYXRlVXBkYXRlU2VuZERyYWZ0UmVxdWVzdEJvZHkocmVxdWVzdDogYW55W10pIHtcbiAgY29uc3QgdXBkYXRlTGlzdCA9IHJlcXVlc3RbMV0/LlswXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkodXBkYXRlTGlzdCkpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZE1lc3NhZ2VzID0gdXBkYXRlTGlzdC5tYXAocGFyc2VSZXF1ZXN0VGhyZWFkKS5maWx0ZXIoaXNOb3ROaWwpO1xuXG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRCeShwYXJzZWRNZXNzYWdlcywgKG0pID0+XG4gICAgQUNUSU9OX1RZUEVfUFJJT1JJVFlfUkFOSy5pbmRleE9mKG0udHlwZSksXG4gICk7XG5cbiAgcmV0dXJuIHNvcnRlZFswXSB8fCBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlcyByZXNwb25zZSBib2R5IHdoZW4gY29tcG9zZSB3aW5kb3cgZWl0aGVyIHNhdmVkIGEgZHJhZnQgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogdXBkYXRlZCB0aGUgZHJhZnQsIG9yIHNlbnQgdGhlIGRyYWZ0LlxuICogTk9URTogcmVzcG9uc2UgY291bGQgY29udGFpbiBtdWx0aXBsZSB0aHJlYWRzIGFuZCBtZXNzYWdlcyB3aXRoaW4gaXRcbiAqIGV2ZW4gbm90IHJlbGF0ZWQgdG8gYSBtZXNzYWdlL3RocmVhZCBpbiB0aGUgcmVxdWVzdCBib2R5LlxuICogU28gdGhlIGNhbGxpbmcgY29kZSBzaG91bGQgZmluZCBuZWVkZWQgbWVzc2FnZSBtYW51YWxseS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDcmVhdGVVcGRhdGVTZW5kRHJhZnRSZXNwb25zZUJvZHkocmVzcG9uc2U6IGFueVtdKSB7XG4gIGNvbnN0IHVwZGF0ZUxpc3QgPSByZXNwb25zZVsxXT8uWzVdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh1cGRhdGVMaXN0KSkge1xuICAgIC8vIGNhbm5vdCBwYXJzZVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVMaXN0XG4gICAgLm1hcChwYXJzZVJlc3BvbnNlVGhyZWFkKVxuICAgIC5maWx0ZXIoaXNOb3ROaWwpXG4gICAgLmZsYXRNYXAoKHBhcnNlZFRocmVhZCkgPT4ge1xuICAgICAgY29uc3QgeyB0aHJlYWRJZCwgb2xkVGhyZWFkSWQsIHBhcnNlZE1lc3NhZ2VzIH0gPSBwYXJzZWRUaHJlYWQ7XG5cbiAgICAgIHJldHVybiBwYXJzZWRNZXNzYWdlcy5tYXAoKHBhcnNlZE1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlSWQsIHRvLCBjYywgYmNjLCBhY3Rpb25zLCByZmNJRCwgb2xkTWVzc2FnZUlkIH0gPVxuICAgICAgICAgIHBhcnNlZE1lc3NhZ2U7XG5cbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbnNUb0NvbXBvc2VSZXF1ZXN0VHlwZShhY3Rpb25zKTtcblxuICAgICAgICBpZiAoIWFjdGlvblR5cGUpIHtcbiAgICAgICAgICAvLyB1bnN1cHBvcnRlZCBhY3Rpb25zIHdpdGhpbiBhIG1lc3NhZ2VcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIGNjLFxuICAgICAgICAgIGJjYyxcbiAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgIHJmY0lELFxuICAgICAgICAgIG9sZE1lc3NhZ2VJZCxcbiAgICAgICAgICBvbGRUaHJlYWRJZCxcbiAgICAgICAgICB0eXBlOiBhY3Rpb25UeXBlLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAuZmlsdGVyKGlzTm90TmlsKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUJvZHlDb250ZW50SW5TZW5kUmVxdWVzdEJvZHkoXG4gIHJlcXVlc3Q6IEFycmF5PGFueT4sXG4gIG5ld0JvZHlIdG1sQ29udGVudDogc3RyaW5nLFxuKSB7XG4gIC8vIHNpbmNlIGRyYWZ0SUQgaXMgbm90IHBhc3NlZCBmcm9tIG91dHNpZGUsXG4gIC8vIHVzZSBwYXJzZSBmdW5jdGlvbiB0byBmaW5kIGEgbWVzc2FnZSB3aGljaCBib2R5IG5lZWRzIHRvIGJlIHJlcGxhY2VkXG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ3JlYXRlVXBkYXRlU2VuZERyYWZ0UmVxdWVzdEJvZHkocmVxdWVzdCk7XG4gIGlmICghcGFyc2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCByZXBsYWNlQm9keUluVGhpc01lc3NhZ2VJZCA9IHBhcnNlZC5tZXNzYWdlSWQ7XG5cbiAgY29uc3QgdXBkYXRlTGlzdCA9IHJlcXVlc3RbMV0/LlswXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkodXBkYXRlTGlzdCkpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZvciAoY29uc3QgdGhyZWFkV3JhcHBlciBvZiB1cGRhdGVMaXN0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRocmVhZFdyYXBwZXIpIHx8ICFBcnJheS5pc0FycmF5KHRocmVhZFdyYXBwZXJbMV0pKSB7XG4gICAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZFdyYXBwZXJbMV07XG5cbiAgICBjb25zdCB0aHJlYWRJZCA9IHBhcnNlVGhyZWFkSWQodGhyZWFkWzBdKTtcbiAgICBpZiAoIXRocmVhZElkKSB7XG4gICAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gZmluZEFuZFBhcnNlUmVxdWVzdE1lc3NhZ2UodGhyZWFkKTtcblxuICAgIGlmIChwYXJzZVJlc3VsdD8ucGFyc2VkTXNnLm1lc3NhZ2VJZCA9PT0gcmVwbGFjZUJvZHlJblRoaXNNZXNzYWdlSWQpIHtcbiAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBhY3Rpb25zVG9Db21wb3NlUmVxdWVzdFR5cGUoXG4gICAgICAgIHBhcnNlUmVzdWx0LnBhcnNlZE1zZy5hY3Rpb25zLFxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGlvblR5cGUgPT09ICdTRU5EJykge1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG1lc3NhZ2Ugd2l0aCBuZWVkZWQgbWVzc2FnZUlkIGFuZCAnU0VORCcgYWN0aW9uIGFuZCByZXBsYWNlIHRoZSBib2R5IGNvbnRlbnRcbiAgICAgICAgcmVwbGFjZUJvZHlJblJlcXVlc3RNc2cocGFyc2VSZXN1bHQub3JpZ2luYWxNc2csIG5ld0JvZHlIdG1sQ29udGVudCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRocmVhZElkKHRocmVhZElkOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCF0aHJlYWRJZC5zdGFydHNXaXRoKCd0aHJlYWQtJykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0aHJlYWRJZC5pbmNsdWRlcygnfCcpKSB7XG4gICAgcmV0dXJuIHRocmVhZElkLnNwbGl0KCd8JylbMF07XG4gIH1cblxuICByZXR1cm4gdGhyZWFkSWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXNnSWQobWVzc2FnZUlkOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFtZXNzYWdlSWQuc3RhcnRzV2l0aCgnbXNnLScpKSB7XG4gICAgLy8gY2Fubm90IHBhcnNlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZUlkO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbnRhY3RzKGNvbnRhY3RzOiBhbnlbXSk6IENvbnRhY3RbXSB8IG51bGwge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29udGFjdHMpKSB7XG4gICAgLy8gY2Fubm90IHBhcnNlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGFjdHNcbiAgICAuZmlsdGVyKChjKSA9PiAhIWNbMV0pXG4gICAgLm1hcCgoYyk6IENvbnRhY3QgPT4gKHsgZW1haWxBZGRyZXNzOiBjWzFdLCBuYW1lOiBjWzJdID8/IG51bGwgfSkpO1xufVxuXG5mdW5jdGlvbiBmaW5kQW5kUGFyc2VSZXF1ZXN0TWVzc2FnZSh0aHJlYWQ6IGFueVtdKToge1xuICBwYXJzZWRNc2c6IE5vbk51bGxhYmxlPFJldHVyblR5cGU8dHlwZW9mIHBhcnNlUmVxdWVzdE1zZz4+O1xuICBvcmlnaW5hbE1zZzogYW55O1xufSB8IG51bGwge1xuICBjb25zdCBvcmlnaW5hbE1zZ3MgPSBbXG4gICAgdGhyZWFkWzFdPy5bMl0/LlswXT8uWzRdPy5bMF0sXG4gICAgdGhyZWFkWzFdPy5bMV0/LlswXSxcbiAgICB0aHJlYWRbMV0/LlsxM10/LlswXSxcbiAgXTtcblxuICBmb3IgKGNvbnN0IG9yaWdpbmFsTXNnIG9mIG9yaWdpbmFsTXNncykge1xuICAgIGNvbnN0IHBhcnNlZE1zZyA9IHBhcnNlUmVxdWVzdE1zZyhvcmlnaW5hbE1zZyk7XG4gICAgaWYgKHBhcnNlZE1zZykge1xuICAgICAgcmV0dXJuIHsgcGFyc2VkTXNnLCBvcmlnaW5hbE1zZyB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlcXVlc3RUaHJlYWQodGhyZWFkV3JhcHBlcjogYW55KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aHJlYWRXcmFwcGVyKSB8fCAhQXJyYXkuaXNBcnJheSh0aHJlYWRXcmFwcGVyWzFdKSkge1xuICAgIC8vIGNhbm5vdCBwYXJzZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgdGhyZWFkID0gdGhyZWFkV3JhcHBlclsxXTtcblxuICBjb25zdCB0aHJlYWRJZCA9IHBhcnNlVGhyZWFkSWQodGhyZWFkWzBdKTtcbiAgaWYgKCF0aHJlYWRJZCkge1xuICAgIC8vIGNhbm5vdCBwYXJzZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcGFyc2VSZXN1bHQgPSBmaW5kQW5kUGFyc2VSZXF1ZXN0TWVzc2FnZSh0aHJlYWQpO1xuXG4gIGlmICghcGFyc2VSZXN1bHQpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHsgcGFyc2VkTXNnOiBtZXNzYWdlLCBvcmlnaW5hbE1zZyB9ID0gcGFyc2VSZXN1bHQ7XG5cbiAgY29uc3QgeyBtZXNzYWdlSWQsIHRvLCBjYywgYmNjLCBzdWJqZWN0LCBib2R5LCBhY3Rpb25zIH0gPSBtZXNzYWdlO1xuXG4gIGxldCBhY3Rpb25UeXBlID0gYWN0aW9uc1RvQ29tcG9zZVJlcXVlc3RUeXBlKGFjdGlvbnMpO1xuICBpZiAoIWFjdGlvblR5cGUpIHtcbiAgICAvLyBleGl0IGlmIGRvZXNuJ3QgaGF2ZSByZXF1aXJlZCBhY3Rpb25zXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB1c3VhbGx5IGZvciBkcmFmdF9zYXZlIGFjdGlvbiB3aGVuIGRyYWZ0IG9yIHJlcGx5IGdvdCBzYXZlZCBmb3IgZmlyc3QgdGltZSwgcmVzcG9uc2UgY291bGQgYmUgZGlmZmVyZW50XG4gIC8vIGZyb20gdXN1YWwgdXBkYXRlIHJlc3BvbnNlLCBzbyByZXBsYWNlIGRyYWZ0X3NhdmUgYWN0aW9uIHdpdGggZmlyc3RfZHJhZnRfc2F2ZSBpbiB0aGlzIGNhc2UuXG4gIGlmIChcbiAgICBhY3Rpb25UeXBlID09PSAnRFJBRlRfU0FWRScgJiZcbiAgICAob3JpZ2luYWxNc2cgPT09IHRocmVhZFsxXT8uWzJdPy5bMF0/Lls0XT8uWzBdIHx8XG4gICAgICBvcmlnaW5hbE1zZyA9PT0gdGhyZWFkWzFdPy5bMV0/LlswXSlcbiAgKSB7XG4gICAgYWN0aW9uVHlwZSA9ICdGSVJTVF9EUkFGVF9TQVZFJztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGhyZWFkSWQsXG4gICAgbWVzc2FnZUlkLFxuICAgIHRvLFxuICAgIGNjLFxuICAgIGJjYyxcbiAgICBzdWJqZWN0LFxuICAgIGJvZHksXG4gICAgYWN0aW9ucyxcbiAgICB0eXBlOiBhY3Rpb25UeXBlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlcXVlc3RNc2cobXNnOiBhbnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1lc3NhZ2VJZCA9IHBhcnNlTXNnSWQobXNnWzBdKTtcbiAgaWYgKCFtZXNzYWdlSWQpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHN1YmplY3QgPSBtc2dbN107XG4gIGNvbnN0IHRvID0gcGFyc2VDb250YWN0cyhtc2dbMl0pO1xuICBjb25zdCBjYyA9IHBhcnNlQ29udGFjdHMobXNnWzNdKTtcbiAgY29uc3QgYmNjID0gcGFyc2VDb250YWN0cyhtc2dbNF0pO1xuICBjb25zdCBib2R5ID0gbXNnWzhdWzFdWzBdWzFdO1xuICBjb25zdCBhY3Rpb25zID0gbXNnWzEwXTtcbiAgY29uc3QgcmZjSUQgPSBtc2dbMTNdO1xuICBjb25zdCBvbGRNZXNzYWdlSWQgPSBtc2dbNTVdO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZUlkLFxuICAgIHRvLFxuICAgIGNjLFxuICAgIGJjYyxcbiAgICBzdWJqZWN0LFxuICAgIGJvZHksXG4gICAgYWN0aW9ucyxcbiAgICByZmNJRCxcbiAgICBvbGRNZXNzYWdlSWQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VCb2R5SW5SZXF1ZXN0TXNnKG1zZzogYW55LCBuZXdCb2R5SHRtbENvbnRlbnQ6IHN0cmluZykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgIC8vIGNhbm5vdCBwYXJzZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbXNnWzhdWzFdWzBdWzFdID0gbmV3Qm9keUh0bWxDb250ZW50O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlVGhyZWFkKHRocmVhZFdyYXBwZXI6IGFueSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGhyZWFkV3JhcHBlcikgfHwgIUFycmF5LmlzQXJyYXkodGhyZWFkV3JhcHBlclswXSkpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHRocmVhZCA9IHRocmVhZFdyYXBwZXJbMF07XG4gIGNvbnN0IHRocmVhZElkID0gcGFyc2VUaHJlYWRJZCh0aHJlYWRbMF0pO1xuICBpZiAoIXRocmVhZElkKSB7XG4gICAgLy8gY2Fubm90IHBhcnNlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB0aHJlYWRJbm5lciA9IHRocmVhZFsyXT8uWzZdPy5bMF07XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aHJlYWRJbm5lcikpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG9sZFRocmVhZElkID0gdGhyZWFkSW5uZXJbMTldO1xuXG4gIGNvbnN0IHBhcnNlZE1lc3NhZ2VzID0gQXJyYXkuaXNBcnJheSh0aHJlYWRJbm5lcls0XSlcbiAgICA/IHRocmVhZElubmVyWzRdXG4gICAgICAgIC5tYXAoKG1zZykgPT4ge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtc2cpKSB7XG4gICAgICAgICAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlTXNnKG1zZyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoaXNOb3ROaWwpXG4gICAgOiBbXTtcblxuICByZXR1cm4ge1xuICAgIHRocmVhZElkLFxuICAgIG9sZFRocmVhZElkLFxuICAgIHBhcnNlZE1lc3NhZ2VzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlTXNnKG1zZzogYW55W10pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1lc3NhZ2VJZCA9IHBhcnNlTXNnSWQobXNnWzBdKTtcbiAgaWYgKCFtZXNzYWdlSWQpIHtcbiAgICAvLyBjYW5ub3QgcGFyc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFjdGlvbnM6IHN0cmluZ1tdID0gbXNnWzEwXTtcbiAgY29uc3QgdG8gPSBwYXJzZUNvbnRhY3RzKG1zZ1syXSk7XG4gIGNvbnN0IGNjID0gcGFyc2VDb250YWN0cyhtc2dbM10pO1xuICBjb25zdCBiY2MgPSBwYXJzZUNvbnRhY3RzKG1zZ1s0XSk7XG4gIGNvbnN0IHJmY0lEID0gbXNnWzEzXTtcbiAgY29uc3Qgb2xkTWVzc2FnZUlkID0gbXNnWzU1XTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VJZCxcbiAgICB0byxcbiAgICBjYyxcbiAgICBiY2MsXG4gICAgYWN0aW9ucyxcbiAgICByZmNJRCxcbiAgICBvbGRNZXNzYWdlSWQsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25zVG9Db21wb3NlUmVxdWVzdFR5cGUoXG4gIGFjdGlvbnM6IHN0cmluZ1tdLFxuKTogQ29tcG9zZVJlcXVlc3RUeXBlIHwgbnVsbCB7XG4gIGlmIChcbiAgICBpbnRlcnNlY3Rpb24oYWN0aW9ucywgRFJBRlRfU0FWSU5HX0FDVElPTlMpLmxlbmd0aCA9PT1cbiAgICBEUkFGVF9TQVZJTkdfQUNUSU9OUy5sZW5ndGhcbiAgKSB7XG4gICAgcmV0dXJuICdEUkFGVF9TQVZFJztcbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb24oYWN0aW9ucywgU0VORF9BQ1RJT05TKS5sZW5ndGggPT09IFNFTkRfQUNUSU9OUy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ1NFTkQnO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgaW50ZXJzZWN0aW9uIGZyb20gJ2xvZGFzaC9pbnRlcnNlY3Rpb24nO1xuaW1wb3J0IHsgQ29tcG9zZVJlcXVlc3QsIENvbXBvc2VSZXF1ZXN0VHlwZSwgU0VORF9BQ1RJT05TIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29udGFjdCB9IGZyb20gJy4uLy4uL2luYm94c2RrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERldGFpbHNPZkNvbXBvc2VSZXF1ZXN0KFxuICBwYXJzZWQ6IFJlY29yZDxhbnksIGFueT4sXG4pOiBDb21wb3NlUmVxdWVzdCB8IG51bGwge1xuICBjb25zdCB1cGRhdGVMaXN0ID0gcGFyc2VkWzJdICYmIHBhcnNlZFsyXVsxXTtcbiAgaWYgKCF1cGRhdGVMaXN0KSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBtZXNzYWdlVXBkYXRlcyA9IHVwZGF0ZUxpc3QuZmlsdGVyKCh1cGRhdGU6IGFueSkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZVdyYXBwZXIgPVxuICAgICAgdXBkYXRlWzJdICYmIHVwZGF0ZVsyXVsyXSAmJiAodXBkYXRlWzJdWzJdWzE0XSB8fCB1cGRhdGVbMl1bMl1bMl0pO1xuICAgIHJldHVybiAoXG4gICAgICB1cGRhdGVXcmFwcGVyICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdWzFdICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdWzFdLmluZGV4T2YoJ21zZy1hOicpID4gLTFcbiAgICApO1xuICB9KTtcblxuICBpZiAobWVzc2FnZVVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc2VuZFVwZGF0ZU1hdGNoID0gbWVzc2FnZVVwZGF0ZXMuZmluZCgodXBkYXRlOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZVdyYXBwZXIgPVxuICAgICAgICB1cGRhdGVbMl0gJiYgdXBkYXRlWzJdWzJdICYmICh1cGRhdGVbMl1bMl1bMTRdIHx8IHVwZGF0ZVsyXVsyXVsyXSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHVwZGF0ZVdyYXBwZXJbMV1bMTFdICYmXG4gICAgICAgIGludGVyc2VjdGlvbih1cGRhdGVXcmFwcGVyWzFdWzExXSwgU0VORF9BQ1RJT05TKS5sZW5ndGggPT09XG4gICAgICAgICAgU0VORF9BQ1RJT05TLmxlbmd0aFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmIChzZW5kVXBkYXRlTWF0Y2gpIHtcbiAgICAgIGNvbnN0IHNlbmRVcGRhdGVXcmFwcGVyID1cbiAgICAgICAgc2VuZFVwZGF0ZU1hdGNoWzJdICYmXG4gICAgICAgIHNlbmRVcGRhdGVNYXRjaFsyXVsyXSAmJlxuICAgICAgICAoc2VuZFVwZGF0ZU1hdGNoWzJdWzJdWzE0XSB8fCBzZW5kVXBkYXRlTWF0Y2hbMl1bMl1bMl0pO1xuICAgICAgY29uc3Qgc2VuZFVwZGF0ZSA9IHNlbmRVcGRhdGVXcmFwcGVyWzFdO1xuICAgICAgcmV0dXJuIGdldENvbXBvc2VSZXF1ZXN0RnJvbVVwZGF0ZShzZW5kVXBkYXRlLCAnU0VORCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGEgc21hbGwgY2hhbmNlIHRoYXQgYW4gdXBkYXRlIGxpc3QgY291bGQgY29udGFpbiB0aGVcbiAgICAgIC8vIGRyYWZ0IHNhdmVzIGZvciBtdWx0aXBsZSBkcmFmdHMgaW4gc29tZSBzaXR1YXRpb25zIOKAlCB3ZSd2ZSBuZXZlclxuICAgICAgLy8gc2VlbiB0aGlzIHNvIGN1cnJlbnRseSBqdXN0IHBpY2tpbmcgdGhlIGZpcnN0IHVwZGF0ZSBhbmQgYXNzdW1pbmdcbiAgICAgIC8vIHRoYXQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHJlcXVlc3QgdGhleSBhcmUgZm9yXG4gICAgICAvLyBxdWV1ZWQgdXAgdmVyc2lvbnMgb2YgdGhlIHNhbWUgZHJhZnQuXG5cbiAgICAgIGNvbnN0IGZpcnN0TWVzc2FnZVVwZGF0ZSA9IG1lc3NhZ2VVcGRhdGVzWzBdO1xuICAgICAgY29uc3QgdXBkYXRlV3JhcHBlciA9XG4gICAgICAgIGZpcnN0TWVzc2FnZVVwZGF0ZVsyXSAmJlxuICAgICAgICBmaXJzdE1lc3NhZ2VVcGRhdGVbMl1bMl0gJiZcbiAgICAgICAgKGZpcnN0TWVzc2FnZVVwZGF0ZVsyXVsyXVsxNF0gfHwgZmlyc3RNZXNzYWdlVXBkYXRlWzJdWzJdWzJdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IHVwZGF0ZVdyYXBwZXJbMV07XG4gICAgICByZXR1cm4gZ2V0Q29tcG9zZVJlcXVlc3RGcm9tVXBkYXRlKHVwZGF0ZSwgJ0RSQUZUX1NBVkUnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGZpcnN0IHRpbWUgYSBkcmFmdCBpcyBzYXZlZCBpdCBoYXMgYSBkaWZmZXJlbnQgcmVzcG9uc2UgZm9ybWF0XG4gICAgY29uc3QgbWVzc2FnZVVwZGF0ZXMgPSB1cGRhdGVMaXN0XG4gICAgICAubWFwKFxuICAgICAgICAodXBkYXRlOiBhbnkpID0+XG4gICAgICAgICAgdXBkYXRlWzJdICYmXG4gICAgICAgICAgdXBkYXRlWzJdWzJdICYmXG4gICAgICAgICAgdXBkYXRlWzJdWzJdWzNdICYmXG4gICAgICAgICAgdXBkYXRlWzJdWzJdWzNdWzFdICYmXG4gICAgICAgICAgdXBkYXRlWzJdWzJdWzNdWzFdWzVdICYmXG4gICAgICAgICAgdXBkYXRlWzJdWzJdWzNdWzFdWzVdWzBdLFxuICAgICAgKVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGlmIChtZXNzYWdlVXBkYXRlcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGZpcnN0TWVzc2FnZVVwZGF0ZSA9IG1lc3NhZ2VVcGRhdGVzWzBdO1xuXG4gICAgcmV0dXJuIGdldENvbXBvc2VSZXF1ZXN0RnJvbVVwZGF0ZShmaXJzdE1lc3NhZ2VVcGRhdGUsICdGSVJTVF9EUkFGVF9TQVZFJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9zZVJlcXVlc3RGcm9tVXBkYXRlKFxuICB1cGRhdGU6IGFueSxcbiAgdHlwZTogQ29tcG9zZVJlcXVlc3RUeXBlLFxuKTogQ29tcG9zZVJlcXVlc3QgfCBudWxsIHtcbiAgY29uc3QgYm9keSA9XG4gICAgdXBkYXRlWzldICYmIHVwZGF0ZVs5XVsyXSAmJiB1cGRhdGVbOV1bMl1bMF0gJiYgdXBkYXRlWzldWzJdWzBdWzJdO1xuXG4gIGlmIChib2R5ID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgYm9keSxcbiAgICB0eXBlLFxuICAgIHRvOiBwYXJzZUNvbnRhY3RzKHVwZGF0ZVszXSksXG4gICAgY2M6IHBhcnNlQ29udGFjdHModXBkYXRlWzRdKSxcbiAgICBiY2M6IHBhcnNlQ29udGFjdHModXBkYXRlWzVdKSxcbiAgICBkcmFmdElEOiB1cGRhdGVbMV0ucmVwbGFjZSgnbXNnLWE6JywgJycpLFxuICAgIHN1YmplY3Q6IHVwZGF0ZVs4XSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb250YWN0cyhjb250YWN0czogYW55W10pOiBDb250YWN0W10gfCBudWxsIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRhY3RzKSkge1xuICAgIC8vIGV4aXQgY3V6IGNhbm5vdCBwYXJzZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhY3RzLm1hcChcbiAgICAoYyk6IENvbnRhY3QgPT4gKHsgZW1haWxBZGRyZXNzOiBjWzJdLCBuYW1lOiBjWzNdIHx8IG51bGwgfSksXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlRW1haWxCb2R5Rm9yU2VuZFJlcXVlc3QoXG4gIHJlcXVlc3Q6IHN0cmluZyxcbiAgbmV3Qm9keT86IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGlmICghbmV3Qm9keSkgcmV0dXJuIHJlcXVlc3Q7XG5cbiAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyZXF1ZXN0KTtcblxuICBjb25zdCB1cGRhdGVMaXN0ID0gcGFyc2VkWzJdICYmIHBhcnNlZFsyXVsxXTtcbiAgaWYgKCF1cGRhdGVMaXN0KSByZXR1cm4gcmVxdWVzdDtcblxuICBjb25zdCBtZXNzYWdlVXBkYXRlcyA9IHVwZGF0ZUxpc3QuZmlsdGVyKCh1cGRhdGU6IGFueSkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZVdyYXBwZXIgPVxuICAgICAgdXBkYXRlWzJdICYmIHVwZGF0ZVsyXVsyXSAmJiAodXBkYXRlWzJdWzJdWzE0XSB8fCB1cGRhdGVbMl1bMl1bMl0pO1xuICAgIHJldHVybiAoXG4gICAgICB1cGRhdGVXcmFwcGVyICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdWzFdICYmXG4gICAgICB1cGRhdGVXcmFwcGVyWzFdWzFdLmluZGV4T2YoJ21zZy1hOicpID4gLTFcbiAgICApO1xuICB9KTtcblxuICBpZiAoIW1lc3NhZ2VVcGRhdGVzLmxlbmd0aCkgcmV0dXJuIHJlcXVlc3Q7XG4gIGNvbnN0IHNlbmRVcGRhdGVNYXRjaCA9IG1lc3NhZ2VVcGRhdGVzLmZpbmQoKHVwZGF0ZTogYW55KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlV3JhcHBlciA9XG4gICAgICB1cGRhdGVbMl0gJiYgdXBkYXRlWzJdWzJdICYmICh1cGRhdGVbMl1bMl1bMTRdIHx8IHVwZGF0ZVsyXVsyXVsyXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgdXBkYXRlV3JhcHBlclsxXVsxMV0gJiZcbiAgICAgIGludGVyc2VjdGlvbih1cGRhdGVXcmFwcGVyWzFdWzExXSwgU0VORF9BQ1RJT05TKS5sZW5ndGggPT09XG4gICAgICAgIFNFTkRfQUNUSU9OUy5sZW5ndGhcbiAgICApO1xuICB9KTtcblxuICBpZiAoIXNlbmRVcGRhdGVNYXRjaCkgcmV0dXJuIHJlcXVlc3Q7XG4gIGNvbnN0IHNlbmRVcGRhdGVXcmFwcGVyID1cbiAgICBzZW5kVXBkYXRlTWF0Y2hbMl0gJiZcbiAgICBzZW5kVXBkYXRlTWF0Y2hbMl1bMl0gJiZcbiAgICAoc2VuZFVwZGF0ZU1hdGNoWzJdWzJdWzE0XSB8fCBzZW5kVXBkYXRlTWF0Y2hbMl1bMl1bMl0pO1xuICBjb25zdCBzZW5kVXBkYXRlID0gc2VuZFVwZGF0ZVdyYXBwZXJbMV07XG4gIHNlbmRVcGRhdGVbOV1bMl1bMF1bMl0gPSBuZXdCb2R5O1xuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9zZVJlcXVlc3QgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBwYXJzZUNvbXBvc2VSZXF1ZXN0Qm9keV8yMDIyXzA5XzA5LFxuICBwYXJzZUNvbXBvc2VSZXNwb25zZUJvZHlfMjAyMl8wOV8wOSxcbiAgcmVwbGFjZUJvZHlDb250ZW50SW5Db21wb3NlU2VuZFJlcXVlc3RCb2R5XzIwMjJfMDlfMDksXG59IGZyb20gJy4vc3luYy1jb21wb3NlLXByb2Nlc3Nvci0yMDIyMDkwOSc7XG5pbXBvcnQge1xuICBnZXREZXRhaWxzT2ZDb21wb3NlUmVxdWVzdCxcbiAgcmVwbGFjZUVtYWlsQm9keUZvclNlbmRSZXF1ZXN0LFxufSBmcm9tICcuL3N5bmMtY29tcG9zZS1yZXF1ZXN0LXByb2Nlc3Nvcic7XG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnLi4vaW5qZWN0ZWQtbG9nZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29tcG9zZVJlcXVlc3RCb2R5KFxuICByZXF1ZXN0OiBzdHJpbmcsXG4pOiBDb21wb3NlUmVxdWVzdCB8IG51bGwge1xuICBjb25zdCByZXF1ZXN0UGFyc2VkID0gSlNPTi5wYXJzZShyZXF1ZXN0KTtcblxuICB0cnkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3RQYXJzZWQpKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbXBvc2VSZXF1ZXN0Qm9keV8yMDIyXzA5XzA5KHJlcXVlc3RQYXJzZWQpO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHBhcnNlZC50eXBlLFxuICAgICAgICAgIHRvOiBwYXJzZWQudG8sXG4gICAgICAgICAgY2M6IHBhcnNlZC5jYyxcbiAgICAgICAgICBiY2M6IHBhcnNlZC5iY2MsXG4gICAgICAgICAgZHJhZnRJRDogcGFyc2VkLm1lc3NhZ2VJZC5yZXBsYWNlKCdtc2ctYTonLCAnJyksXG4gICAgICAgICAgc3ViamVjdDogcGFyc2VkLnN1YmplY3QsXG4gICAgICAgICAgYm9keTogcGFyc2VkLmJvZHksXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nZ2VyLmV2ZW50U2RrUGFzc2l2ZSgnY29ubmVjdGlvbi5yZXF1ZXN0UmVzcG9uc2VQYXJzaW5nRmFpbGVkJywge1xuICAgICAgcmVxdWVzdFBhcnNlRXJyb3I6IGVycixcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBnZXREZXRhaWxzT2ZDb21wb3NlUmVxdWVzdChyZXF1ZXN0UGFyc2VkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29tcG9zZVJlc3BvbnNlQm9keShyZXNwb25zZTogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc3BvbnNlUGFyc2VkID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2VQYXJzZWQpKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcG9zZVJlc3BvbnNlQm9keV8yMDIyXzA5XzA5KHJlc3BvbnNlUGFyc2VkKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VCb2R5Q29udGVudEluQ29tcG9zZVNlbmRSZXF1ZXN0Qm9keShcbiAgcmVxdWVzdDogc3RyaW5nLFxuICBuZXdCb2R5SHRtbENvbnRlbnQ6IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHJlcXVlc3RQYXJzZWQgPSBKU09OLnBhcnNlKHJlcXVlc3QpO1xuXG4gIHRyeSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdFBhcnNlZCkpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VkUmVxdWVzdE9iaiA9XG4gICAgICAgIHJlcGxhY2VCb2R5Q29udGVudEluQ29tcG9zZVNlbmRSZXF1ZXN0Qm9keV8yMDIyXzA5XzA5KFxuICAgICAgICAgIHJlcXVlc3RQYXJzZWQsXG4gICAgICAgICAgbmV3Qm9keUh0bWxDb250ZW50LFxuICAgICAgICApO1xuXG4gICAgICBpZiAocmVwbGFjZWRSZXF1ZXN0T2JqKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXBsYWNlZFJlcXVlc3RPYmopO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBjb3VsZG4ndCBwYXJzZSBhbmQgcmVwbGFjZSBib2R5IGNvbnRlbnQsIHJldHVybiBvcmlnaW5hbCBvYmplY3RcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nZ2VyLmV2ZW50U2RrUGFzc2l2ZSgnY29ubmVjdGlvbi5yZXF1ZXN0UmVzcG9uc2VQYXJzaW5nRmFpbGVkJywge1xuICAgICAgcmVwbGFjZUJvZHlGYWlsZWQ6IGVycixcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXBsYWNlRW1haWxCb2R5Rm9yU2VuZFJlcXVlc3QocmVxdWVzdCwgbmV3Qm9keUh0bWxDb250ZW50KTtcbn1cbiIsImltcG9ydCBjbG9uZSBmcm9tICdsb2Rhc2gvY2xvbmUnO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnbG9kYXNoL2ZsYXR0ZW4nO1xuaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0IGludGVyc2VjdGlvbiBmcm9tICdsb2Rhc2gvaW50ZXJzZWN0aW9uJztcbmltcG9ydCBpbmNsdWRlcyBmcm9tICdsb2Rhc2gvaW5jbHVkZXMnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IEtlZmlyIGZyb20gJ2tlZmlyJztcbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICcuLi9pbmplY3RlZC1sb2dnZXInO1xuaW1wb3J0IFhIUlByb3h5RmFjdG9yeSBmcm9tICcuLi94aHItcHJveHktZmFjdG9yeSc7XG5pbXBvcnQgcXVlcnlzdHJpbmcsIHsgc3RyaW5naWZ5IH0gZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgdGhyZWFkSWRlbnRpZmllciBmcm9tICcuL3RocmVhZC1pZGVudGlmaWVyJztcbmltcG9ydCAqIGFzIG1lc3NhZ2VNZXRhZGF0YUhvbGRlciBmcm9tICcuLi9tZXNzYWdlLW1ldGFkYXRhLWhvbGRlcic7XG5pbXBvcnQgKiBhcyBHbWFpbFJlc3BvbnNlUHJvY2Vzc29yIGZyb20gJy4uLy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RvbS1kcml2ZXIvZ21haWwvZ21haWwtcmVzcG9uc2UtcHJvY2Vzc29yJztcbmltcG9ydCAqIGFzIEdtYWlsU3luY1Jlc3BvbnNlUHJvY2Vzc29yIGZyb20gJy4uLy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2RvbS1kcml2ZXIvZ21haWwvZ21haWwtc3luYy1yZXNwb25zZS1wcm9jZXNzb3InO1xuaW1wb3J0IHF1b3RlZFNwbGl0IGZyb20gJy4uLy4uL2NvbW1vbi9xdW90ZWQtc3BsaXQnO1xuaW1wb3J0IGRlZmVyLCB7IERlZmVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL2RlZmVyJztcbmltcG9ydCBtb2RpZnlTdWdnZXN0aW9ucyBmcm9tICcuL21vZGlmeS1zdWdnZXN0aW9ucyc7XG5cbmltcG9ydCB7XG4gIHBhcnNlQ29tcG9zZVJlcXVlc3RCb2R5LFxuICBwYXJzZUNvbXBvc2VSZXNwb25zZUJvZHksXG4gIHJlcGxhY2VCb2R5Q29udGVudEluQ29tcG9zZVNlbmRSZXF1ZXN0Qm9keSxcbn0gZnJvbSAnLi9zeW5jLWNvbXBvc2UtcHJvY2Vzc29yJztcblxuaW1wb3J0IHR5cGUgeyBXcmFwcGVyLCBYSFJQcm94eUNvbm5lY3Rpb25EZXRhaWxzIH0gZnJvbSAnLi4veGhyLXByb3h5LWZhY3RvcnknO1xuXG5mdW5jdGlvbiBsb2dFcnJvckV4Y2VwdEV2ZW50TGlzdGVuZXJzKGVycjogdW5rbm93biwgZGV0YWlsczogc3RyaW5nKSB7XG4gIC8vIERvbid0IGxvZyBHbWFpbCdzIGVycm9yc1xuICBpZiAoZGV0YWlscyAhPT0gJ1hNTEh0dHBSZXF1ZXN0IGV2ZW50IGxpc3RlbmVyIGVycm9yJykge1xuICAgIGxvZ2dlci5lcnJvcihlcnIsIGRldGFpbHMpO1xuICB9IGVsc2Uge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gbGV0IHdpbmRvdy5vbmVycm9yIGxvZyB0aGlzXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSwgMSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBHbWFpbEludGVyY2VwdG9yKCkge1xuICBsZXQganNGcmFtZTogV2luZG93UHJveHkgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcbiAgY29uc3QganNfZnJhbWVfZWxlbWVudCA9IHRvcCEuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzX2ZyYW1lJyk7XG5cbiAgaWYgKGpzX2ZyYW1lX2VsZW1lbnQpIHtcbiAgICBqc0ZyYW1lID0gKGpzX2ZyYW1lX2VsZW1lbnQgYXMgYW55KS5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmV2ZW50U2RrUGFzc2l2ZSgnbm9KU0ZyYW1lRWxlbWVudEZvdW5kJyk7XG4gIH1cblxuICBzZXR1cEdtYWlsSW50ZXJjZXB0b3JPbkZyYW1lcyh3aW5kb3csIGpzRnJhbWUpO1xufVxuXG4vLyBTcGxpdCBpbnRvIGEgc2VwYXJhdGUgc3RlcCB0byBtYWtlIGl0IGVhc3kgZm9yIHRlc3RzIHRvIHVzZS5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cEdtYWlsSW50ZXJjZXB0b3JPbkZyYW1lcyhcbiAgbWFpbkZyYW1lOiBXaW5kb3dQcm94eSxcbiAganNGcmFtZTogV2luZG93UHJveHkgfCBudWxsIHwgdW5kZWZpbmVkLFxuKSB7XG4gIGNvbnN0IG1haW5fd3JhcHBlcnM6IFdyYXBwZXJbXSA9IFtdLFxuICAgIGpzX2ZyYW1lX3dyYXBwZXJzOiBXcmFwcGVyW10gPSBbXTtcblxuICB7XG4gICAgY29uc3QgbWFpbl9vcmlnaW5hbFhIUiA9IChtYWluRnJhbWUgYXMgYW55KS5YTUxIdHRwUmVxdWVzdDtcbiAgICAobWFpbkZyYW1lIGFzIGFueSkuWE1MSHR0cFJlcXVlc3QgPSBYSFJQcm94eUZhY3RvcnkoXG4gICAgICBtYWluX29yaWdpbmFsWEhSLFxuICAgICAgbWFpbl93cmFwcGVycyxcbiAgICAgIHtcbiAgICAgICAgbG9nRXJyb3I6IGxvZ0Vycm9yRXhjZXB0RXZlbnRMaXN0ZW5lcnMsXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICBpZiAoanNGcmFtZSkge1xuICAgIGNvbnN0IGpzX2ZyYW1lX29yaWdpbmFsWEhSID0gKGpzRnJhbWUgYXMgYW55KS5YTUxIdHRwUmVxdWVzdDtcbiAgICAoanNGcmFtZSBhcyBhbnkpLlhNTEh0dHBSZXF1ZXN0ID0gWEhSUHJveHlGYWN0b3J5KFxuICAgICAganNfZnJhbWVfb3JpZ2luYWxYSFIsXG4gICAgICBqc19mcmFtZV93cmFwcGVycyxcbiAgICAgIHtcbiAgICAgICAgbG9nRXJyb3I6IGxvZ0Vycm9yRXhjZXB0RXZlbnRMaXN0ZW5lcnMsXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICB0aHJlYWRJZGVudGlmaWVyLnNldHVwKCk7XG4gIG1lc3NhZ2VNZXRhZGF0YUhvbGRlci5zZXR1cCgpO1xuICAvL2VtYWlsIHNlbmRpbmcgbW9kaWZpZXIvbm90aWZpZXJcbiAge1xuICAgIGNvbnN0IG1vZGlmaWVyczogUmVjb3JkPHN0cmluZywgQXJyYXk8c3RyaW5nPj4gPSB7fTtcbiAgICBLZWZpci5mcm9tRXZlbnRzPHsgZGV0YWlsOiBhbnkgfSwgdW5rbm93bj4oXG4gICAgICBkb2N1bWVudCxcbiAgICAgICdpbmJveFNES3JlZ2lzdGVyQ29tcG9zZVJlcXVlc3RNb2RpZmllcicsXG4gICAgKS5vblZhbHVlKCh7IGRldGFpbCB9KSA9PiB7XG4gICAgICBjb25zdCBrZXlJZCA9IGRldGFpbC5jb21wb3NlaWQgfHwgZGV0YWlsLmRyYWZ0SUQ7XG5cbiAgICAgIGlmICghbW9kaWZpZXJzW2tleUlkXSkge1xuICAgICAgICBtb2RpZmllcnNba2V5SWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIG1vZGlmaWVyc1trZXlJZF0ucHVzaChkZXRhaWwubW9kaWZpZXJJZCk7XG4gICAgfSk7XG4gICAgS2VmaXIuZnJvbUV2ZW50cyhcbiAgICAgIGRvY3VtZW50LFxuICAgICAgJ2luYm94U0RLdW5yZWdpc3RlckNvbXBvc2VSZXF1ZXN0TW9kaWZpZXInLFxuICAgICkub25WYWx1ZSgoeyBkZXRhaWwgfTogYW55KSA9PiB7XG4gICAgICBjb25zdCB7IGtleUlkLCBtb2RpZmllcklkIH0gPSBkZXRhaWw7XG4gICAgICBtb2RpZmllcnNba2V5SWRdID0gbW9kaWZpZXJzW2tleUlkXS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IG1vZGlmaWVySWQpO1xuXG4gICAgICBpZiAobW9kaWZpZXJzW2tleUlkXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVyc1trZXlJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnBhcmFtcy5hY3QgPT09ICdzbSc7XG4gICAgICB9LFxuICAgICAgb3JpZ2luYWxTZW5kQm9keUxvZ2dlcjogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGJvZHkpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnZW1haWxTZW5kaW5nJyxcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0Q2hhbmdlcjogYXN5bmMgZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IGNvbXBvc2VQYXJhbXMgPSBxdWVyeXN0cmluZy5wYXJzZShyZXF1ZXN0LmJvZHkpO1xuICAgICAgICBjb25zdCBjb21wb3NlaWQgPSBjb21wb3NlUGFyYW1zLmNvbXBvc2VpZDtcbiAgICAgICAgY29uc3QgY29tcG9zZU1vZGlmaWVySWRzID0gbW9kaWZpZXJzW2NvbXBvc2VQYXJhbXMuY29tcG9zZWlkIGFzIGFueV07XG5cbiAgICAgICAgaWYgKCFjb21wb3NlTW9kaWZpZXJJZHMgfHwgY29tcG9zZU1vZGlmaWVySWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGNvbXBvc2VNb2RpZmllcklkcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllcklkID0gY29tcG9zZU1vZGlmaWVySWRzW2lpXTtcbiAgICAgICAgICBjb25zdCBtb2RpZmljYXRpb25Qcm9taXNlID0gS2VmaXIuZnJvbUV2ZW50czxhbnksIHVua25vd24+KFxuICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICAnaW5ib3hTREtjb21wb3NlUmVxdWVzdE1vZGlmaWVkJyxcbiAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAoeyBkZXRhaWwgfSkgPT5cbiAgICAgICAgICAgICAgICBkZXRhaWwuY29tcG9zZWlkID09PSBjb21wb3NlaWQgJiZcbiAgICAgICAgICAgICAgICBkZXRhaWwubW9kaWZpZXJJZCA9PT0gbW9kaWZpZXJJZCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC50YWtlKDEpXG4gICAgICAgICAgICAubWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwuY29tcG9zZVBhcmFtcylcbiAgICAgICAgICAgIC50b1Byb21pc2UoLyogUHJvbWlzZSAqLyk7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbmJveFNES21vZGlmeUNvbXBvc2VSZXF1ZXN0JyxcbiAgICAgICAgICAgIGNvbXBvc2VpZCxcbiAgICAgICAgICAgIG1vZGlmaWVySWQsXG4gICAgICAgICAgICBjb21wb3NlUGFyYW1zOiB7XG4gICAgICAgICAgICAgIGJvZHk6IGNvbXBvc2VQYXJhbXMuYm9keSxcbiAgICAgICAgICAgICAgaXNQbGFpblRleHQ6IGNvbXBvc2VQYXJhbXMuaXNodG1sICE9PSAnMScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG5ld0NvbXBvc2VQYXJhbXMgPSBhd2FpdCBtb2RpZmljYXRpb25Qcm9taXNlO1xuICAgICAgICAgIGNvbXBvc2VQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wb3NlUGFyYW1zLCBuZXdDb21wb3NlUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0LCB7XG4gICAgICAgICAgYm9keTogc3RyaW5naWZ5Q29tcG9zZVBhcmFtcyhjb21wb3NlUGFyYW1zKSxcbiAgICAgICAgfSkgYXMgYW55O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGlzdGVuZXJzOiBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZW1haWxTZW50JyxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogY29ubmVjdGlvbi5vcmlnaW5hbFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgIG9yaWdpbmFsU2VuZEJvZHk6IGNvbm5lY3Rpb24ub3JpZ2luYWxTZW5kQm9keSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb25uZWN0aW9uLm9yaWdpbmFsU2VuZEJvZHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvc2VQYXJhbXMgPSBxdWVyeXN0cmluZy5wYXJzZShcbiAgICAgICAgICAgICAgY29ubmVjdGlvbi5vcmlnaW5hbFNlbmRCb2R5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RpZmllcnNbY29tcG9zZVBhcmFtcy5jb21wb3NlaWQgYXMgc3RyaW5nXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnBhcmFtcy5hY3QgPT09ICdzZCc7XG4gICAgICB9LFxuICAgICAgb3JpZ2luYWxTZW5kQm9keUxvZ2dlcjogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGJvZHkpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnZW1haWxEcmFmdFNhdmVTZW5kaW5nJyxcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxpc3RlbmVyczogZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2VtYWlsRHJhZnRSZWNlaXZlZCcsXG4gICAgICAgICAgICByZXNwb25zZVRleHQ6IGNvbm5lY3Rpb24ub3JpZ2luYWxSZXNwb25zZVRleHQsXG4gICAgICAgICAgICBvcmlnaW5hbFNlbmRCb2R5OiBjb25uZWN0aW9uLm9yaWdpbmFsU2VuZEJvZHksXG4gICAgICAgICAgICBjb25uZWN0aW9uRGV0YWlsczoge1xuICAgICAgICAgICAgICBtZXRob2Q6IGNvbm5lY3Rpb24ubWV0aG9kLFxuICAgICAgICAgICAgICB1cmw6IGNvbm5lY3Rpb24udXJsLFxuICAgICAgICAgICAgICBwYXJhbXM6IGNvbm5lY3Rpb24ucGFyYW1zLFxuICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IGNvbm5lY3Rpb24ucmVzcG9uc2VUeXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgICB7XG4gICAgICAvLyBTeW5jIEFQSS1iYXNlZCBjb21wb3NlIHNlbmRpbmcgaW50ZXJjZXB0XG4gICAgICBjb25zdCBjdXJyZW50U2VuZENvbm5lY3Rpb25JRHM6IFdlYWtNYXA8XG4gICAgICAgIFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHMsXG4gICAgICAgIHN0cmluZ1xuICAgICAgPiA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb25zdCBjdXJyZW50RHJhZnRTYXZlQ29ubmVjdGlvbklEczogV2Vha01hcDxcbiAgICAgICAgWEhSUHJveHlDb25uZWN0aW9uRGV0YWlscyxcbiAgICAgICAgc3RyaW5nXG4gICAgICA+ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHM6IFdlYWtNYXA8XG4gICAgICAgIFhIUlByb3h5Q29ubmVjdGlvbkRldGFpbHMsXG4gICAgICAgIHN0cmluZ1xuICAgICAgPiA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBtYWluX3dyYXBwZXJzLnB1c2goe1xuICAgICAgICBpc1JlbGV2YW50VG8oY29ubmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAvc3luYyg/OlxcL3VcXC9cXGQrKT9cXC9pXFwvcy8udGVzdChjb25uZWN0aW9uLnVybCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JpZ2luYWxTZW5kQm9keUxvZ2dlcihjb25uZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24ub3JpZ2luYWxTZW5kQm9keSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9zZVJlcXVlc3REZXRhaWxzID0gcGFyc2VDb21wb3NlUmVxdWVzdEJvZHkoXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24ub3JpZ2luYWxTZW5kQm9keSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9zZVJlcXVlc3REZXRhaWxzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBkcmFmdElEIH0gPSBjb21wb3NlUmVxdWVzdERldGFpbHM7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY29tcG9zZVJlcXVlc3REZXRhaWxzLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnRklSU1RfRFJBRlRfU0FWRSc6XG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0RHJhZnRTYXZlQ29ubmVjdGlvbklEcy5zZXQoY29ubmVjdGlvbiwgZHJhZnRJRCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnRFJBRlRfU0FWRSc6XG4gICAgICAgICAgICAgICAgY3VycmVudERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuc2V0KGNvbm5lY3Rpb24sIGRyYWZ0SUQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ1NFTkQnOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcy5zZXQoY29ubmVjdGlvbiwgZHJhZnRJRCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbWFpbFNlbmRpbmcnLFxuICAgICAgICAgICAgICAgICAgZHJhZnRJRCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVxdWVzdENoYW5nZXI6IGFzeW5jIGZ1bmN0aW9uIChjb25uZWN0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgICAgY29uc3QgY29tcG9zZVJlcXVlc3REZXRhaWxzID0gcGFyc2VDb21wb3NlUmVxdWVzdEJvZHkocmVxdWVzdC5ib2R5KTtcbiAgICAgICAgICBpZiAoIWNvbXBvc2VSZXF1ZXN0RGV0YWlscyB8fCBjb21wb3NlUmVxdWVzdERldGFpbHMudHlwZSAhPT0gJ1NFTkQnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgY29uc3QgeyBkcmFmdElEIH0gPSBjb21wb3NlUmVxdWVzdERldGFpbHM7XG4gICAgICAgICAgY29uc3QgY29tcG9zZU1vZGlmaWVySWRzID0gbW9kaWZpZXJzW2RyYWZ0SURdO1xuICAgICAgICAgIGlmICghY29tcG9zZU1vZGlmaWVySWRzIHx8IGNvbXBvc2VNb2RpZmllcklkcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICBsZXQgbmV3RW1haWxCb2R5ID0gY29tcG9zZVJlcXVlc3REZXRhaWxzLmJvZHk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgY29tcG9zZU1vZGlmaWVySWRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJJZCA9IGNvbXBvc2VNb2RpZmllcklkc1tpaV07XG4gICAgICAgICAgICBjb25zdCBtb2RpZmljYXRpb25Qcm9taXNlID0gS2VmaXIuZnJvbUV2ZW50czxhbnksIHVua25vd24+KFxuICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgJ2luYm94U0RLY29tcG9zZVJlcXVlc3RNb2RpZmllZCcsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHsgZGV0YWlsIH0pID0+XG4gICAgICAgICAgICAgICAgICBkZXRhaWwuZHJhZnRJRCA9PT0gZHJhZnRJRCAmJlxuICAgICAgICAgICAgICAgICAgZGV0YWlsLm1vZGlmaWVySWQgPT09IG1vZGlmaWVySWQsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnRha2UoMSlcbiAgICAgICAgICAgICAgLm1hcCgoeyBkZXRhaWwgfSkgPT4gZGV0YWlsLmNvbXBvc2VQYXJhbXMpXG4gICAgICAgICAgICAgIC50b1Byb21pc2UoLyogUHJvbWlzZSAqLyk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAnaW5ib3hTREttb2RpZnlDb21wb3NlUmVxdWVzdCcsXG4gICAgICAgICAgICAgIGRyYWZ0SUQsXG4gICAgICAgICAgICAgIG1vZGlmaWVySWQsXG4gICAgICAgICAgICAgIGNvbXBvc2VQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBib2R5OiBuZXdFbWFpbEJvZHksXG4gICAgICAgICAgICAgICAgaXNQbGFpblRleHQ6IGZhbHNlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdDb21wb3NlUGFyYW1zID0gYXdhaXQgbW9kaWZpY2F0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgIG5ld0VtYWlsQm9keSA9IG5ld0NvbXBvc2VQYXJhbXMuYm9keTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCwge1xuICAgICAgICAgICAgYm9keTogcmVwbGFjZUJvZHlDb250ZW50SW5Db21wb3NlU2VuZFJlcXVlc3RCb2R5KFxuICAgICAgICAgICAgICByZXF1ZXN0LmJvZHksXG4gICAgICAgICAgICAgIG5ld0VtYWlsQm9keSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSkgYXMgYW55O1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGlzdGVuZXJzKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50U2VuZENvbm5lY3Rpb25JRHMuaGFzKGNvbm5lY3Rpb24pIHx8XG4gICAgICAgICAgICBjdXJyZW50RHJhZnRTYXZlQ29ubmVjdGlvbklEcy5oYXMoY29ubmVjdGlvbikgfHxcbiAgICAgICAgICAgIGN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuaGFzKGNvbm5lY3Rpb24pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzZW5kRmFpbGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlbWFpbFNlbmRGYWlsZWQnLFxuICAgICAgICAgICAgICAgIGRyYWZ0SUQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjdXJyZW50U2VuZENvbm5lY3Rpb25JRHMuZGVsZXRlKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZHJhZnRJRCA9XG4gICAgICAgICAgICAgIGN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcy5nZXQoY29ubmVjdGlvbikgfHxcbiAgICAgICAgICAgICAgY3VycmVudERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuZ2V0KGNvbm5lY3Rpb24pIHx8XG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuZ2V0KGNvbm5lY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0dXMgIT09IDIwMCB8fCAhY29ubmVjdGlvbi5vcmlnaW5hbFJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICBzZW5kRmFpbGVkKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzUGFyc2VkID0gcGFyc2VDb21wb3NlUmVzcG9uc2VCb2R5KFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ub3JpZ2luYWxSZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNwb25zZVBhcnNlZCBvZiByZXNwb25zZXNQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgZHJhZnQsIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgcmVzcG9uc2UgcmVsYXRlZCB0byB0aGUgZHJhZnQgd2UncmUgc2VuZGluZy5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZnRJRCAmJiAhcmVzcG9uc2VQYXJzZWQubWVzc2FnZUlkLmVuZHNXaXRoKGRyYWZ0SUQpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZVBhcnNlZC50eXBlID09PSAnRklSU1RfRFJBRlRfU0FWRScgfHxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUGFyc2VkLnR5cGUgPT09ICdEUkFGVF9TQVZFJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZnRJRDogZHJhZnRJRCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtYWlsRHJhZnRSZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgIHJmY0lEOiByZXNwb25zZVBhcnNlZC5yZmNJRCxcbiAgICAgICAgICAgICAgICAgICAgdGhyZWFkSUQ6IHJlc3BvbnNlUGFyc2VkLnRocmVhZElkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IHJlc3BvbnNlUGFyc2VkLm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgb2xkTWVzc2FnZUlEOiByZXNwb25zZVBhcnNlZC5vbGRNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgIG9sZFRocmVhZElEOiByZXNwb25zZVBhcnNlZC5vbGRUaHJlYWRJZCxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFNlbmRDb25uZWN0aW9uSURzLmRlbGV0ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnREcmFmdFNhdmVDb25uZWN0aW9uSURzLmRlbGV0ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuZGVsZXRlKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VQYXJzZWQudHlwZSA9PT0gJ1NFTkQnKSB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBkcmFmdElEOiBkcmFmdElELFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW1haWxTZW50JyxcbiAgICAgICAgICAgICAgICAgICAgcmZjSUQ6IHJlc3BvbnNlUGFyc2VkLnJmY0lELFxuICAgICAgICAgICAgICAgICAgICB0aHJlYWRJRDogcmVzcG9uc2VQYXJzZWQudGhyZWFkSWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJRDogcmVzcG9uc2VQYXJzZWQubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICBvbGRNZXNzYWdlSUQ6IHJlc3BvbnNlUGFyc2VkLm9sZE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVGhyZWFkSUQ6IHJlc3BvbnNlUGFyc2VkLm9sZFRocmVhZElkLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50U2VuZENvbm5lY3Rpb25JRHMuZGVsZXRlKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgY3VycmVudERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuZGVsZXRlKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0RHJhZnRTYXZlQ29ubmVjdGlvbklEcy5kZWxldGUoY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmV2ZW50U2RrUGFzc2l2ZShcbiAgICAgICAgICAgICAgICAnY29ubmVjdGlvbi5yZXF1ZXN0UmVzcG9uc2VQYXJzaW5nRmFpbGVkJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZVBhcnNlRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlc3BvbnNlID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgY29ubmVjdGlvbi5vcmlnaW5hbFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBmdW5jdGlvbiBzaWxlbnRseSBmYWlscyB3YXkgdG9vIGVhc2lseS4gTmVlZCB0byBhZGQgYmV0dGVyIGxvZ2dpbmcgZm9yIGl0IVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMuaGFzKGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVzcG9uc2VbMl0gJiZcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFJlc3BvbnNlWzJdWzZdICYmXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZVsyXVs2XVswXSAmJlxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVzcG9uc2VbMl1bNl1bMF1bMV07XG5cbiAgICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aHJlYWRVcGRhdGUgPVxuICAgICAgICAgICAgICAgICAgd3JhcHBlclszXSAmJiB3cmFwcGVyWzNdWzddICYmIHdyYXBwZXJbM11bN11bMV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVVwZGF0ZSA9XG4gICAgICAgICAgICAgICAgICB0aHJlYWRVcGRhdGUgJiYgdGhyZWFkVXBkYXRlWzVdICYmIHRocmVhZFVwZGF0ZVs1XVswXTtcblxuICAgICAgICAgICAgICAgIGlmICh0aHJlYWRVcGRhdGUgJiYgbWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZnRJRDogZHJhZnRJRCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtYWlsRHJhZnRSZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgIHJmY0lEOiBtZXNzYWdlVXBkYXRlWzE0XSxcbiAgICAgICAgICAgICAgICAgICAgdGhyZWFkSUQ6IHRocmVhZFVwZGF0ZVs0XS5zcGxpdCgnfCcpWzBdLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IG1lc3NhZ2VVcGRhdGVbMV0sXG4gICAgICAgICAgICAgICAgICAgIG9sZE1lc3NhZ2VJRDogbWVzc2FnZVVwZGF0ZVs1Nl0sXG4gICAgICAgICAgICAgICAgICAgIG9sZFRocmVhZElEOiB0aHJlYWRVcGRhdGVbMjBdLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBkcmFmdCBzYXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmUtMjAxOS0wNS0yOSBoYW5kbGluZ1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ldmVudFNka1Bhc3NpdmUoJ29sZCBjb21wb3NlIGRyYWZ0IGlkIGhhbmRsaW5nIGhpdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFdyYXBwZXIgPVxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZVsyXSAmJlxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZVsyXVs2XSAmJlxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZVsyXVs2XVsxXSAmJlxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZVsyXVs2XVsxXVsxXTtcblxuICAgICAgICAgICAgICAgIGlmIChvbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzYXZlVXBkYXRlID1cbiAgICAgICAgICAgICAgICAgICAgb2xkV3JhcHBlclszXSAmJiBvbGRXcmFwcGVyWzNdWzFdICYmIG9sZFdyYXBwZXJbM11bMV1bMV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChzYXZlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgZHJhZnRJRDogZHJhZnRJRCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW1haWxEcmFmdFJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICByZmNJRDogc2F2ZVVwZGF0ZVsxNF0sXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlEOiBzYXZlVXBkYXRlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgIG9sZE1lc3NhZ2VJRDogc2F2ZVVwZGF0ZVs0OF1cbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IEJpZ051bWJlcihzYXZlVXBkYXRlWzQ4XSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNhdmVVcGRhdGVbNTZdLFxuICAgICAgICAgICAgICAgICAgICAgIHN5bmNUaHJlYWRJRDogb2xkV3JhcHBlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVMaXN0ID0gb3JpZ2luYWxSZXNwb25zZVsyXT8uWzZdO1xuXG4gICAgICAgICAgICAgIGlmICghdXBkYXRlTGlzdCkge1xuICAgICAgICAgICAgICAgIHNlbmRGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBzZW5kVXBkYXRlTWF0Y2ggPSB1cGRhdGVMaXN0LmZpbmQoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZTogYW55KSA9PlxuICAgICAgICAgICAgICAgICAgdXBkYXRlWzFdPy5bM10/Lls3XT8uWzFdPy5bNV0/LlswXT8uWzE0XSAmJlxuICAgICAgICAgICAgICAgICAgdXBkYXRlWzFdWzNdWzddWzFdWzVdLmZpbmQoKG1lc3NhZ2U6IGFueSkgPT5cbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXMobWVzc2FnZVsxXSwgZHJhZnRJRCksXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmICghc2VuZFVwZGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcy5oYXMoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbmltYWxTZW5kVXBkYXRlcyA9IHVwZGF0ZUxpc3QuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAodXBkYXRlOiBhbnkpID0+IHVwZGF0ZVsxXT8uWzNdPy5bNV0/LlszXSxcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtaW5pbWFsU2VuZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aHJlYWRJRCA9IG1pbmltYWxTZW5kVXBkYXRlc1swXVsxXVsxXVxuICAgICAgICAgICAgICAgICAgICAgID8gbWluaW1hbFNlbmRVcGRhdGVzWzBdWzFdWzFdLnJlcGxhY2UoL1xcfC4qJC8sICcnKVxuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgIGRyYWZ0SUQsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtYWlsU2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgdGhyZWFkSUQsXG4gICAgICAgICAgICAgICAgICAgICAgLy9uZXcgY29tcG9zZVxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltYWxTZW5kVXBkYXRlc1swXVsxXVszXT8uWzVdPy5bNV0/LlswXSB8fCAvL3JlcGxpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltYWxTZW5kVXBkYXRlc1swXVsxXVszXVs1XVszXT8uWzBdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VuZEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHNlbmRVcGRhdGVXcmFwcGVyID0gc2VuZFVwZGF0ZU1hdGNoWzFdPy5bM10/Lls3XT8uWzFdO1xuICAgICAgICAgICAgICBjb25zdCBzZW5kVXBkYXRlID0gc2VuZFVwZGF0ZVdyYXBwZXJbNV0uZmluZCgobWVzc2FnZTogYW55KSA9PlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VbMV0uaW5jbHVkZXMoZHJhZnRJRCksXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzZW5kVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgc2VuZEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGlzRW1haWxTZW50UmVzcG9uc2UgPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcy5oYXMoY29ubmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbmRVcGRhdGVbMTFdKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihuZXcgRXJyb3IoJ3NlbmRVcGRhdGVbMTFdIHdhcyBub3QgYW4gYXJyYXknKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1haWxTZW50UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzZW5kVXBkYXRlWzExXS5pbmRleE9mKCdecicpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignc2VuZFVwZGF0ZVsxMV0gdW5leHBlY3RlZGx5IGNvbnRhaW5lZCBcIl5yXCInKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNFbWFpbFNlbnRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZW5kVXBkYXRlWzIyXSAhPT0gdW5kZWZpbmVkICYmIHNlbmRVcGRhdGVbMjJdICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignc2VuZFVwZGF0ZVsyMl0gd2FzIG5vdCBleHBlY3RlZCB2YWx1ZScpLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlbmRVcGRhdGVbMjJdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB0aHJlYWRJRCA9IHNlbmRVcGRhdGVXcmFwcGVyWzRdXG4gICAgICAgICAgICAgICAgPyBzZW5kVXBkYXRlV3JhcHBlcls0XS5yZXBsYWNlKC9cXHwuKiQvLCAnJylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgICAgICBkcmFmdElEOiBkcmFmdElELFxuICAgICAgICAgICAgICAgIHR5cGU6IGlzRW1haWxTZW50UmVzcG9uc2UgPyAnZW1haWxTZW50JyA6ICdlbWFpbERyYWZ0UmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgIHJmY0lEOiBzZW5kVXBkYXRlWzE0XSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IHNlbmRVcGRhdGVbMV0sXG4gICAgICAgICAgICAgICAgb2xkTWVzc2FnZUlEOiBzZW5kVXBkYXRlWzQ4XVxuICAgICAgICAgICAgICAgICAgPyBuZXcgQmlnTnVtYmVyKHNlbmRVcGRhdGVbNDhdKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgICAgIDogc2VuZFVwZGF0ZVs1Nl0sXG4gICAgICAgICAgICAgICAgdGhyZWFkSUQsXG4gICAgICAgICAgICAgICAgLy8gSXQgc2VlbXMgR21haWwgaXMgQS9CIHRlc3RpbmcgaW5jbHVkaW5nIGdtYWlsVGhyZWFkSUQgaW4gcmVzcG9uc2VbMjBdIGFuZCBub3QgaW5jbHVkaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVuY29kZWQgdmVyc2lvbiBvZiBpdCBpbiByZXNwb25zZVsxOF0sIHNvIHB1bGwgaXQgZnJvbSBbMjBdIGlmIFsxOF0gaXMgbm90IHNldC5cbiAgICAgICAgICAgICAgICBvbGRUaHJlYWRJRDpcbiAgICAgICAgICAgICAgICAgIHNlbmRVcGRhdGVXcmFwcGVyWzE4XSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJpZ051bWJlcihzZW5kVXBkYXRlV3JhcHBlclsxOF0pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICA6IHNlbmRVcGRhdGVXcmFwcGVyWzIwXSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcy5kZWxldGUoY29ubmVjdGlvbik7XG4gICAgICAgICAgICBjdXJyZW50RHJhZnRTYXZlQ29ubmVjdGlvbklEcy5kZWxldGUoY29ubmVjdGlvbik7XG4gICAgICAgICAgICBjdXJyZW50Rmlyc3REcmFmdFNhdmVDb25uZWN0aW9uSURzLmRlbGV0ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBpbnRlcmNlcHQgYW5kIHByb2Nlc3MgdGhyZWFkIHJlc3BvbnNlc1xuICB7XG4gICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG8oY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gISFjb25uZWN0aW9uLnBhcmFtcy5zZWFyY2ggJiYgY29ubmVjdGlvbi5wYXJhbXMudmlldyA9PT0gJ3RsJztcbiAgICAgIH0sXG4gICAgICBhc3luYyByZXNwb25zZVRleHRDaGFuZ2VyKGNvbm5lY3Rpb24sIHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAvLyBQcmVzZW5jZSBvZiBhIHJlc3BvbnNlVGV4dENoYW5nZXIgYmxvY2tzIEdtYWlsIGZyb20gZ2V0dGluZyB0aGUgcGFydGlhbFxuICAgICAgICAvLyB2YWx1ZXMgYXMgdGhpcyBsb2Fkcy4gV2Ugd2FudCBvdXIgb3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXIgdG8gcnVuXG4gICAgICAgIC8vIGJlZm9yZSBHbWFpbCBoYXMgc2VlbiBhbnkgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAgICByZXR1cm4gcmVzcG9uc2VUZXh0O1xuICAgICAgfSxcbiAgICAgIG9yaWdpbmFsUmVzcG9uc2VUZXh0TG9nZ2VyKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBjb25uZWN0aW9uLm9yaWdpbmFsUmVzcG9uc2VUZXh0O1xuICAgICAgICAgIHRocmVhZElkZW50aWZpZXIucHJvY2Vzc1RocmVhZExpc3RSZXNwb25zZShyZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIC8vIGludGVyY2VwdCBhbmQgcHJvY2VzcyBjb252ZXJzYXRpb24gdmlldyByZXNwb25zZXMgdG8gZ2V0IG1lc3NhZ2UgbWV0YWRhdGFcbiAge1xuICAgIC8vIGRvIHRoaXMgZm9yIGdtYWlsIHYxXG4gICAge1xuICAgICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICAgIGlzUmVsZXZhbnRUbyhjb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucGFyYW1zLnZpZXcgPT09ICdjdic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXIoY29ubmVjdGlvbikge1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cGVkTWVzc2FnZXMgPSBHbWFpbFJlc3BvbnNlUHJvY2Vzc29yLmV4dHJhY3RNZXNzYWdlcyhcbiAgICAgICAgICAgICAgY29ubmVjdGlvbi5vcmlnaW5hbFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtZXNzYWdlTWV0YWRhdGFIb2xkZXIuYWRkKGdyb3VwZWRNZXNzYWdlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN5bmMgQVBJIGJhc2VkXG4gICAge1xuICAgICAgLy8gc2VhcmNoIHJlc3BvbnNlXG4gICAgICBtYWluX3dyYXBwZXJzLnB1c2goe1xuICAgICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIC9zeW5jKD86XFwvdVxcL1xcZCspP1xcL2lcXC9idi8udGVzdChjb25uZWN0aW9uLnVybCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXIoY29ubmVjdGlvbikge1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zdCB0aHJlYWRzID1cbiAgICAgICAgICAgICAgR21haWxTeW5jUmVzcG9uc2VQcm9jZXNzb3IuZXh0cmFjdFRocmVhZHNGcm9tU2VhcmNoUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vcmlnaW5hbFJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1lc3NhZ2VNZXRhZGF0YUhvbGRlci5hZGQoXG4gICAgICAgICAgICAgIHRocmVhZHMubWFwKChzeW5jVGhyZWFkKSA9PiAoe1xuICAgICAgICAgICAgICAgIHRocmVhZElEOiBzeW5jVGhyZWFkLnN5bmNUaHJlYWRJRCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3luY1RocmVhZC5leHRyYU1ldGFEYXRhLnN5bmNNZXNzYWdlRGF0YS5tYXAoXG4gICAgICAgICAgICAgICAgICAoc3luY01lc3NhZ2UpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHN5bmNNZXNzYWdlLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJlY2lwaWVudHM6IHN5bmNNZXNzYWdlLnJlY2lwaWVudHMsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB9KSkgYXMgYW55LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIC8vIHRocmVhZCByZXNwb25zZVxuICAgICAgbWFpbl93cmFwcGVycy5wdXNoKHtcbiAgICAgICAgaXNSZWxldmFudFRvOiBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAvc3luYyg/OlxcL3VcXC9cXGQrKT9cXC9pXFwvZmQvLnRlc3QoY29ubmVjdGlvbi51cmwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9yaWdpbmFsUmVzcG9uc2VUZXh0TG9nZ2VyKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgdGhyZWFkcyA9XG4gICAgICAgICAgICAgIEdtYWlsU3luY1Jlc3BvbnNlUHJvY2Vzc29yLmV4dHJhY3RUaHJlYWRzRnJvbVRocmVhZFJlc3BvbnNlKFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ub3JpZ2luYWxSZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtZXNzYWdlTWV0YWRhdGFIb2xkZXIuYWRkKFxuICAgICAgICAgICAgICB0aHJlYWRzLm1hcCgoc3luY1RocmVhZCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0aHJlYWRJRDogc3luY1RocmVhZC5zeW5jVGhyZWFkSUQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN5bmNUaHJlYWQuZXh0cmFNZXRhRGF0YS5zeW5jTWVzc2FnZURhdGEubWFwKFxuICAgICAgICAgICAgICAgICAgKHN5bmNNZXNzYWdlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBzeW5jTWVzc2FnZS5kYXRlLFxuICAgICAgICAgICAgICAgICAgICByZWNpcGllbnRzOiBzeW5jTWVzc2FnZS5yZWNpcGllbnRzLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgfSkpIGFzIGFueSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIFNlYXJjaCBzdWdnZXN0aW9ucyBtb2RpZmllclxuICAvLyBUaGUgY29udGVudCBzY3JpcHRzIHRlbGwgdXMgd2hlbiB0aGV5J3JlIGludGVyZXN0ZWQgaW4gYWRkaW5nXG4gIC8vIG1vZGlmaWNhdGlvbnMgdG8gZnV0dXJlIHN1Z2dlc3Rpb24gcmVzdWx0cy4gV2hlbiB3ZSBzZWUgYSBzZWFyY2hcbiAgLy8gc3VnZ2VzdGlvbnMgcmVxdWVzdCBjb21lIHRocm91Z2gsIHdlIHNpZ25hbCB0aGUgcXVlcnkgc3RyaW5nIHRvIHRoZSBjb250ZW50XG4gIC8vIHNjcmlwdHMsIHdhaXQgZm9yIHRoZSBzYW1lIG51bWJlciBvZiByZXNwb25zZXMgYXMgdGhlIG51bWJlciBvZiByZWdpc3RlcmVkXG4gIC8vIHN1Z2dlc3Rpb24gbW9kaWZpZXJzLCBhbmQgdGhlbiBtZWxkIHRoZW0gaW50byB0aGUgcXVlcnkgcmVzcG9uc2UuXG4gIHtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjdXJyZW50UXVlcnk6IHVua25vd247XG4gICAgbGV0IHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zOiBhbnk7XG4gICAgbGV0IGN1cnJlbnRRdWVyeURlZmVyOiBhbnk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2luYm94U0RLcmVnaXN0ZXJTdWdnZXN0aW9uc01vZGlmaWVyJyxcbiAgICAgIGZ1bmN0aW9uICh7IGRldGFpbCB9OiBhbnkpIHtcbiAgICAgICAgcHJvdmlkZXJzW2RldGFpbC5wcm92aWRlcklEXSA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogT2JqZWN0LmtleXMocHJvdmlkZXJzKS5sZW5ndGgsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdpbmJveFNES3Byb3ZpZGVTdWdnZXN0aW9ucycsXG4gICAgICBmdW5jdGlvbiAoeyBkZXRhaWwgfTogYW55KSB7XG4gICAgICAgIGlmIChkZXRhaWwucXVlcnkgPT09IGN1cnJlbnRRdWVyeSkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzW2RldGFpbC5wcm92aWRlcklEXTtcbiAgICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVyIGRvZXMgbm90IGV4aXN0IGZvciBwcm92aWRlcklEJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJpZWQgdG8gbW9kaWZpZWQgYSBudWxsIHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VnZ2VzdGlvbk1vZGlmaWNhdGlvbnNbcHJvdmlkZXIucG9zaXRpb25dID0gZGV0YWlsLnN1Z2dlc3Rpb25zO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zLmZpbHRlcihCb29sZWFuKS5sZW5ndGggPT09XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm92aWRlcnMpLmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWVyeURlZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmllZCB0byByZXNvbHZlIGEgbnVsbCBjdXJyZW50UXVlcnlEZWZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFF1ZXJ5RGVmZXIucmVzb2x2ZShmbGF0dGVuKHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zKSk7XG4gICAgICAgICAgICBjdXJyZW50UXVlcnlEZWZlciA9IGN1cnJlbnRRdWVyeSA9IHN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcblxuICAgIG1haW5fd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG8oY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIE9iamVjdC5rZXlzKHByb3ZpZGVycykubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICEhY29ubmVjdGlvbi51cmwubWF0Y2goL15cXC9jbG91ZHNlYXJjaFxcL3JlcXVlc3RcXD8vKSAmJlxuICAgICAgICAgIGNvbm5lY3Rpb24ucGFyYW1zLmNsaWVudCA9PSAnZ21haWwnICYmXG4gICAgICAgICAgY29ubmVjdGlvbi5wYXJhbXMuZ3NfcmkgPT0gJ2dtYWlsJ1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9yaWdpbmFsU2VuZEJvZHlMb2dnZXIoY29ubmVjdGlvbiwgYm9keSkge1xuICAgICAgICBjb25zdCBwYXJzZWRCb2R5ID0gcXVlcnlzdHJpbmcucGFyc2UoYm9keSk7XG4gICAgICAgIGlmICghcGFyc2VkQm9keS5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gSlNPTi5wYXJzZShwYXJzZWRCb2R5LnJlcXVlc3QgYXMgc3RyaW5nKVsyXTtcbiAgICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UXVlcnkgPSBxdWVyeTtcbiAgICAgICAgaWYgKGN1cnJlbnRRdWVyeURlZmVyKSBjdXJyZW50UXVlcnlEZWZlci5yZXNvbHZlKCk7XG4gICAgICAgIGN1cnJlbnRRdWVyeURlZmVyID0gKGNvbm5lY3Rpb24gYXMgYW55KS5fZGVmZXIgPSBkZWZlcigpO1xuICAgICAgICBzdWdnZXN0aW9uTW9kaWZpY2F0aW9ucyA9IFtdO1xuICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdzdWdnZXN0aW9uc1JlcXVlc3QnLFxuICAgICAgICAgIHF1ZXJ5OiBjdXJyZW50UXVlcnksXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgYXN5bmMgcmVzcG9uc2VUZXh0Q2hhbmdlcihjb25uZWN0aW9uLCByZXNwb25zZVRleHQpIHtcbiAgICAgICAgaWYgKChjb25uZWN0aW9uIGFzIGFueSkuX2RlZmVyICYmIGNvbm5lY3Rpb24uc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBjb25zdCBtb2RpZmljYXRpb25zID0gYXdhaXQgKGNvbm5lY3Rpb24gYXMgYW55KS5fZGVmZXIucHJvbWlzZTtcblxuICAgICAgICAgIGlmIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZ5U3VnZ2VzdGlvbnMocmVzcG9uc2VUZXh0LCBtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2VUZXh0O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICB7XG4gICAgLy8gVE9ETzogc2ltcGxpZnkgdGhpcyBjb2RlXG4gICAgLy8gdGhlIHRyaWdnZXJFdmVudCBjYWxsIHNob3VsZCBoYXBwZW4gaW4gdGhlIHJlcXVlc3RDaGFuZ2VyIGNhbGxiYWNrXG4gICAgLy8gYW5kIGEgbG90IG9mIHRoZXNlIHN0YXRlIHZhcmlhYmxlcyBjYW4gYmUgc3RvcmVkIGluIHRoZSBjbG9zdXJlXG4gICAgLy8gU2VhcmNoIHF1ZXJ5IHJlcGxhY2VyLlxuICAgIC8vIFRoZSBjb250ZW50IHNjcmlwdCB0ZWxscyB1cyBzZWFyY2ggdGVybXMgdG8gd2F0Y2ggZm9yLiBXaGVuZXZlciB3ZSBzZWUgYVxuICAgIC8vIHNlYXJjaCBxdWVyeSBjb250YWluaW5nIHRoZSB0ZXJtLCB3ZSBkZWxheSBpdCBiZWluZyBzZW50IG91dCwgdHJpZ2dlciBhblxuICAgIC8vIGV2ZW50IGNvbnRhaW5pbmcgdGhlIGZ1bGwgcXVlcnksIGFuZCB3YWl0IGZvciBhIHJlc3BvbnNlIGV2ZW50IGZyb20gdGhlXG4gICAgLy8gY29udGVudCBzY3JpcHQgdGhhdCBjb250YWlucyBhIG5ldyBxdWVyeSB0byBzdWJzdGl0dXRlIGluLlxuICAgIGNvbnN0IGN1c3RvbVNlYXJjaFRlcm1zOiB1bmtub3duW10gPSBbXTtcbiAgICBsZXQgcXVlcnlSZXBsYWNlbWVudDoge1xuICAgICAgdGVybTogdW5rbm93bjtcbiAgICAgIHF1ZXJ5OiB1bmtub3duO1xuICAgICAgbmV3UXVlcnk6IERlZmVyPHVua25vd24+O1xuICAgICAgc3RhcnQ6IHVua25vd247XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnaW5ib3hTREtjcmVhdGVDdXN0b21TZWFyY2hUZXJtJyxcbiAgICAgIGZ1bmN0aW9uIChldmVudDogYW55KSB7XG4gICAgICAgIGN1c3RvbVNlYXJjaFRlcm1zLnB1c2goZXZlbnQuZGV0YWlsLnRlcm0pO1xuICAgICAgfSxcbiAgICApO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnaW5ib3hTREtzZWFyY2hSZXBsYWNlbWVudFJlYWR5JyxcbiAgICAgIGZ1bmN0aW9uIChldmVudDogYW55KSB7XG4gICAgICAgIGlmIChxdWVyeVJlcGxhY2VtZW50LnF1ZXJ5ID09PSBldmVudC5kZXRhaWwucXVlcnkpIHtcbiAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50Lm5ld1F1ZXJ5LnJlc29sdmUoZXZlbnQuZGV0YWlsLm5ld1F1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gY2xhc3NpYyBHbWFpbCBBUEkgaW50ZXJjZXB0XG4gICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIGxldCBjdXN0b21TZWFyY2hUZXJtOiB1bmtub3duO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBjb25uZWN0aW9uLnBhcmFtcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvbm5lY3Rpb24ubWV0aG9kID09PSAnUE9TVCcgJiZcbiAgICAgICAgICBwYXJhbXMuc2VhcmNoICYmXG4gICAgICAgICAgcGFyYW1zLnZpZXcgPT09ICd0bCcgJiZcbiAgICAgICAgICBjb25uZWN0aW9uLnVybC5tYXRjaCgvXlxcPy8pICYmXG4gICAgICAgICAgcGFyYW1zLnEgJiZcbiAgICAgICAgICAoY3VzdG9tU2VhcmNoVGVybSA9IGludGVyc2VjdGlvbihcbiAgICAgICAgICAgIGN1c3RvbVNlYXJjaFRlcm1zLFxuICAgICAgICAgICAgcXVvdGVkU3BsaXQocGFyYW1zLnEpLFxuICAgICAgICAgIClbMF0pXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHF1ZXJ5UmVwbGFjZW1lbnQgJiZcbiAgICAgICAgICAgIHF1ZXJ5UmVwbGFjZW1lbnQucXVlcnkgPT09IHBhcmFtcy5xICYmXG4gICAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50LnN0YXJ0ICE9IHBhcmFtcy5zdGFydFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgc2FtZSBxdWVyeSB0aGF0IHdhcyBtYWRlIGxhc3QsIGJ1dCBqdXN0IGZvciBhXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgcGFnZSwgdGhlbiByZS11c2UgdGhlIHJlcGxhY2VtZW50IHF1ZXJ5IHdlIGdvdCBsYXN0IHRpbWUuXG4gICAgICAgICAgICAvLyBEb24ndCB3YWl0IG9uIHRoZSBleHRlbnNpb24gdG8gY29tZSB1cCB3aXRoIGl0IGFnYWluIChhbmQgcmlzayBpdFxuICAgICAgICAgICAgLy8gZ2l2aW5nIGFuIGluY29uc2lzdGVudCBhbnN3ZXIgYmV0d2VlbiBwYWdlcykuXG4gICAgICAgICAgICAoY29ubmVjdGlvbiBhcyBhbnkpLl9xdWVyeVJlcGxhY2VtZW50ID0gcXVlcnlSZXBsYWNlbWVudDtcbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIG9sZCBxdWVyeVJlcGxhY2VtZW50IHdpdGggdGhpcyBwYWdlIG5vdyBzbyB3ZSBjYW4gdGVsbCBvblxuICAgICAgICAgICAgLy8gYSBsYXRlciByZXF1ZXN0IHdoZXRoZXIgdGhlIHBhZ2Ugd2FzIGNoYW5nZWQgb3IgdGhlIGxpc3QgcmVmcmVzaFxuICAgICAgICAgICAgLy8gYnV0dG9uIHdhcyBoaXQuXG4gICAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50LnN0YXJ0ID0gcGFyYW1zLnN0YXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocXVlcnlSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBvbGQgb25lIHdpdGggc29tZXRoaW5nIGJlY2F1c2Ugbm8gb25lIGVsc2UgaXMgZ29pbmdcbiAgICAgICAgICAgICAgLy8gdG8gYWZ0ZXIgaXQncyByZXBsYWNlZCBpbiBhIG1vbWVudC5cbiAgICAgICAgICAgICAgcXVlcnlSZXBsYWNlbWVudC5uZXdRdWVyeS5yZXNvbHZlKHF1ZXJ5UmVwbGFjZW1lbnQucXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlSZXBsYWNlbWVudCA9IChjb25uZWN0aW9uIGFzIGFueSkuX3F1ZXJ5UmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICAgIHRlcm06IGN1c3RvbVNlYXJjaFRlcm0sXG4gICAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXMucSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHBhcmFtcy5zdGFydCxcbiAgICAgICAgICAgICAgbmV3UXVlcnk6IGRlZmVyKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NlYXJjaFF1ZXJ5Rm9yUmVwbGFjZW1lbnQnLFxuICAgICAgICAgICAgICB0ZXJtOiBjdXN0b21TZWFyY2hUZXJtLFxuICAgICAgICAgICAgICBxdWVyeTogcGFyYW1zLnEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0Q2hhbmdlcjogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIChjb25uZWN0aW9uIGFzIGFueSkuX3F1ZXJ5UmVwbGFjZW1lbnQubmV3UXVlcnkucHJvbWlzZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChuZXdRdWVyeTogc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBjbG9uZShjb25uZWN0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgICBuZXdQYXJhbXMucSA9IG5ld1F1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgdXJsOiAnPycgKyBzdHJpbmdpZnkobmV3UGFyYW1zKSxcbiAgICAgICAgICAgICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIG5ld2VyLCBzeW5jIEFQSSBiYXNlZCByZXF1ZXN0IGludGVyY2VwdFxuICAgIG1haW5fd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29ubmVjdGlvbi5tZXRob2QgPT09ICdQT1NUJyAmJlxuICAgICAgICAgIC9zeW5jKD86XFwvdVxcL1xcZCspP1xcL2lcXC9idi8udGVzdChjb25uZWN0aW9uLnVybClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0Q2hhbmdlcjogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IGN1c3RvbVNlYXJjaFRlcm07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3QuYm9keSk7XG4gICAgICAgIGxldCBuZXdGb3JtYXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBheWxvYWQsIHNlYXJjaFN0cmluZywgcGFnZU9mZnNldDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgICAgIG5ld0Zvcm1hdCA9IHRydWU7XG5cbiAgICAgICAgICBwYXlsb2FkID0gYm9keVswXTtcbiAgICAgICAgICBzZWFyY2hTdHJpbmcgPSBwYXlsb2FkWzNdO1xuICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYXlsb2FkWzldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBheWxvYWQgPSBib2R5WzFdO1xuICAgICAgICAgIHNlYXJjaFN0cmluZyA9IHBheWxvYWRbNF07XG4gICAgICAgICAgcGFnZU9mZnNldCA9IHBheWxvYWRbMTBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNTeW5jQVBJU2VhcmNoV2l0aEN1c3RvbVRlcm0gPVxuICAgICAgICAgIHBheWxvYWRbbmV3Rm9ybWF0ID8gMCA6IDFdID09PSA3OSAmJlxuICAgICAgICAgIHR5cGVvZiBzZWFyY2hTdHJpbmcgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgKGN1c3RvbVNlYXJjaFRlcm0gPSBpbnRlcnNlY3Rpb24oXG4gICAgICAgICAgICBjdXN0b21TZWFyY2hUZXJtcyxcbiAgICAgICAgICAgIHF1b3RlZFNwbGl0KHNlYXJjaFN0cmluZyksXG4gICAgICAgICAgKVswXSk7XG4gICAgICAgIGlmICghaXNTeW5jQVBJU2VhcmNoV2l0aEN1c3RvbVRlcm0pIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVxdWVzdCk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHF1ZXJ5UmVwbGFjZW1lbnQgJiZcbiAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50LnF1ZXJ5ID09PSBzZWFyY2hTdHJpbmcgJiZcbiAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50LnN0YXJ0ICE9IHBhZ2VPZmZzZXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgc2FtZSBxdWVyeSB0aGF0IHdhcyBtYWRlIGxhc3QsIGJ1dCBqdXN0IGZvciBhXG4gICAgICAgICAgLy8gZGlmZmVyZW50IHBhZ2UsIHRoZW4gcmUtdXNlIHRoZSByZXBsYWNlbWVudCBxdWVyeSB3ZSBnb3QgbGFzdCB0aW1lLlxuICAgICAgICAgIC8vIERvbid0IHdhaXQgb24gdGhlIGV4dGVuc2lvbiB0byBjb21lIHVwIHdpdGggaXQgYWdhaW4gKGFuZCByaXNrIGl0XG4gICAgICAgICAgLy8gZ2l2aW5nIGFuIGluY29uc2lzdGVudCBhbnN3ZXIgYmV0d2VlbiBwYWdlcykuXG4gICAgICAgICAgKGNvbm5lY3Rpb24gYXMgYW55KS5fcXVlcnlSZXBsYWNlbWVudCA9IHF1ZXJ5UmVwbGFjZW1lbnQ7XG4gICAgICAgICAgLy8gTWFyayB0aGUgb2xkIHF1ZXJ5UmVwbGFjZW1lbnQgd2l0aCB0aGlzIHBhZ2Ugbm93IHNvIHdlIGNhbiB0ZWxsIG9uXG4gICAgICAgICAgLy8gYSBsYXRlciByZXF1ZXN0IHdoZXRoZXIgdGhlIHBhZ2Ugd2FzIGNoYW5nZWQgb3IgdGhlIGxpc3QgcmVmcmVzaFxuICAgICAgICAgIC8vIGJ1dHRvbiB3YXMgaGl0LlxuICAgICAgICAgIHF1ZXJ5UmVwbGFjZW1lbnQuc3RhcnQgPSBwYWdlT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChxdWVyeVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBvbGQgb25lIHdpdGggc29tZXRoaW5nIGJlY2F1c2Ugbm8gb25lIGVsc2UgaXMgZ29pbmdcbiAgICAgICAgICAgIC8vIHRvIGFmdGVyIGl0J3MgcmVwbGFjZWQgaW4gYSBtb21lbnQuXG4gICAgICAgICAgICBxdWVyeVJlcGxhY2VtZW50Lm5ld1F1ZXJ5LnJlc29sdmUocXVlcnlSZXBsYWNlbWVudC5xdWVyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcXVlcnlSZXBsYWNlbWVudCA9IChjb25uZWN0aW9uIGFzIGFueSkuX3F1ZXJ5UmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICB0ZXJtOiBjdXN0b21TZWFyY2hUZXJtLFxuICAgICAgICAgICAgcXVlcnk6IHNlYXJjaFN0cmluZyxcbiAgICAgICAgICAgIHN0YXJ0OiBwYWdlT2Zmc2V0LFxuICAgICAgICAgICAgbmV3UXVlcnk6IGRlZmVyKCksXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ3NlYXJjaFF1ZXJ5Rm9yUmVwbGFjZW1lbnQnLFxuICAgICAgICAgICAgdGVybTogY3VzdG9tU2VhcmNoVGVybSxcbiAgICAgICAgICAgIHF1ZXJ5OiBzZWFyY2hTdHJpbmcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGNvbm5lY3Rpb24gYXMgYW55KS5fcXVlcnlSZXBsYWNlbWVudC5uZXdRdWVyeS5wcm9taXNlLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKG5ld1F1ZXJ5OiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdGb3JtYXQpIHtcbiAgICAgICAgICAgICAgYm9keVswXVszXSA9IG5ld1F1ZXJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYm9keVsxXVs0XSA9IG5ld1F1ZXJ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAge1xuICAgIC8vIFNlYXJjaCByZXN1bHRzIHJlcGxhY2VyLlxuICAgIC8vIFRoZSBjb250ZW50IHNjcmlwdCB0ZWxscyB1cyBhIHNlYXJjaCBxdWVyeSB0byB3YXRjaCBmb3IuIFdoZW5ldmVyIHdlIHNlZVxuICAgIC8vIHRoZSBzZWFyY2ggcXVlcnksIHRyaWdnZXIgYW4gZXZlbnQgY29udGFpbmluZyB0aGUgcXVlcnksIHRyaWdnZXIgYW5cbiAgICAvLyBldmVudCBjb250YWluaW5nIHRoZSByZXNwb25zZSwgYW5kIHRoZW4gd2FpdCBmb3IgYSByZXNwb25zZSBldmVudCBmcm9tXG4gICAgLy8gdGhlIGNvbnRlbnQgc2NyaXB0IHRoYXQgY29udGFpbnMgbmV3IHJlc3VsdHMgdG8gc3Vic3RpdHV0ZSBpbi5cbiAgICBjb25zdCBjdXN0b21TZWFyY2hRdWVyaWVzOiB1bmtub3duW10gPSBbXTtcbiAgICBsZXQgY3VzdG9tTGlzdEpvYjoge1xuICAgICAgcXVlcnk6IHVua25vd247XG4gICAgICBzdGFydDogdW5rbm93bjtcbiAgICAgIG5ld1JlcXVlc3RQYXJhbXM6IERlZmVyPHVua25vd24+O1xuICAgICAgbmV3UmVzdWx0czogRGVmZXI8dW5rbm93bj47XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2luYm94U0RLY3VzdG9tTGlzdFJlZ2lzdGVyUXVlcnknLFxuICAgICAgKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgY3VzdG9tU2VhcmNoUXVlcmllcy5wdXNoKGV2ZW50LmRldGFpbC5xdWVyeSk7XG4gICAgICB9LFxuICAgICk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5ib3hTREtjdXN0b21MaXN0TmV3UXVlcnknLCAoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBjdXN0b21MaXN0Sm9iLnF1ZXJ5ID09PSBldmVudC5kZXRhaWwucXVlcnkgJiZcbiAgICAgICAgY3VzdG9tTGlzdEpvYi5zdGFydCA9PT0gZXZlbnQuZGV0YWlsLnN0YXJ0XG4gICAgICApIHtcbiAgICAgICAgY29uc3QgeyBuZXdRdWVyeSwgbmV3U3RhcnQgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY3VzdG9tTGlzdEpvYi5uZXdSZXF1ZXN0UGFyYW1zLnJlc29sdmUoe1xuICAgICAgICAgIHF1ZXJ5OiBuZXdRdWVyeSxcbiAgICAgICAgICBzdGFydDogbmV3U3RhcnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2luYm94U0RLY3VzdG9tTGlzdFJlc3VsdHMnLCAoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgaWYgKGN1c3RvbUxpc3RKb2IucXVlcnkgPT09IGV2ZW50LmRldGFpbC5xdWVyeSkge1xuICAgICAgICBjdXN0b21MaXN0Sm9iLm5ld1Jlc3VsdHMucmVzb2x2ZShldmVudC5kZXRhaWwubmV3UmVzdWx0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAganNfZnJhbWVfd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGNvbm5lY3Rpb24ucGFyYW1zO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBjb25uZWN0aW9uLm1ldGhvZCA9PT0gJ1BPU1QnICYmXG4gICAgICAgICAgcGFyYW1zLnNlYXJjaCAmJlxuICAgICAgICAgIHBhcmFtcy52aWV3ID09PSAndGwnICYmXG4gICAgICAgICAgY29ubmVjdGlvbi51cmwubWF0Y2goL15cXD8vKSAmJlxuICAgICAgICAgIHBhcmFtcy5xICYmXG4gICAgICAgICAgIXBhcmFtcy5hY3QgJiZcbiAgICAgICAgICBmaW5kKGN1c3RvbVNlYXJjaFF1ZXJpZXMsICh4KSA9PiB4ID09PSBwYXJhbXMucSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGN1c3RvbUxpc3RKb2IpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIG9sZCBvbmUgd2l0aCBzb21ldGhpbmcgYmVjYXVzZSBubyBvbmUgZWxzZSBpcyBnb2luZ1xuICAgICAgICAgICAgLy8gdG8gYWZ0ZXIgaXQncyByZXBsYWNlZCBpbiBhIG1vbWVudC5cbiAgICAgICAgICAgIGN1c3RvbUxpc3RKb2IubmV3UmVxdWVzdFBhcmFtcy5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcXVlcnk6IGN1c3RvbUxpc3RKb2IucXVlcnksXG4gICAgICAgICAgICAgIHN0YXJ0OiBjdXN0b21MaXN0Sm9iLnN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXN0b21MaXN0Sm9iLm5ld1Jlc3VsdHMucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXN0b21MaXN0Sm9iID0gKGNvbm5lY3Rpb24gYXMgYW55KS5fY3VzdG9tTGlzdEpvYiA9IHtcbiAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXMucSxcbiAgICAgICAgICAgIHN0YXJ0OiArcGFyYW1zLnN0YXJ0LFxuICAgICAgICAgICAgbmV3UmVxdWVzdFBhcmFtczogZGVmZXIoKSxcbiAgICAgICAgICAgIG5ld1Jlc3VsdHM6IGRlZmVyKCksXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ3NlYXJjaEZvclJlcGxhY2VtZW50JyxcbiAgICAgICAgICAgIHF1ZXJ5OiBjdXN0b21MaXN0Sm9iLnF1ZXJ5LFxuICAgICAgICAgICAgc3RhcnQ6IGN1c3RvbUxpc3RKb2Iuc3RhcnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdENoYW5nZXI6IGZ1bmN0aW9uIChjb25uZWN0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiAoY29ubmVjdGlvbiBhcyBhbnkpLl9jdXN0b21MaXN0Sm9iLm5ld1JlcXVlc3RQYXJhbXMucHJvbWlzZS50aGVuKFxuICAgICAgICAgICh7IHF1ZXJ5LCBzdGFydCB9OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IGNsb25lKGNvbm5lY3Rpb24ucGFyYW1zKTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5xID0gcXVlcnk7XG4gICAgICAgICAgICBuZXdQYXJhbXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgIHVybDogJz8nICsgc3RyaW5naWZ5KG5ld1BhcmFtcyksXG4gICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVRleHRDaGFuZ2VyOiBmdW5jdGlvbiAoY29ubmVjdGlvbiwgcmVzcG9uc2UpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnc2VhcmNoUmVzdWx0c1Jlc3BvbnNlJyxcbiAgICAgICAgICBxdWVyeTogKGNvbm5lY3Rpb24gYXMgYW55KS5fY3VzdG9tTGlzdEpvYi5xdWVyeSxcbiAgICAgICAgICBzdGFydDogKGNvbm5lY3Rpb24gYXMgYW55KS5fY3VzdG9tTGlzdEpvYi5zdGFydCxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY29ubmVjdGlvbiBhcyBhbnkpLl9jdXN0b21MaXN0Sm9iLm5ld1Jlc3VsdHMucHJvbWlzZS50aGVuKFxuICAgICAgICAgIChuZXdSZXN1bHRzOiBhbnkpID0+IChuZXdSZXN1bHRzID09PSBudWxsID8gcmVzcG9uc2UgOiBuZXdSZXN1bHRzKSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gU3luYyBBUEktYmFzZWQgY3VzdG9tIHRocmVhZCBsaXN0IGludGVyY2VwdGlvblxuICAgIG1haW5fd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG86IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmICgvc3luYyg/OlxcL3VcXC9cXGQrKT9cXC9pXFwvYnYvLnRlc3QoY29ubmVjdGlvbi51cmwpKSB7XG4gICAgICAgICAgaWYgKGN1c3RvbUxpc3RKb2IpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIG9sZCBvbmUgd2l0aCBzb21ldGhpbmcgYmVjYXVzZSBubyBvbmUgZWxzZSBpcyBnb2luZ1xuICAgICAgICAgICAgLy8gdG8gYWZ0ZXIgaXQncyByZXBsYWNlZCBpbiBhIG1vbWVudC5cbiAgICAgICAgICAgIGN1c3RvbUxpc3RKb2IubmV3UmVxdWVzdFBhcmFtcy5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcXVlcnk6IGN1c3RvbUxpc3RKb2IucXVlcnksXG4gICAgICAgICAgICAgIHN0YXJ0OiBjdXN0b21MaXN0Sm9iLnN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXN0b21MaXN0Sm9iLm5ld1Jlc3VsdHMucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0Q2hhbmdlcjogYXN5bmMgZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3QuYm9keSk7XG4gICAgICAgICAgY29uc3QgbmV3Rm9ybWF0ID0gQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KTtcbiAgICAgICAgICAvLyB3ZSBhcmUgYSBzZWFyY2ghXG4gICAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPVxuICAgICAgICAgICAgKG5ld0Zvcm1hdFxuICAgICAgICAgICAgICA/IHBhcnNlZEJvZHkgJiYgcGFyc2VkQm9keVswXSAmJiBwYXJzZWRCb2R5WzBdWzNdXG4gICAgICAgICAgICAgIDogcGFyc2VkQm9keSAmJiBwYXJzZWRCb2R5WzFdICYmIHBhcnNlZEJvZHlbMV1bNF0pIHx8ICcnO1xuXG4gICAgICAgICAgaWYgKGZpbmQoY3VzdG9tU2VhcmNoUXVlcmllcywgKHgpID0+IHggPT09IHNlYXJjaFF1ZXJ5KSkge1xuICAgICAgICAgICAgY3VzdG9tTGlzdEpvYiA9IChjb25uZWN0aW9uIGFzIGFueSkuX2N1c3RvbUxpc3RKb2IgPSB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBzZWFyY2hRdWVyeSxcbiAgICAgICAgICAgICAgc3RhcnQ6IG5ld0Zvcm1hdCA/IHBhcnNlZEJvZHlbMF1bOV0gOiBwYXJzZWRCb2R5WzFdWzEwXSxcbiAgICAgICAgICAgICAgbmV3UmVxdWVzdFBhcmFtczogZGVmZXIoKSxcbiAgICAgICAgICAgICAgbmV3UmVzdWx0czogZGVmZXIoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAnc2VhcmNoRm9yUmVwbGFjZW1lbnQnLFxuICAgICAgICAgICAgICBxdWVyeTogY3VzdG9tTGlzdEpvYi5xdWVyeSxcbiAgICAgICAgICAgICAgc3RhcnQ6IGN1c3RvbUxpc3RKb2Iuc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24gYXMgYW55XG4gICAgICAgICAgICApLl9jdXN0b21MaXN0Sm9iLm5ld1JlcXVlc3RQYXJhbXMucHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgICAoeyBxdWVyeSwgc3RhcnQgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkQm9keVswXVszXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgcGFyc2VkQm9keVswXVs5XSA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWRCb2R5WzFdWzRdID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICBwYXJzZWRCb2R5WzFdWzEwXSA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcnNlZEJvZHkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVGV4dENoYW5nZXI6IGFzeW5jIGZ1bmN0aW9uIChjb25uZWN0aW9uLCByZXNwb25zZSkge1xuICAgICAgICBpZiAoKGNvbm5lY3Rpb24gYXMgYW55KS5fY3VzdG9tTGlzdEpvYikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnc2VhcmNoUmVzdWx0c1Jlc3BvbnNlJyxcbiAgICAgICAgICAgIHF1ZXJ5OiAoY29ubmVjdGlvbiBhcyBhbnkpLl9jdXN0b21MaXN0Sm9iLnF1ZXJ5LFxuICAgICAgICAgICAgc3RhcnQ6IChjb25uZWN0aW9uIGFzIGFueSkuX2N1c3RvbUxpc3RKb2Iuc3RhcnQsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gKGNvbm5lY3Rpb24gYXMgYW55KS5fY3VzdG9tTGlzdEpvYi5uZXdSZXN1bHRzLnByb21pc2UudGhlbihcbiAgICAgICAgICAgIChuZXdSZXN1bHRzOiBhbnkpID0+IChuZXdSZXN1bHRzID09PSBudWxsID8gcmVzcG9uc2UgOiBuZXdSZXN1bHRzKSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICAvLyBzeW5jIHRva2VuIHNhdmVyc1xuICB7XG4gICAgY29uc3Qgc2F2ZUJUQUlIZWFkZXIgPSAoaGVhZGVyOiBzdHJpbmcpID0+IHtcbiAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLWJ0YWktaGVhZGVyJywgaGVhZGVyKTtcbiAgICAgIHRyaWdnZXJFdmVudCh7XG4gICAgICAgIHR5cGU6ICdidGFpSGVhZGVyUmVjZWl2ZWQnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIG1haW5fd3JhcHBlcnMucHVzaCh7XG4gICAgICBpc1JlbGV2YW50VG8oY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC9zeW5jKD86XFwvdVxcL1xcZCspP1xcLy8udGVzdChjb25uZWN0aW9uLnVybCkgJiZcbiAgICAgICAgICAhKGRvY3VtZW50LmhlYWQgYXMgYW55KS5oYXNBdHRyaWJ1dGUoJ2RhdGEtaW5ib3hzZGstYnRhaS1oZWFkZXInKVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgb3JpZ2luYWxTZW5kQm9keUxvZ2dlcihjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmhlYWRlcnNbJ1gtR21haWwtQlRBSSddKSB7XG4gICAgICAgICAgc2F2ZUJUQUlIZWFkZXIoY29ubmVjdGlvbi5oZWFkZXJzWydYLUdtYWlsLUJUQUknXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzYXZlWHNyZlRva2VuSGVhZGVyID0gKGhlYWRlcjogc3RyaW5nKSA9PiB7XG4gICAgICBkb2N1bWVudC5oZWFkLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmJveHNkay14c3JmLXRva2VuJywgaGVhZGVyKTtcbiAgICAgIHRyaWdnZXJFdmVudCh7XG4gICAgICAgIHR5cGU6ICd4c3JmVG9rZW5IZWFkZXJSZWNlaXZlZCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbWFpbl93cmFwcGVycy5wdXNoKHtcbiAgICAgIGlzUmVsZXZhbnRUbyhjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgL3N5bmMoPzpcXC91XFwvXFxkKyk/XFwvLy50ZXN0KGNvbm5lY3Rpb24udXJsKSAmJlxuICAgICAgICAgICEoZG9jdW1lbnQuaGVhZCBhcyBhbnkpLmhhc0F0dHJpYnV0ZSgnZGF0YS1pbmJveHNkay14c3JmLXRva2VuJylcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsU2VuZEJvZHlMb2dnZXIoY29ubmVjdGlvbikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbi5oZWFkZXJzWydYLUZyYW1ld29yay1Yc3JmLVRva2VuJ10pIHtcbiAgICAgICAgICBzYXZlWHNyZlRva2VuSGVhZGVyKGNvbm5lY3Rpb24uaGVhZGVyc1snWC1GcmFtZXdvcmstWHNyZi1Ub2tlbiddKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdvb2dsZSBBUEkgcmVxdWVzdCBoZWFkZXIgdmFsdWVzXG4gIHtcbiAgICAvLyBoYXJjb2RpbmcgYSB2YWx1ZSBvYnNlcnZlZCBhY3Jvc3MgbXVsdGlwbGUgYWNjb3VudHMgdG8gc3RhcnQgd2l0aC5cbiAgICAvLyBXaWxsIGJlIHVwZGF0ZWQgd2hlbiB3ZSBzZWUgYSByZXF1ZXN0LCBpbiBjYXNlIEdtYWlsIGhhcyBjaGFuZ2VkIGl0LlxuICAgIGxldCBnb29nbGVBcGlLZXkgPSAnQUl6YVN5Qm03YURNRzlhY3RzV1NseC1NdnJZc2Vwd2RuTGd6NjlJJztcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2luYm94U0RLZ2V0R29vZ2xlUmVxdWVzdEhlYWRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBhdXRob3JpemF0aW9uSGVhZGVyID0gKFxuICAgICAgICB3aW5kb3cgYXMgYW55XG4gICAgICApLmdhcGkuYXV0aC5nZXRBdXRoSGVhZGVyVmFsdWVGb3JGaXJzdFBhcnR5KFtdKTtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIGF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgICd4LWdvb2ctYXBpLWtleSc6IGdvb2dsZUFwaUtleSxcbiAgICAgIH07XG4gICAgICBkb2N1bWVudC5oZWFkLnNldEF0dHJpYnV0ZShcbiAgICAgICAgJ2RhdGEtaW5ib3hzZGstZ29vZ2xlLWhlYWRlcnMnLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShoZWFkZXJzKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBtYWluX3dyYXBwZXJzLnB1c2goe1xuICAgICAgaXNSZWxldmFudFRvKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFic29sdXRlIFVSTHMgZ29pbmcgdG8gYSBnb29nbGUgZG9tYWluXG4gICAgICAgIGlmIChjb25uZWN0aW9uLnVybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChjb25uZWN0aW9uLnVybCk7XG4gICAgICAgICAgcmV0dXJuIHVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmdvb2dsZS5jb20nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbFNlbmRCb2R5TG9nZ2VyKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uaGVhZGVyc1snWC1Hb29nLUFwaS1LZXknXSkge1xuICAgICAgICAgIGdvb2dsZUFwaUtleSA9IGNvbm5lY3Rpb24uaGVhZGVyc1snWC1Hb29nLUFwaS1LZXknXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZGV0YWlsOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgbmV3IEN1c3RvbUV2ZW50KCdpbmJveFNES2FqYXhJbnRlcmNlcHQnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBkZXRhaWwsXG4gICAgfSksXG4gICk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbXBvc2VQYXJhbXMoaW5Db21wb3NlUGFyYW1zOiB7XG4gIHRvPzogc3RyaW5nO1xuICBjYz86IHN0cmluZztcbiAgYmNjPzogc3RyaW5nO1xufSkge1xuICBjb25zdCBjb21wb3NlUGFyYW1zID0gY2xvbmUoaW5Db21wb3NlUGFyYW1zKTtcbiAgY29uc3Qgc3RyaW5nID0gYD0ke3N0cmluZ2lmeUNvbXBvc2VSZWNpcGllbnRQYXJhbShcbiAgICBjb21wb3NlUGFyYW1zLnRvISxcbiAgICAndG8nLFxuICApfSY9JHtzdHJpbmdpZnlDb21wb3NlUmVjaXBpZW50UGFyYW0oXG4gICAgY29tcG9zZVBhcmFtcy5jYyEsXG4gICAgJ2NjJyxcbiAgKX0mPSR7c3RyaW5naWZ5Q29tcG9zZVJlY2lwaWVudFBhcmFtKGNvbXBvc2VQYXJhbXMuYmNjISwgJ2JjYycpfWA7XG4gIGRlbGV0ZSBjb21wb3NlUGFyYW1zLnRvO1xuICBkZWxldGUgY29tcG9zZVBhcmFtcy5iY2M7XG4gIGRlbGV0ZSBjb21wb3NlUGFyYW1zLmNjO1xuICByZXR1cm4gc3RyaW5nICsgJyYnICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGNvbXBvc2VQYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDb21wb3NlUmVjaXBpZW50UGFyYW0oXG4gIHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgcGFyYW1UeXBlOiBzdHJpbmcsXG4pIHtcbiAgbGV0IHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCB2YWx1ZS5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHN0cmluZyArPSBgJiR7cGFyYW1UeXBlfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtpaV0pfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmluZyArPSBgJiR7cGFyYW1UeXBlfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59XG4iLCJkZWNsYXJlIGdsb2JhbCB7XG4gIHZhciBnbW9ua2V5OiBhbnkgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwR21vbmtleUhhbmRsZXIoKSB7XG4gIGNvbnN0IGdtb25rZXlQcm9taXNlID0gc2V0dXBHbW9ua2V5KCk7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAnaW5ib3hTREt0ZWxsTWVJc0NvbnZlcnNhdGlvblZpZXdEaXNhYmxlZCcsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgZ21vbmtleVByb21pc2UudGhlbigoZ21vbmtleTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGdtb25rZXkuaXNDb252ZXJzYXRpb25WaWV3RGlzYWJsZWQoKTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KCdpbmJveFNES2dtb25rZXlSZXNwb25zZScsIGZhbHNlLCBmYWxzZSwgYW5zd2VyKTtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuICApO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgJ2luYm94U0RLdGVsbE1lQ3VycmVudFRocmVhZElkJyxcbiAgICBmdW5jdGlvbiAoZXZlbnQ6IGFueSkge1xuICAgICAgbGV0IHRocmVhZElkO1xuXG4gICAgICBpZiAoZXZlbnQuZGV0YWlsLmlzUHJldmlld2VkVGhyZWFkKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tnaD10bF0gdHIuYXBzJykpO1xuICAgICAgICBpZiAocm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudFdpdGhJZCA9IHJvd3NcbiAgICAgICAgICAgIC5tYXAoKHJvdykgPT4gcm93LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXRocmVhZC1pZF0nKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilbMF07XG4gICAgICAgICAgaWYgKGVsZW1lbnRXaXRoSWQpIHtcbiAgICAgICAgICAgIHRocmVhZElkID0gZWxlbWVudFdpdGhJZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhyZWFkLWlkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVhZElkID0gcm93c1swXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5ib3hzZGstdGhyZWFkaWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocmVhZElkID0gd2luZG93Lmdtb25rZXk/LnYyPy5nZXRDdXJyZW50VGhyZWFkPy4oKT8uZ2V0VGhyZWFkSWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRocmVhZElkKSB7XG4gICAgICAgIC8vIGhhc2ggaXMgaW5jbHVkZWQgaW4gdGhlIHN5bmMgaWQgcm91dGUgdXJsLCBzbyB3ZSBhbHNvIG5lZWQgdG8gdGFrZSBpdCBvdXRcbiAgICAgICAgdGhyZWFkSWQgPSB0aHJlYWRJZC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICBldmVudC50YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLWN1cnJlbnR0aHJlYWRpZCcsIHRocmVhZElkKTtcbiAgICAgIH1cbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiBzZXR1cEdtb25rZXkoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgaWYgKCF3aW5kb3cuZ21vbmtleSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCA1MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93Lmdtb25rZXkubG9hZCgnMi4wJywgcmVzb2x2ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoZWNrKCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycjogRXJyb3IgfCB1bmtub3duLCBkZXRhaWxzPzogYW55KSB7XG4gIGlmICghZXJyKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKCdObyBlcnJvciBnaXZlbicpO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGluamVjdGVkIHNjcmlwdCcsIGVyciwgZGV0YWlscyk7XG4gIHRyeSB7XG4gICAgSlNPTi5zdHJpbmdpZnkoZGV0YWlscyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZXRhaWxzID0gJzxmYWlsZWQgdG8ganNvbmlmeT4nO1xuICB9XG5cbiAgY29uc3QgZXJyb3JQcm9wZXJ0aWVzOiBhbnkgPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGVyciBhcyBhbnkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgbmFtZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKGVyciBhcyBhbnkpW25hbWVdO1xuICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGVycm9yUHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXMoZXJyb3JQcm9wZXJ0aWVzKS5sZW5ndGggPiAwKSB7XG4gICAgZGV0YWlscyA9IHsgZXJyb3JQcm9wZXJ0aWVzLCBkZXRhaWxzIH07XG4gIH1cblxuICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgIG5ldyBDdXN0b21FdmVudCgnaW5ib3hTREtpbmplY3RlZEVycm9yJywge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBtZXNzYWdlOiBlcnIgJiYgKGVyciBhcyBhbnkpLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnIgJiYgKGVyciBhcyBhbnkpLnN0YWNrLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50U2RrUGFzc2l2ZShcbiAgbmFtZTogc3RyaW5nLFxuICBkZXRhaWxzPzogYW55LFxuICBzZW5zaXRpdmU/OiBib29sZWFuLFxuKSB7XG4gIHRyeSB7XG4gICAgSlNPTi5zdHJpbmdpZnkoZGV0YWlscyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZXRhaWxzID0gJzxmYWlsZWQgdG8ganNvbmlmeT4nO1xuICB9XG5cbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICBuZXcgQ3VzdG9tRXZlbnQoJ2luYm94U0RLaW5qZWN0ZWRFdmVudFNka1Bhc3NpdmUnLCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgZGV0YWlsOiB7IG5hbWUsIGRldGFpbHMsIHNlbnNpdGl2ZSB9LFxuICAgIH0pLFxuICApO1xufVxuIiwiZXhwb3J0IGNsYXNzIFdhaXRGb3JFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9ICdXYWl0Rm9yRXJyb3InO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignd2FpdEZvciB0aW1lb3V0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gY29uZGl0aW9uIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSB0byB3YWl0IGZvciwgb3IgZmFsc2V5IGlmIGl0J3Mgbm90IHJlYWR5IHlldFxuICogQHRocm93cyB7V2FpdEZvckVycm9yfSBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQgd2l0aGluIHRoZSB0aW1lb3V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhaXRGb3I8VD4oXG4gIGNvbmRpdGlvbjogKCkgPT4gVCB8IG51bGwgfCB1bmRlZmluZWQsXG4gIHRpbWVvdXQ6IG51bWJlciA9IDEyMCAqIDEwMDAsXG4gIHN0ZXB0aW1lOiBudW1iZXIgPSAyNTAsXG4pOiBQcm9taXNlPE5vbk51bGxhYmxlPFQ+PiB7XG4gIC8vIG1ha2UgdGhpcyBlcnJvciBoZXJlIHNvIHdlIGhhdmUgYSBzZW5zaWJsZSBzdGFjay5cbiAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IFdhaXRGb3JFcnJvcigpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IHdhaXRlZCA9IDA7XG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmRpdGlvbigpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3YWl0ZWQgPj0gdGltZW91dCkge1xuICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhaXRlZCArPSBzdGVwdGltZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc3RlcCwgc3RlcHRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoc3RlcCwgMSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4vaW5qZWN0ZWQtbG9nZ2VyJztcbmltcG9ydCB3YWl0Rm9yIGZyb20gJy4uL3BsYXRmb3JtLWltcGxlbWVudGF0aW9uLWpzL2xpYi93YWl0LWZvcic7XG5cbmZ1bmN0aW9uIHN0dXBpZFRvQm9vbChzdHVwaWQ6IGFueSk6IGJvb2xlYW4ge1xuICBzd2l0Y2ggKCcnICsgc3R1cGlkKSB7XG4gICAgY2FzZSAnMSc6XG4gICAgY2FzZSAndCc6XG4gICAgY2FzZSAndHJ1ZSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0dGluZ1ZhbHVlKHNldHRpbmdzOiBhbnlbXSwgbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHZhciBlbnRyeSA9IGZpbmQoc2V0dGluZ3MsIChzZXR0aW5nKSA9PiBzZXR0aW5nWzBdID09PSBuYW1lKTtcbiAgcmV0dXJuIGVudHJ5ID8gc3R1cGlkVG9Cb29sKGVudHJ5WzFdKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICB0eXBlIENvbnRleHQgPSB7XG4gICAgR0xPQkFMUzogYW55W107XG4gICAgZ2JhcjogeyBfQ09ORklHOiBhbnlbXSB9O1xuICB9O1xuICBsZXQgY29udGV4dCA9IGdsb2JhbCBhcyB1bmtub3duIGFzIENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICAvLyBvdXIgY3VycmVudCB0YWIgaGFzIGdsb2JhbHMgZGVmaW5lZFxuICAgIGlmIChjb250ZXh0LkdMT0JBTFMpIHJldHVybiBjb250ZXh0O1xuXG4gICAgLy8gd2UgZG9uJ3QsIGxldCdzIHNlZSBpZiB3ZSBoYXZlIGFjY2VzcyB0byBvcGVuZXIgKGkuZS4gd2UgYXJlIGEgbmV3IGNvbXBvc2UvdGhyZWFkIHZpZXcpXG4gICAgaWYgKGdsb2JhbC5vcGVuZXIgJiYgZ2xvYmFsLm9wZW5lci50b3ApIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgaHJlZlxuICAgICAgLy8gaWYgdGhlIG9wZW5lciBpcyBub3QgZ21haWwgKGkuZS4geW91IGNsaWNrZWQgb24gYSBtYWlsdG8gbGluayBvbiBjcmFpZ3NsaXN0KSB0aGVuIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAgZ2xvYmFsLm9wZW5lci50b3AubG9jYXRpb24uaHJlZjtcbiAgICAgIGNvbnRleHQgPSBnbG9iYWwub3BlbmVyLnRvcDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnRleHQgPSBnbG9iYWwgYXMgdW5rbm93biBhcyBDb250ZXh0OyAvL3dlIGdvdCBhbiBlcnJvciBmcm9tIHJlcXVlc3RpbmcgZ2xvYmFsLm9wZW5lci50b3AubG9jYXRpb24uaHJlZjtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cERhdGFFeHBvc2VyKCkge1xuICBsZXQgY29udGV4dDogYW55O1xuICB3YWl0Rm9yKCgpID0+IHtcbiAgICBjb250ZXh0ID0gZ2V0Q29udGV4dCgpO1xuICAgIHJldHVybiBjb250ZXh0ICYmIChjb250ZXh0LkdMT0JBTFMgfHwgY29udGV4dC5nYmFyKTtcbiAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcbiAgICAgIHZhciB1c2VyRW1haWwgPSBjb250ZXh0LkdMT0JBTFNcbiAgICAgICAgPyBjb250ZXh0LkdMT0JBTFNbMTBdXG4gICAgICAgIDogY29udGV4dC5nYmFyLl9DT05GSUdbMF1bMTBdWzVdO1xuICAgICAgZG9jdW1lbnQuaGVhZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5ib3hzZGstdXNlci1lbWFpbC1hZGRyZXNzJywgdXNlckVtYWlsKTtcbiAgICAgIHZhciB1c2VyTGFuZ3VhZ2U6IHN0cmluZyA9IGNvbnRleHQuR0xPQkFMU1xuICAgICAgICA/IGNvbnRleHQuR0xPQkFMU1s0XS5zcGxpdCgnLicpWzFdXG4gICAgICAgIDogY29udGV4dC5nYmFyLl9DT05GSUdbMF1bMF1bNF07XG4gICAgICBkb2N1bWVudC5oZWFkLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmJveHNkay11c2VyLWxhbmd1YWdlJywgdXNlckxhbmd1YWdlKTtcbiAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKFxuICAgICAgICAnZGF0YS1pbmJveHNkay11c2luZy1zeW5jLWFwaScsXG4gICAgICAgIGNvbnRleHQuR01fU1BUX0VOQUJMRUQsXG4gICAgICApO1xuXG4gICAgICBpZiAoY29udGV4dC5HTE9CQUxTKSB7XG4gICAgICAgIC8vIEdtYWlsXG4gICAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICdkYXRhLWluYm94c2RrLWlrLXZhbHVlJyxcbiAgICAgICAgICBjb250ZXh0LkdMT0JBTFNbOV0sXG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICdkYXRhLWluYm94c2RrLWFjdGlvbi10b2tlbi12YWx1ZScsXG4gICAgICAgICAgY29udGV4dC5HTV9BQ1RJT05fVE9LRU4sXG4gICAgICAgICk7XG4gICAgICAgIHZhciBnbG9iYWxTZXR0aW5nc0hvbGRlciA9IGZpbmQoXG4gICAgICAgICAgY29udGV4dC5HTE9CQUxTWzE3XSxcbiAgICAgICAgICAoaXRlbSkgPT4gaXRlbVswXSA9PT0gJ3AnLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghZ2xvYmFsU2V0dGluZ3NIb2xkZXIpIHtcbiAgICAgICAgICAvLyBnbG9iYWwgc2V0dGluZ3MgZG9lc24ndCBleGlzdCBvbiBnbWFpbCB2Miwgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2cgdGhpcyBhbnltb3JlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBnbG9iYWxTZXR0aW5ncyA9IGdsb2JhbFNldHRpbmdzSG9sZGVyWzFdO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3UGFuZUxhYkVuYWJsZWQgPSBnZXRTZXR0aW5nVmFsdWUoXG4gICAgICAgICAgICAgIGdsb2JhbFNldHRpbmdzLFxuICAgICAgICAgICAgICAnYnhfbGFiXzEyNTInLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3UGFuZUVuYWJsZWQgPSBnZXRTZXR0aW5nVmFsdWUoZ2xvYmFsU2V0dGluZ3MsICdieF9zcGEnKTtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3UGFuZVZlcnRpY2FsID0gZ2V0U2V0dGluZ1ZhbHVlKGdsb2JhbFNldHRpbmdzLCAnYnhfc3BvJyk7XG4gICAgICAgICAgICB2YXIgcHJldmlld1BhbmVNb2RlID1cbiAgICAgICAgICAgICAgcHJldmlld1BhbmVMYWJFbmFibGVkICYmIHByZXZpZXdQYW5lRW5hYmxlZFxuICAgICAgICAgICAgICAgID8gcHJldmlld1BhbmVWZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgPyAndmVydGljYWwnXG4gICAgICAgICAgICAgICAgICA6ICdob3Jpem9udGFsJ1xuICAgICAgICAgICAgICAgIDogJ25vbmUnO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICdkYXRhLWluYm94c2RrLXVzZXItcHJldmlldy1wYW5lLW1vZGUnLFxuICAgICAgICAgICAgICBwcmV2aWV3UGFuZU1vZGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5ib3hcbiAgICAgICAgY29uc3QgcHJlbG9hZERhdGFTZWFyY2hTdHJpbmcgPSAnd2luZG93LkJUX0VtYmVkZGVkQXBwRGF0YT1bJztcbiAgICAgICAgY29uc3QgcHJlbG9hZFNjcmlwdCA9IGZpbmQoXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MU2NyaXB0RWxlbWVudD4oJ3NjcmlwdDpub3QoW3NyY10pJyksXG4gICAgICAgICAgKHNjcmlwdCkgPT5cbiAgICAgICAgICAgIHNjcmlwdC50ZXh0ICYmXG4gICAgICAgICAgICBzY3JpcHQudGV4dC5zbGljZSgwLCA1MDApLmluZGV4T2YocHJlbG9hZERhdGFTZWFyY2hTdHJpbmcpID4gLTEsXG4gICAgICAgICkgYXMgSFRNTFNjcmlwdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFwcmVsb2FkU2NyaXB0KSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVhZCBwcmVsb2FkZWQgQlRfRW1iZWRkZWRBcHBEYXRhJyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB7IHRleHQgfSA9IHByZWxvYWRTY3JpcHQ7XG4gICAgICAgICAgY29uc3QgZmlyc3RCcmFja2V0ID0gdGV4dC5pbmRleE9mKCd3aW5kb3cuQlRfRW1iZWRkZWRBcHBEYXRhPVsnKTtcbiAgICAgICAgICBsZXQgbGFzdEJyYWNrZXQgPSB0ZXh0LmluZGV4T2YoJ11cXG47JywgZmlyc3RCcmFja2V0KTtcblxuICAgICAgICAgIGlmIChsYXN0QnJhY2tldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEkgaGF2ZSBvbmx5IHNlZW4gdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgYSBuZXcgbGluZSBiZXR3ZWVuIHRoZVxuICAgICAgICAgICAgLy8gY2xvc2luZyBicmFja2V0IGFuZCB0aGUgc2VtaWNvbG9uLCBidXQgd2FudCB0byBiZSBkZWZlbnNpdmUgaW5cbiAgICAgICAgICAgIC8vIGNhc2UgdGhhdCBjaGFuZ2VzLlxuICAgICAgICAgICAgbGFzdEJyYWNrZXQgPSB0ZXh0LmluZGV4T2YoJ107JywgZmlyc3RCcmFja2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmVsb2FkRGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICB0ZXh0LnNsaWNlKFxuICAgICAgICAgICAgICBmaXJzdEJyYWNrZXQgKyBwcmVsb2FkRGF0YVNlYXJjaFN0cmluZy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBsYXN0QnJhY2tldCArIDEsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgaWtWYWx1ZSA9IHByZWxvYWREYXRhWzExXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaWtWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHZhbGlkIGlrVmFsdWUnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLWlrLXZhbHVlJywgaWtWYWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeHNyZlRva2VuID0gcHJlbG9hZERhdGFbMTJdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB4c3JmVG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB2YWxpZCB4c3JmVG9rZW4nKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLXhzcmYtdG9rZW4nLCB4c3JmVG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNHTE9CQUxTOiAhIWNvbnRleHQuR0xPQkFMUyxcbiAgICAgICAgICBoYXNHYmFyOiAhIWNvbnRleHQuZ2JhcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0U3RhdHVzID0gZ2V0U3RhdHVzKCk7XG4gICAgICB2YXIgd2FpdFRpbWUgPSAxODAgKiAxMDAwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBsYXRlclN0YXR1cyA9IGdldFN0YXR1cygpO1xuICAgICAgICBsb2dnZXIuZXZlbnRTZGtQYXNzaXZlKCd3YWl0Zm9yIGdsb2JhbCBkYXRhJywge1xuICAgICAgICAgIHN0YXJ0U3RhdHVzLFxuICAgICAgICAgIHdhaXRUaW1lLFxuICAgICAgICAgIGxhdGVyU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICAgIH0sIHdhaXRUaW1lKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KVxuICAgIC5jYXRjaChsb2dnZXIuZXJyb3IpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBFcnJvclNpbGVuY2VyKCkge1xuICB2YXIgb2xkRXJyb3JIYW5kbGVyczogT25FcnJvckV2ZW50SGFuZGxlcltdID0gW107XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2luYm94U0RLc2lsZW5jZVBhZ2VFcnJvcnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgb2xkRXJyb3JIYW5kbGVycy5wdXNoKHdpbmRvdy5vbmVycm9yKTtcblxuICAgIHdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyhTaWxlbmNlZCBpbiBwcm9kdWN0aW9uKSBQYWdlIGVycm9yOicsIC4uLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5ib3hTREt1bnNpbGVuY2VQYWdlRXJyb3JzJywgZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5vbmVycm9yID0gb2xkRXJyb3JIYW5kbGVycy5wb3AoKSE7XG4gIH0pO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEV2ZW50UmVlbWl0dGVyKCkge1xuICAvLyBXZWJraXQgaGFzIGJ1Z3MgdGhhdCBzdG9wIGNlcnRhaW4gdHlwZXMgb2YgZXZlbnRzIGZyb20gYmVpbmcgY3JlYXRlZC4gV2VcbiAgLy8gY2FuIG1hbnVhbGx5IGZha2UgY3JlYXRpb24gb2YgdGhvc2UgZXZlbnRzLCBidXQgd2UgaGF2ZSB0byBkbyBpdCBmcm9tXG4gIC8vIGluc2lkZSB0aGUgcGFnZSdzIHNjcmlwdCBpZiB3ZSB3YW50IHRoZSBwYWdlJ3Mgc2NyaXB0IHRvIHNlZSB0aGUgbW9kaWZpZWRcbiAgLy8gcHJvcGVydGllcy5cbiAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE2NzM1XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMjc4NTNcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAnaW5ib3hzZGtfZXZlbnRfcmVsYXknLFxuICAgIGZ1bmN0aW9uIChldmVudDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgY29uc3QgbmV3RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAobmV3RXZlbnQgYXMgYW55KS5pbml0RXZlbnQoXG4gICAgICAgIGV2ZW50LmRldGFpbC50eXBlLFxuICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyxcbiAgICAgICAgZXZlbnQuZGV0YWlsLmNhbmNlbGFibGUsXG4gICAgICApO1xuICAgICAgT2JqZWN0LmFzc2lnbihuZXdFdmVudCwgZXZlbnQuZGV0YWlsLnByb3BzKTtcbiAgICAgIGlmIChldmVudC5kZXRhaWwuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgZmlsZXMsIGZpbGVOYW1lcyB9ID0gZXZlbnQuZGV0YWlsLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgaWYgKGZpbGVOYW1lcykge1xuICAgICAgICAgIGZpbGVOYW1lcy5mb3JFYWNoKChmaWxlTmFtZTogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAobmV3RXZlbnQgYXMgYW55KS5kYXRhVHJhbnNmZXIgPSB7XG4gICAgICAgICAgZHJvcEVmZmVjdDogJ25vbmUnLFxuICAgICAgICAgIGVmZmVjdEFsbG93ZWQ6ICdhbGwnLFxuICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgIGl0ZW1zOiBmaWxlcy5tYXAoKHsgdHlwZSB9OiBhbnksIGk6IG51bWJlcikgPT4gKHtcbiAgICAgICAgICAgIGtpbmQ6ICdmaWxlJyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnZXRBc0ZpbGUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlc1tpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRBc1N0cmluZygpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRBc1N0cmluZyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICB0eXBlczogWydGaWxlcyddLFxuICAgICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXREYXRhKCkge30sXG4gICAgICAgICAgc2V0RHJhZ0ltYWdlKCkge30sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBldmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfSxcbiAgKTtcbn1cbiIsImltcG9ydCB7IGRlZm4gfSBmcm9tICd1ZCc7XG5pbXBvcnQgaW5jbHVkZXMgZnJvbSAnbG9kYXNoL2luY2x1ZGVzJztcbmltcG9ydCBjbG9zZXN0IGZyb20gJ2Nsb3Nlc3QtbmcnO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4vaW5qZWN0ZWQtbG9nZ2VyJztcblxuZnVuY3Rpb24gbWQ8VD4odmFsdWU6IFQpOiB7IHZhbHVlOiBUOyBjb25maWd1cmFibGU6IGJvb2xlYW4gfSB7XG4gIHJldHVybiB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfTtcbn1cblxuLy8gVGhlc2UgYXJlIGJhc2ljYWxseSBhbGwgdGhlIGtleXMgdGhhdCB0cmlnZ2VyIHNvbWUgYWN0aW9uIGluIHRocmVhZCBsaXN0XG4vLyB2aWV3cyBhbmQgdGhyZWFkIHZpZXdzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBiZSB0cmlnZ2VyYWJsZSB3aGlsZSBhIGN1c3RvbVxuLy8gdmlldyBpcyBvcGVuLiBLZXkgY29tYm9zIHdoaWNoIGFmZmVjdCB0aGluZ3Mgc3RpbGwgdmlzaWJsZSBvbiB0aGUgc2NyZWVuIG9yXG4vLyBuYXZpZ2F0ZSB0byBhIG5ldyB2aWV3IGFyZSBzdGlsbCBhbGxvd2VkLlxuXG5jb25zdCBibG9ja2VkQW55TW9kS2V5cyA9IFtcbiAgJ0Fycm93TGVmdCcsXG4gICdBcnJvd1JpZ2h0JyxcbiAgJ0Fycm93VXAnLFxuICAnQXJyb3dEb3duJyxcbiAgJ1BhZ2VVcCcsXG4gICdQYWdlRG93bicsXG4gICdIb21lJyxcbiAgJ0VuZCcsXG4gICdFbnRlcicsXG5dO1xuXG4vLyBUaGVzZSBhcmUgb25seSBuZWNlc3NhcnkgZm9yIFNhZmFyaVxuY29uc3QgYmxvY2tlZEtleUlkZW50aWZpZXJzID0gWydMZWZ0JywgJ1JpZ2h0JywgJ1VwJywgJ0Rvd24nXTtcblxuY29uc3QgYmxvY2tlZEFueU1vZENoYXJhY3RlcnMgPSAnISNbXXt9Xys9LTs6XFxyXFxuMTIzNDU2Nzg5MGB+JztcbmNvbnN0IGJsb2NrZWROb01vZENoYXJhY3RlcnMgPSAnLHhzeWVtcmFmei51amtwbmwnO1xuY29uc3QgYmxvY2tlZFNoaWZ0Q2hhcmFjdGVycyA9ICdwYXJmbml1dCc7XG5cbmZ1bmN0aW9uIHNob3VsZEJsb2NrRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiBib29sZWFuIHtcbiAgaWYgKCFkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnaW5ib3hzZGtfX2N1c3RvbV92aWV3X2FjdGl2ZScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gIGNvbnN0IGtleSA9XG4gICAgZXZlbnQua2V5IHx8IC8qIHNhZmFyaSovIFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSk7XG5cbiAgLy8gQmxvY2sgYWxsIGVzY2FwZSBrZXkgcHJlc3NlcyBpbnNpZGUgYSBjdXN0b20gdmlldywgZXZlbiB3aGVuIGFuIGlucHV0XG4gIC8vIGlzIGZvY3VzZWQuXG4gIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnICYmIGNsb3Nlc3QodGFyZ2V0LCAnLmluYm94c2RrX19jdXN0b21fdmlldycpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoXG4gICAgaW5jbHVkZXMoYmxvY2tlZEFueU1vZEtleXMsIGtleSkgfHxcbiAgICAvKiBzYWZhcmkgKi8gaW5jbHVkZXMoXG4gICAgICBibG9ja2VkS2V5SWRlbnRpZmllcnMsXG4gICAgICAoZXZlbnQgYXMgYW55KS5rZXlJZGVudGlmaWVyLFxuICAgICkgfHxcbiAgICBpbmNsdWRlcyhibG9ja2VkQW55TW9kQ2hhcmFjdGVycywga2V5KSB8fFxuICAgICghZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICFldmVudC5jdHJsS2V5ICYmXG4gICAgICAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgIWV2ZW50LmFsdEtleSAmJlxuICAgICAgaW5jbHVkZXMoYmxvY2tlZE5vTW9kQ2hhcmFjdGVycywga2V5KSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICFldmVudC5jdHJsS2V5ICYmXG4gICAgICAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgIWV2ZW50LmFsdEtleSAmJlxuICAgICAgaW5jbHVkZXMoYmxvY2tlZFNoaWZ0Q2hhcmFjdGVycywga2V5LnRvTG93ZXJDYXNlKCkpKVxuICApIHtcbiAgICBpZiAoXG4gICAgICAvLyBHbWFpbCBhbHJlYWR5IGlnbm9yZXMgZXZlbnRzIG9yaWdpbmF0aW5nIGluIHRoZXNlIGVsZW1lbnRzIGV2ZW4gaWZcbiAgICAgIC8vIHRoZXkgd2VyZSBtYWRlIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgIGNsb3Nlc3QodGFyZ2V0LCAnaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIFtjb250ZW50ZWRpdGFibGVdJykgfHxcbiAgICAgIC8vIEdtYWlsIGlnbm9yZXMgZXZlbnRzIG9yaWdpbmF0aW5nIGluIGl0cyBvd24gaW50ZXJhY3RpdmUgZWxlbWVudHNcbiAgICAgIC8vIHdoaWNoIHRlbmQgdG8gaGF2ZSBjZXJ0YWluIHJvbGUgYXR0cmlidXRlcy5cbiAgICAgICghY2xvc2VzdCh0YXJnZXQsICcuaW5ib3hzZGtfX2N1c3RvbV92aWV3JykgJiZcbiAgICAgICAgY2xvc2VzdCh0YXJnZXQsICdbcm9sZT1idXR0b25dLCBbcm9sZT1saW5rXScpKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBoYW5kbGVyID0gZGVmbihtb2R1bGUsIGZ1bmN0aW9uIChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICB0cnkge1xuICAgIC8vIElmIHRoZSBrZXkgaXMgaW4gYSBibGFja2xpc3QgYW5kIGl0IG9yaWdpbmF0ZWQgd2hpbGUgYSBjdXN0b20gdmlldyBpc1xuICAgIC8vIHByZXNlbnQsIHRoZW4gbWFpbSB0aGUgZXZlbnQgb2JqZWN0IGJlZm9yZSBHbWFpbCBvciBJbmJveCBzZWVzIGl0LlxuICAgIGlmIChzaG91bGRCbG9ja0V2ZW50KGV2ZW50KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHtcbiAgICAgICAgYWx0S2V5OiBtZChmYWxzZSksXG4gICAgICAgIGN0cmxLZXk6IG1kKGZhbHNlKSxcbiAgICAgICAgc2hpZnRLZXk6IG1kKGZhbHNlKSxcbiAgICAgICAgbWV0YUtleTogbWQoZmFsc2UpLFxuXG4gICAgICAgIGNoYXJDb2RlOiBtZCg5MiksXG4gICAgICAgIGNvZGU6IG1kKCdCYWNrc2xhc2gnKSxcbiAgICAgICAga2V5OiBtZCgnXFxcXCcpLFxuICAgICAgICBrZXlDb2RlOiBtZCg5MiksXG4gICAgICAgIHdoaWNoOiBtZCg5MiksXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBDdXN0b21WaWV3RXZlbnRBc3Nhc3NpbigpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIsIHRydWUpO1xufVxuIiwiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnY2xvc2VzdC1uZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEluYm94Q3VzdG9tVmlld0xpbmtGaXhlcigpIHtcbiAgY29uc3QgYWxsb3dlZFN0YXJ0VGVybXMgPSBuZXcgU2V0KCk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgJ2luYm94U0RLcmVnaXN0ZXJBbGxvd2VkSGFzaExpbmtTdGFydFRlcm0nLFxuICAgIGZ1bmN0aW9uIChldmVudDogRXZlbnQpIHtcbiAgICAgIGNvbnN0IHRlcm0gPSAoZXZlbnQgYXMgYW55KS5kZXRhaWwudGVybTtcbiAgICAgIGFsbG93ZWRTdGFydFRlcm1zLmFkZCh0ZXJtKTtcbiAgICB9LFxuICApO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICdjbGljaycsXG4gICAgZnVuY3Rpb24gKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGNsb3Nlc3QodGFyZ2V0LCAnYVtocmVmXj1cIiNcIl0nKTtcbiAgICAgIGlmICghYW5jaG9yIHx8ICEoYW5jaG9yIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpKSByZXR1cm47XG4gICAgICBjb25zdCBtID0gL14jKFteL10rKS8uZXhlYyhhbmNob3IuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJycpO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICBjb25zdCBzdGFydFRlcm0gPSBtWzFdO1xuICAgICAgaWYgKCFhbGxvd2VkU3RhcnRUZXJtcy5oYXMoc3RhcnRUZXJtKSkgcmV0dXJuO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICAoZXZlbnQgYXMgYW55KS5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHt9O1xuICAgIH0sXG4gICAgdHJ1ZSxcbiAgKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwUHVzaFN0YXRlTGlzdGVuZXIoKSB7XG4gIGNvbnN0IG9yaWdQdXNoU3RhdGUgPSBoaXN0b3J5LnB1c2hTdGF0ZTtcblxuICBoaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0gb3JpZ1B1c2hTdGF0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdpbmJveFNES3B1c2hTdGF0ZScsIHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBhcmdzLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24geGhySGVscGVyKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdpbmJveFNES3BhZ2VBamF4JywgZnVuY3Rpb24gKGV2ZW50OiBhbnkpIHtcbiAgICBjb25zdCBpZCA9IGV2ZW50LmRldGFpbC5pZDtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdXJsOiBldmVudC5kZXRhaWwudXJsLFxuICAgICAgbWV0aG9kOiBldmVudC5kZXRhaWwubWV0aG9kLFxuICAgICAgaGVhZGVyczogZXZlbnQuZGV0YWlsLmhlYWRlcnMsXG4gICAgICB4aHJGaWVsZHM6IGV2ZW50LmRldGFpbC54aHJGaWVsZHMsXG4gICAgICBkYXRhOiBldmVudC5kZXRhaWwuZGF0YSxcbiAgICB9O1xuXG4gICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXNlIGZldGNoIHdoZW4gcG9zc2libGUgYmVjYXVzZSBpdCdzIG5lZWRlZCBmb3JcbiAgICAvLyBnZXREb3dubG9hZFVSTCgpIGluIEdtYWlsIHYyOiBHbWFpbCB2MidzIFNlcnZpY2VXb3JrZXIgaW4gQ2hyb21lIGNhdXNlc1xuICAgIC8vIHhoci5yZXNwb25zZVVSTCB0byBoYXZlIHRoZSB3cm9uZyB2YWx1ZSAocG9zc2libHkgYSBDaHJvbWUgYnVnKS5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChvcHRzLnVybCwge1xuICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ2luYm94U0RLcGFnZUFqYXhEb25lJywge1xuICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiBhd2FpdCByZXNwb25zZS50ZXh0KCksXG4gICAgICAgICAgICByZXNwb25zZVVSTDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgnaW5ib3hTREtwYWdlQWpheERvbmUnLCB7XG4gICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGVycm9yOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyICYmIGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVyciAmJiBlcnIuc3RhY2ssXG4gICAgICAgICAgICBzdGF0dXM6IGVyciAmJiBlcnIueGhyICYmIGVyci54aHIuc3RhdHVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgZmxhdHRlbiBmcm9tICdsb2Rhc2gvZmxhdHRlbic7XG5pbXBvcnQgbGFzdCBmcm9tICdsb2Rhc2gvbGFzdCc7XG5pbXBvcnQgdCBmcm9tICd0cmFuc2R1Y2Vycy5qcyc7XG5pbXBvcnQgbWFwSW5kZXhlZCBmcm9tICdtYXAtaW5kZXhlZC14Zic7XG5pbXBvcnQgaHRtbFRvVGV4dCBmcm9tICcuLi8uLi8uLi9jb21tb24vaHRtbC10by10ZXh0JztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9hc3NlcnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwcmV0U2VudEVtYWlsUmVzcG9uc2UocmVzcG9uc2VTdHJpbmc6IHN0cmluZyk6IHtcbiAgdGhyZWFkSUQ6IHN0cmluZztcbiAgbWVzc2FnZUlEOiBzdHJpbmc7XG59IHtcbiAgY29uc3QgZW1haWxTZW50QXJyYXkgPSBkZXNlcmlhbGl6ZShyZXNwb25zZVN0cmluZykudmFsdWU7XG5cbiAgY29uc3QgZ21haWxNZXNzYWdlSWQgPSBleHRyYWN0R21haWxNZXNzYWdlSWRGcm9tU2VudEVtYWlsKGVtYWlsU2VudEFycmF5KTtcbiAgY29uc3QgZ21haWxUaHJlYWRJZCA9XG4gICAgZXh0cmFjdEdtYWlsVGhyZWFkSWRGcm9tU2VudEVtYWlsKGVtYWlsU2VudEFycmF5KSB8fCBnbWFpbE1lc3NhZ2VJZDtcbiAgaWYgKCFnbWFpbE1lc3NhZ2VJZCB8fCAhZ21haWxUaHJlYWRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZW1haWwgcmVzcG9uc2UnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRocmVhZElEOiBnbWFpbFRocmVhZElkLFxuICAgIG1lc3NhZ2VJRDogZ21haWxNZXNzYWdlSWQsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0R21haWxNZXNzYWdlSWRGcm9tU2VudEVtYWlsKFxuICBlbWFpbFNlbnRBcnJheTogYW55LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IG1lc3NhZ2VJZEFycmF5TWFya2VyID0gJ2EnO1xuICBjb25zdCBtZXNzYWdlSWRBcnJheSA9IF9zZWFyY2hBcnJheShcbiAgICBlbWFpbFNlbnRBcnJheSxcbiAgICBtZXNzYWdlSWRBcnJheU1hcmtlcixcbiAgICAobWFya2VyQXJyYXkpID0+XG4gICAgICBtYXJrZXJBcnJheS5sZW5ndGggPiAzICYmXG4gICAgICBBcnJheS5pc0FycmF5KG1hcmtlckFycmF5WzNdKSAmJlxuICAgICAgbWFya2VyQXJyYXlbM10ubGVuZ3RoID4gMCxcbiAgKTtcblxuICBpZiAoIW1lc3NhZ2VJZEFycmF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZUlkQXJyYXlbM11bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0R21haWxUaHJlYWRJZEZyb21TZW50RW1haWwoXG4gIGVtYWlsU2VudEFycmF5OiBhbnksXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgdGhyZWFkSWRBcnJheU1hcmtlciA9ICdjc2QnO1xuICBjb25zdCB0aHJlYWRJZEFycmF5ID0gX3NlYXJjaEFycmF5KFxuICAgIGVtYWlsU2VudEFycmF5LFxuICAgIHRocmVhZElkQXJyYXlNYXJrZXIsXG4gICAgZnVuY3Rpb24gKG1hcmtlckFycmF5KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtYXJrZXJBcnJheS5sZW5ndGggPT0gMyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG1hcmtlckFycmF5WzJdKSAmJlxuICAgICAgICBtYXJrZXJBcnJheVsyXS5sZW5ndGggPiA1XG4gICAgICApO1xuICAgIH0sXG4gICk7XG5cbiAgaWYgKCF0aHJlYWRJZEFycmF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhyZWFkSWRBcnJheVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RHbWFpbFRocmVhZElkRnJvbU1lc3NhZ2VJZFNlYXJjaChcbiAgcmVzcG9uc2VTdHJpbmc6IHN0cmluZyxcbik6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCB0aHJlYWRSZXNwb25zZUFycmF5ID0gZGVzZXJpYWxpemUocmVzcG9uc2VTdHJpbmcpLnZhbHVlO1xuICBjb25zdCB0aHJlYWRJZEFycmF5TWFya2VyID0gJ2NzJztcbiAgY29uc3QgdGhyZWFkSWRBcnJheSA9IF9zZWFyY2hBcnJheShcbiAgICB0aHJlYWRSZXNwb25zZUFycmF5LFxuICAgIHRocmVhZElkQXJyYXlNYXJrZXIsXG4gICAgKG1hcmtlckFycmF5KSA9PiBtYXJrZXJBcnJheVswXSA9PT0gJ2NzJyAmJiBtYXJrZXJBcnJheS5sZW5ndGggPiAyMCxcbiAgKTtcblxuICBpZiAoIXRocmVhZElkQXJyYXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aHJlYWRJZEFycmF5WzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZVNpbmdsZVF1b3RlcyhzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBUaGUgaW5wdXQgc3RyaW5nIGNvbnRhaW5zIHVucXVvdGVkLCBkb3VibGUtcXVvdGVkLCBhbmQgc2luZ2xlLXF1b3RlZFxuICAvLyBwYXJ0cy4gUGFyc2UgdGhlIHN0cmluZyBmb3IgdGhlc2UgcGFydHMsIGFuZCB0cmFuc2Zvcm0gdGhlIHNpbmdsZS1cbiAgLy8gcXVvdGVkIHBhcnQgaW50byBhIGRvdWJsZS1xdW90ZWQgcGFydCBieSBzd2FwcGluZyB0aGUgcXVvdGVzLCBhbmRcbiAgLy8gZXNjYXBpbmcgYW55IGRvdWJsZS1xdW90ZXMgaW5zaWRlIG9mIGl0IHdpdGggYmFja3NsYXNoZXMuXG5cbiAgLy8gaSBpcyBvdXIgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmluZy4gcmVzdWx0IGlzIG91ciByZXN1bHQgc3RyaW5nIHRoYXRcbiAgLy8gd2UnbGwgY29weSB0aGUgcGFydHMgb2YgdGhlIGlucHV0IHRvIGFzIHdlIGludGVycHJldCB0aGVtLlxuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHJlc3VsdFBhcnRzID0gW107XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCBzaW5nbHkgb3IgZG91Ymx5IHF1b3RlZCBwYXJ0LlxuICAgIC8vIGBpYCBpcyBpbmNyZWFzaW5nIG1vbm90b25pY2FsbHkgZXZlcnkgcm91bmQgb2YgdGhpcyBsb29wLCBhbmQgdGhlIGxvb3BcbiAgICAvLyBlbmRzIGFzIHNvb24gYXMgbm8gbWF0Y2hlcyBhcmUgZm91bmQgYWZ0ZXIgdGhlIGBpYHRoIHBvc2l0aW9uIGluIHRoZVxuICAgIC8vIHN0cmluZywgc28gdGhpcyB3aGlsZSBsb29wIGNhbid0IGJlIGluZmluaXRlLlxuICAgIGNvbnN0IG5leHRRdW90ZUluZGV4ID0gZmluZE5leHRRdW90ZShzLCBpKTtcbiAgICBpZiAobmV4dFF1b3RlSW5kZXggPCAwKSB7XG4gICAgICByZXN1bHRQYXJ0cy5wdXNoKHMuc3Vic3RyKGkpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBDb3B5IHRoZSB1bnF1b3RlZCBwYXJ0IHByZWNlZGluZyB0aGUgcXVvdGVkIHNlY3Rpb24gd2UgZm91bmQgaW50byB0aGVcbiAgICAvLyByZXN1bHQsIGFuZCBwdXQgYSBkb3VibGUtcXVvdGUgaW50byB0aGUgcmVzdWx0IHRvIGJlZ2luIHRoZSBxdW90ZWRcbiAgICAvLyBzZWN0aW9uIHdlIGZvdW5kLlxuICAgIHJlc3VsdFBhcnRzLnB1c2gocy5zdWJzdHIoaSwgbmV4dFF1b3RlSW5kZXggLSBpKSk7XG4gICAgcmVzdWx0UGFydHMucHVzaCgnXCInKTtcbiAgICBpID0gbmV4dFF1b3RlSW5kZXggKyAxO1xuICAgIGlmIChzW25leHRRdW90ZUluZGV4XSA9PT0gJ1wiJykge1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBxdW90YXRpb24gbWFyayBub3QgcHJlY2VkZWQgYnkgYSBiYWNrc2xhc2guXG4gICAgICBjb25zdCBuZXh0RG91YmxlUXVvdGVJbmRleCA9IGZpbmROZXh0VW5lc2NhcGVkQ2hhcmFjdGVyKHMsIGksICdcIicpO1xuICAgICAgaWYgKG5leHREb3VibGVRdW90ZUluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIGRvdWJsZSBxdW90ZScpO1xuICAgICAgfVxuICAgICAgLy8gQWRkIHRoYXQgZW50aXJlIGRvdWJsZS1xdW90ZWQgcGFydCB0byB0aGUgcmVzdWx0LlxuICAgICAgcmVzdWx0UGFydHMucHVzaChzLnNsaWNlKGksIG5leHREb3VibGVRdW90ZUluZGV4ICsgMSkpO1xuICAgICAgaSA9IG5leHREb3VibGVRdW90ZUluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2FtZSBsb2dpYyBhcyBhYm92ZSwgYnV0IGZvciBhIHNpbmdsZS1xdW90ZWQgcGFydC5cbiAgICAgIGNvbnN0IG5leHRTaW5nbGVRdW90ZUluZGV4ID0gZmluZE5leHRVbmVzY2FwZWRDaGFyYWN0ZXIocywgaSwgXCInXCIpO1xuICAgICAgaWYgKG5leHRTaW5nbGVRdW90ZUluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNpbmdsZSBxdW90ZScpO1xuICAgICAgfVxuICAgICAgLy8gRXNjYXBlIGFsbCBkb3VibGUtcXVvdGVzIGluc2lkZSB0aGUgcGFydCwgdW4tZXNjYXBlIGFsbCBzaW5nbGUtcXVvdGVzXG4gICAgICAvLyBpbnNpZGUgdGhlIHBhcnQsIGFuZCB0aGVuIHdyaXRlIGl0IG91dCBpbnRvIHRoZSByZXN1bHQgd2l0aCB0aGUgZW5kaW5nXG4gICAgICAvLyBzaW5nbGUtcXVvdGUgcmVwbGFjZWQgd2l0aCBhIGRvdWJsZS1xdW90ZS5cbiAgICAgIGNvbnN0IHBhcnQgPSBzXG4gICAgICAgIC5zbGljZShpLCBuZXh0U2luZ2xlUXVvdGVJbmRleClcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxuICAgICAgICAucmVwbGFjZSgvXFxcXCcvZywgXCInXCIpO1xuICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgIHJlc3VsdFBhcnRzLnB1c2goJ1wiJyk7XG4gICAgICBpID0gbmV4dFNpbmdsZVF1b3RlSW5kZXggKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0UGFydHMuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0UXVvdGUoczogc3RyaW5nLCBzdGFydDogbnVtYmVyKTogbnVtYmVyIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBsZW4gPSBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHNbaV0gPT09ICdcIicgfHwgc1tpXSA9PT0gXCInXCIpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0VW5lc2NhcGVkQ2hhcmFjdGVyKFxuICBzOiBzdHJpbmcsXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGNoYXI6IHN0cmluZyxcbik6IG51bWJlciB7XG4gIGZvciAobGV0IGkgPSBzdGFydCwgbGVuID0gcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzW2ldID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHNbaV0gPT09IGNoYXIpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZU9wdGlvbnMge1xuICBpbmNsdWRlTGVuZ3RoczogYm9vbGVhbjtcbiAgc3VnZ2VzdGlvbk1vZGU6IGJvb2xlYW47XG4gIG5vQXJyYXlOZXdMaW5lczogYm9vbGVhbjtcbiAgaW5jbHVkZUV4cGxpY2l0TnVsbHM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZSh0aHJlYWRSZXNwb25zZVN0cmluZzogc3RyaW5nKToge1xuICB2YWx1ZTogYW55W107XG4gIG9wdGlvbnM6IE1lc3NhZ2VPcHRpb25zO1xufSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUxlbmd0aHM6IGZhbHNlLFxuICAgIHN1Z2dlc3Rpb25Nb2RlOiAvXjVcXG4vLnRlc3QodGhyZWFkUmVzcG9uc2VTdHJpbmcpLFxuICAgIG5vQXJyYXlOZXdMaW5lczogIS9eWyxcXF1dL20udGVzdCh0aHJlYWRSZXNwb25zZVN0cmluZyksXG4gICAgaW5jbHVkZUV4cGxpY2l0TnVsbHM6IHRydWUsXG4gIH07XG5cbiAgY29uc3QgdmFsdWUgPSBbXTtcblxuICBsZXQgcG9zO1xuICBpZiAob3B0aW9ucy5zdWdnZXN0aW9uTW9kZSkge1xuICAgIHBvcyA9IHRocmVhZFJlc3BvbnNlU3RyaW5nLmluZGV4T2YoXCInXFxuXCIpO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2Ugd2FzIG1pc3NpbmcgYmVnaW5uaW5nIGhlYWRlcicpO1xuICAgIH1cbiAgICBwb3MgKz0gMjtcbiAgfSBlbHNlIHtcbiAgICBwb3MgPSB0aHJlYWRSZXNwb25zZVN0cmluZy5pbmRleE9mKCdcXG5cXG4nKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIHdhcyBtaXNzaW5nIGJlZ2lubmluZyBuZXdsaW5lcycpO1xuICAgIH1cbiAgICBwb3MgKz0gMjtcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCB0aHJlYWRSZXNwb25zZVN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbGluZUVuZCA9IHRocmVhZFJlc3BvbnNlU3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvcyArIDEpO1xuICAgIGlmIChsaW5lRW5kID09PSAtMSkge1xuICAgICAgbGluZUVuZCA9IHRocmVhZFJlc3BvbnNlU3RyaW5nLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHRocmVhZFJlc3BvbnNlU3RyaW5nW2xpbmVFbmQgLSAxXSA9PT0gJ1xccicpIHtcbiAgICAgIC8vIHNlcmlvdXNseSBHbWFpbCBpcyBjcmF6eS4gVGhlIGNodW5rIGxlbmd0aCBvbmx5IHNvbWV0aW1lcyBpbmNsdWRlcyB0aGVcbiAgICAgIC8vIG5ld2xpbmUgYWZ0ZXIgdGhlIGNodW5rIGxlbmd0aC5cbiAgICAgIGxpbmVFbmQgKz0gMTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lID0gdGhyZWFkUmVzcG9uc2VTdHJpbmcuc2xpY2UocG9zLCBsaW5lRW5kKTtcbiAgICBsZXQgZGF0YUxpbmU7XG4gICAgaWYgKC9eXFxkK1xccyokLy50ZXN0KGxpbmUpKSB7XG4gICAgICBvcHRpb25zLmluY2x1ZGVMZW5ndGhzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9ICtsaW5lO1xuICAgICAgZGF0YUxpbmUgPSB0aHJlYWRSZXNwb25zZVN0cmluZy5zbGljZShsaW5lRW5kLCBsaW5lRW5kICsgbGVuZ3RoKTtcbiAgICAgIHBvcyA9IGxpbmVFbmQgKyBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMaW5lID0gdGhyZWFkUmVzcG9uc2VTdHJpbmcuc2xpY2UocG9zKTtcbiAgICAgIHBvcyA9IHRocmVhZFJlc3BvbnNlU3RyaW5nLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YWx1ZS5wdXNoKGRlc2VyaWFsaXplQXJyYXkoZGF0YUxpbmUpKTtcbiAgfVxuXG4gIHJldHVybiB7IHZhbHVlLCBvcHRpb25zIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVVucXVvdGVkU2VjdGlvbnMoXG4gIHN0cjogc3RyaW5nLFxuICBjYjogKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBsZXQgbmV4dFF1b3RlO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBsZXQgaW5TdHJpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKChuZXh0UXVvdGUgPSBmaW5kTmV4dFVuZXNjYXBlZENoYXJhY3RlcihzdHIsIHBvc2l0aW9uLCAnXCInKSkgIT09IC0xKSB7XG4gICAgaWYgKGluU3RyaW5nKSB7XG4gICAgICBwYXJ0cy5wdXNoKHN0ci5zbGljZShwb3NpdGlvbiwgbmV4dFF1b3RlICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKGNiKHN0ci5zbGljZShwb3NpdGlvbiwgbmV4dFF1b3RlICsgMSkpKTtcbiAgICB9XG4gICAgcG9zaXRpb24gPSBuZXh0UXVvdGUgKyAxO1xuICAgIGluU3RyaW5nID0gIWluU3RyaW5nO1xuICB9XG4gIGlmIChpblN0cmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGVuZGVkIGluc2lkZSBxdW90ZWQgc2VjdGlvbicpO1xuICB9XG4gIHBhcnRzLnB1c2goY2Ioc3RyLnNsaWNlKHBvc2l0aW9uKSkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUFycmF5KHZhbHVlOiBzdHJpbmcpOiBhbnlbXSB7XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW1xcclxcblxcdF0vZywgJycpO1xuXG4gIC8vIENoYW5nZSBhbGwgdGhlIHNpbmdseSBxdW90ZWQgcGFydHMgdG8gdXNlIGRvdWJsZS1xdW90ZXMgc28gdGhhdCB0aGVcbiAgLy8gZGF0YSBjYW4gYmUgSlNPTi1kZWNvZGVkIGluc3RlYWQgb2YgZXZhbCdkLiAoQWxzbyBuZWNlc3NhcnkgZm9yIHRoZVxuICAvLyBuZXh0IHN0ZXAuKVxuICB2YWx1ZSA9IHJld3JpdGVTaW5nbGVRdW90ZXModmFsdWUpO1xuXG4gIC8vIEZpeCBzb21lIHRoaW5ncyB3aXRoIHRoZSBkYXRhLiAoSXQncyBpbiBhIHdlaXJkIG1pbmlmaWVkIEpTT04tbGlrZVxuICAvLyBmb3JtYXQpLiBNYWtlIHN1cmUgd2UgZG9uJ3QgbW9kaWZ5IGFueSBkYXRhIGluc2lkZSBvZiBzdHJpbmdzIVxuICB2YWx1ZSA9IHRyYW5zZm9ybVVucXVvdGVkU2VjdGlvbnMoXG4gICAgdmFsdWUsXG4gICAgKG1hdGNoKSA9PlxuICAgICAgbWF0Y2hcbiAgICAgICAgLnJlcGxhY2UoLyxcXHMqKD89LHxcXF0pL2csICcsbnVsbCcpIC8vIGZpeCBpbXBsaWVkIG51bGxzXG4gICAgICAgIC5yZXBsYWNlKC9cXFtcXHMqKD89LCkvZywgJ1tudWxsJyksIC8vIFwiXG4gICk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSwgKGssIHYpID0+ICh2ID09IG51bGwgPyB1bmRlZmluZWQgOiB2KSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVzZXJpYWxpemF0aW9uIGVycm9yJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZTogYW55W10sIG9wdGlvbnM6IE1lc3NhZ2VPcHRpb25zKTogc3RyaW5nIHtcbiAgaWYgKG9wdGlvbnMuc3VnZ2VzdGlvbk1vZGUpIHtcbiAgICBhc3NlcnQob3B0aW9ucy5pbmNsdWRlTGVuZ3Rocyk7XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25TZXJpYWxpemUodmFsdWUsIG9wdGlvbnMuaW5jbHVkZUV4cGxpY2l0TnVsbHMpO1xuICB9XG4gIHJldHVybiB0aHJlYWRMaXN0U2VyaWFsaXplKHZhbHVlLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdGhyZWFkTGlzdFNlcmlhbGl6ZShcbiAgdGhyZWFkUmVzcG9uc2VBcnJheTogYW55W10sXG4gIG9wdGlvbnM6IE1lc3NhZ2VPcHRpb25zLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBpbmNsdWRlTGVuZ3Rocywgbm9BcnJheU5ld0xpbmVzLCBpbmNsdWRlRXhwbGljaXROdWxscyB9ID0gb3B0aW9ucztcblxuICBsZXQgcmVzcG9uc2UgPSBcIildfSdcXG5cIiArIChub0FycmF5TmV3TGluZXMgJiYgaW5jbHVkZUxlbmd0aHMgPyAnJyA6ICdcXG4nKTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHRocmVhZFJlc3BvbnNlQXJyYXkubGVuZ3RoOyBpaSsrKSB7XG4gICAgY29uc3QgYXJyYXlTZWN0aW9uID0gdGhyZWFkUmVzcG9uc2VBcnJheVtpaV07XG4gICAgY29uc3QgYXJyYXlTZWN0aW9uU3RyaW5nID0gc2VyaWFsaXplQXJyYXkoXG4gICAgICBhcnJheVNlY3Rpb24sXG4gICAgICBub0FycmF5TmV3TGluZXMsXG4gICAgICBpbmNsdWRlRXhwbGljaXROdWxscyxcbiAgICApO1xuXG4gICAgaWYgKCFpbmNsdWRlTGVuZ3Rocykge1xuICAgICAgcmVzcG9uc2UgKz0gYXJyYXlTZWN0aW9uU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBhcnJheVNlY3Rpb25TdHJpbmcubGVuZ3RoICsgKG5vQXJyYXlOZXdMaW5lcyA/IDIgOiAxKTtcbiAgICAgIHJlc3BvbnNlICs9XG4gICAgICAgIChub0FycmF5TmV3TGluZXMgPyAnXFxuJyA6ICcnKSArIGxlbmd0aCArICdcXG4nICsgYXJyYXlTZWN0aW9uU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaW5jbHVkZUxlbmd0aHMpIHtcbiAgICBpZiAoIW5vQXJyYXlOZXdMaW5lcykge1xuICAgICAgY29uc3QgbGluZXMgPSByZXNwb25zZS5zcGxpdCgvXFxyfFxcbi8pO1xuICAgICAgY29uc3QgZmlyc3RMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0zKTtcbiAgICAgIGNvbnN0IGxhc3RMaW5lcyA9IGxpbmVzLnNsaWNlKC0zKTtcbiAgICAgIHJlc3BvbnNlID0gZmlyc3RMaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgIHJlc3BvbnNlICs9ICdcXG4nICsgbGFzdExpbmVzWzBdICsgbGFzdExpbmVzWzFdLnJlcGxhY2UoL1wiL2csIFwiJ1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQSAxNi1kaWdpdCBoZXhhZGVjaW1hbCBzdHJpbmcgaXMgb2Z0ZW4gYXQgdGhlIGVuZCwgYnV0IHNvbWV0aW1lcyBpdFxuICAgICAgLy8gaGFzIGZld2VyIGRpZ2l0cy5cbiAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UucmVwbGFjZSgvXCIoWzAtOWEtZl17OCwxNn0pXCJcXF0kLywgXCInJDEnXVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UgKyAobm9BcnJheU5ld0xpbmVzICYmIGluY2x1ZGVMZW5ndGhzID8gJ1xcbicgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIHN1Z2dlc3Rpb25TZXJpYWxpemUoXG4gIHN1Z2dlc3Rpb25zQXJyYXk6IGFueVtdLFxuICBpbmNsdWRlRXhwbGljaXROdWxsczogYm9vbGVhbixcbik6IHN0cmluZyB7XG4gIGxldCByZXNwb25zZSA9IFwiNVxcbildfSdcXG5cIjtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHN1Z2dlc3Rpb25zQXJyYXkubGVuZ3RoOyBpaSsrKSB7XG4gICAgY29uc3QgYXJyYXlTZWN0aW9uID0gc3VnZ2VzdGlvbnNBcnJheVtpaV07XG4gICAgY29uc3QgYXJyYXlTZWN0aW9uU3RyaW5nID0gc2VyaWFsaXplQXJyYXkoXG4gICAgICBhcnJheVNlY3Rpb24sXG4gICAgICBmYWxzZSxcbiAgICAgIGluY2x1ZGVFeHBsaWNpdE51bGxzLFxuICAgICk7XG5cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheVNlY3Rpb25TdHJpbmcubGVuZ3RoO1xuICAgIHJlc3BvbnNlICs9IGxlbmd0aCArICdcXHJcXG4nICsgYXJyYXlTZWN0aW9uU3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVBcnJheShcbiAgYXJyYXk6IGFueVtdLFxuICBub0FycmF5TmV3TGluZXM6IGJvb2xlYW4sXG4gIGluY2x1ZGVFeHBsaWNpdE51bGxzOiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgbGV0IHJlc3BvbnNlID0gJ1snO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyYXkubGVuZ3RoOyBpaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGFycmF5W2lpXTtcblxuICAgIGxldCBhZGRpdGlvbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgYWRkaXRpb24gPSBzZXJpYWxpemVBcnJheShpdGVtLCBub0FycmF5TmV3TGluZXMsIGluY2x1ZGVFeHBsaWNpdE51bGxzKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgYWRkaXRpb24gPSBpbmNsdWRlRXhwbGljaXROdWxscyA/ICdudWxsJyA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRpdGlvbiA9IEpTT04uc3RyaW5naWZ5KGl0ZW0pXG4gICAgICAgIC5yZXBsYWNlKC88L2dpbSwgJ1xcXFx1MDAzYycpXG4gICAgICAgIC5yZXBsYWNlKC89L2dpbSwgJ1xcXFx1MDAzZCcpXG4gICAgICAgIC5yZXBsYWNlKC8+L2dpbSwgJ1xcXFx1MDAzZScpXG4gICAgICAgIC5yZXBsYWNlKC8mL2dpbSwgJ1xcXFx1MDAyNicpO1xuICAgIH1cblxuICAgIGlmIChpaSA+IDApIHtcbiAgICAgIHJlc3BvbnNlICs9ICcsJztcbiAgICB9XG4gICAgcmVzcG9uc2UgKz0gYWRkaXRpb247XG4gIH1cblxuICByZXNwb25zZSArPSAnXScgKyAobm9BcnJheU5ld0xpbmVzID8gJycgOiAnXFxuJyk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gIHN1YmplY3Q6IHN0cmluZztcbiAgc2hvcnREYXRlOiBzdHJpbmc7XG4gIHRpbWVTdHJpbmc6IHN0cmluZztcbiAgcGVvcGxlSHRtbDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgaXNVbnJlYWQ6IGJvb2xlYW47XG4gIGxhc3RFbWFpbEFkZHJlc3M6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIGJvZHlQcmV2aWV3SHRtbDogc3RyaW5nO1xuICBzb21lR21haWxNZXNzYWdlSWRzOiBzdHJpbmdbXTtcbiAgZ21haWxUaHJlYWRJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZERyYWZ0SWQoXG4gIHJlc3BvbnNlOiBzdHJpbmcsXG4gIG1lc3NhZ2VJRDogc3RyaW5nLFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGRlY29kZWQgPSBkZXNlcmlhbGl6ZShyZXNwb25zZSkudmFsdWU7XG5cbiAgY29uc3QgbXNnQSA9IHQudG9BcnJheShcbiAgICBkZWNvZGVkLFxuICAgIHQuY29tcG9zZShcbiAgICAgIHQuY2F0LFxuICAgICAgdC5maWx0ZXIoQXJyYXkuaXNBcnJheSksXG4gICAgICB0LmNhdCxcbiAgICAgIHQuZmlsdGVyKCh4OiBhbnkpID0+IHhbMF0gPT09ICdtcycgJiYgeFsxXSA9PT0gbWVzc2FnZUlEKSxcbiAgICAgIHQudGFrZSgxKSxcbiAgICAgIHQubWFwKCh4OiBhbnkpID0+IHhbNjBdKSxcbiAgICApLFxuICApWzBdIGFzIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIGlmIChtc2dBKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBtc2dBLm1hdGNoKC9ebXNnLVteOl06KFxcUyspJC9pKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVGhyZWFkc0luUmVzcG9uc2UoXG4gIHJlc3BvbnNlOiBzdHJpbmcsXG4gIHJlcGxhY2VtZW50VGhyZWFkczogVGhyZWFkW10sXG4gIHsgc3RhcnQsIHRvdGFsIH06IHsgc3RhcnQ6IG51bWJlcjsgdG90YWw/OiBudW1iZXIgfCAnTUFOWScgfSxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgdmFsdWUsIG9wdGlvbnMgfSA9IGRlc2VyaWFsaXplKHJlc3BvbnNlKTtcblxuICBjb25zdCBhY3Rpb25SZXNwb25zZU1vZGUgPVxuICAgIHZhbHVlLmxlbmd0aCA9PT0gMSAmJlxuICAgIHZhbHVlWzBdLmxlbmd0aCA9PT0gMiAmJlxuICAgIHR5cGVvZiB2YWx1ZVswXVsxXSA9PT0gJ3N0cmluZyc7XG4gIGNvbnN0IHRocmVhZFZhbHVlID0gYWN0aW9uUmVzcG9uc2VNb2RlXG4gICAgPyB2YWx1ZVswXVswXS5tYXAoKHg6IGFueSkgPT4gW3hdKVxuICAgIDogdmFsdWU7XG5cbiAgLypcbnRocmVhZFZhbHVlIGxvb2tzIGxpa2UgdGhpczpcbltcbiAgWyAvLyBncm91cFxuICAgIFtcImJsYWhcIiwgLi4uXSwgLy8gaXRlbVxuICAgIFtcImJsYWhcIiwgLi4uXSAgLy8gaXRlbVxuICBdLFxuICBbIC8vIGdyb3VwXG4gICAgW1wiYmxhaFwiLCAuLi5dLFxuICAgIFtcInRiXCIsIFsuLi5dXSxcbiAgICBbXCJ0YlwiLCBbLi4uXV1cbiAgXSxcbiAgW1xuICAgIFtcInRiXCIsIFsuLi5dXSxcbiAgICBbXCJibGFoXCIsIC4uLl1cbiAgXSxcbiAgW1xuICAgIFtcImJsYWhcIiwgLi4uXSxcbiAgICBbXCJibGFoXCIsIC4uLl1cbiAgXSxcbl1cblxudGhyZWFkVmFsdWUgaXMgYW4gYXJyYXkgb2YgZ3JvdXBzLiBFYWNoIGdyb3VwIGlzIGFuIGFycmF5IG9mIGl0ZW1zLiBBbiBpdGVtIGlzXG5hbiBhcnJheSB3aGljaCBoYXMgYW4gaWRlbnRpZmllciBzdHJpbmcgYXMgaXRzIGZpcnN0IGl0ZW0uIEVhY2ggXCJ0YlwiIGl0ZW1cbmNvbnRhaW5zIGFuIGFycmF5IG9mIHVwIHRvIDEwIHRocmVhZHMuIEFsbCBvZiB0aGUgXCJ0YlwiIGl0ZW1zIHdpbGwgYmUgc2VxdWVudGlhbFxuYnV0IG1heSBvdmVyZmxvdyB0byBvdGhlciBncm91cHMuXG5cbldlIHdhbnQgdG8gcmVwbGFjZSBhbGwgb2YgdGhlIFwidGJcIiBpdGVtcywgd2hpbGUgdHJ5aW5nIHRvIHN0aWNrIGNsb3NlIHRvIHRoZVxub3JpZ2luYWwgc3RydWN0dXJlLiBXZSBwcmVwYXJlIGJ5IGNyZWF0aW5nIGFuIGFycmF5IG9mIGdyb3VwcyB0aGF0IGNvbWUgYmVmb3JlXG5hbnkgZ3JvdXBzIGNvbnRhaW5pbmcgYSBcInRiXCIgaXRlbSwgYW4gYXJyYXkgb2YgZ3JvdXBzIHRoYXQgY29tZSBhZnRlciBhbnlcbmdyb3VwcyBjb250YWluaW5nIGEgXCJ0YlwiIGl0ZW0sIGFuIGFycmF5IG9mIGl0ZW1zIHRoYXQgY29tZSBiZWZvcmUgYW55IFwidGJcIlxuaXRlbXMgaW4gdGhlIGZpcnN0IFwidGJcIiBncm91cCwgYW5kIGFuIGFycmF5IG9mIGl0ZW1zIHRoYXQgY29tZSBhZnRlciBhbnkgXCJ0YlwiXG5pdGVtcyBpbiB0aGUgbGFzdCBcInRiXCIgZ3JvdXAuIFRoZW4gd2UgZ2VuZXJhdGUgdGhlIG5ldyBcInRiXCIgaXRlbXMsIGFuZCBzcGxpY2Vcbml0IGFsbCBiYWNrIHRvZ2V0aGVyLlxuXG4qL1xuXG4gIGNvbnN0IHByZVRiR3JvdXBzOiBhbnlbXSA9IFtdO1xuICBjb25zdCBwb3N0VGJHcm91cHM6IGFueVtdID0gW107XG4gIGxldCBwcmVUYkl0ZW1zOiBhbnlbXSA9IFtdO1xuICBsZXQgcG9zdFRiSXRlbXM6IGFueVtdID0gW107XG5cbiAgbGV0IGhhc1NlZW5UYiA9IGZhbHNlO1xuICB0aHJlYWRWYWx1ZS5mb3JFYWNoKChncm91cDogYW55KSA9PiB7XG4gICAgbGV0IHRiU2VlbkluVGhpc0dyb3VwID0gZmFsc2U7XG4gICAgY29uc3QgcHJlVGJHcm91cDogYW55W10gPSBbXTtcbiAgICBjb25zdCBwb3N0VGJHcm91cDogYW55W10gPSBbXTtcbiAgICBncm91cC5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICAgIGlmICh0b3RhbCAmJiBpdGVtWzBdID09PSAndGknKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gZG9lcyBub3Qgc3dpdGNoIG91dCBvZiAnbWFueSctdG90YWwgbW9kZSAod2UgY3VycmVudGx5IG5ldmVyIG5lZWQgdGhpcykuXG4gICAgICAgICAgaXRlbVsyXSA9IGl0ZW1bMTBdID0gdG90YWw7XG4gICAgICAgIH0gZWxzZSBpZiAodG90YWwgPT09ICdNQU5ZJykge1xuICAgICAgICAgIC8vIGxhcmdlIHRvdGFsIHRvIGVuc3VyZSBpdCBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGFjdHVhbFxuICAgICAgICAgIC8vIG51bWJlciBvZiB0aHJlYWRzLlxuICAgICAgICAgIGl0ZW1bMl0gPSBpdGVtWzEwXSA9IDEwMCAqIDEwMDA7XG4gICAgICAgICAgLy8gZmxpcCByZXNwb25zZSBmcm9tIG51bWJlci10b3RhbCBtb2RlIGludG8gJ21hbnknLXRvdGFsIG1vZGUuXG4gICAgICAgICAgaXRlbVszXSA9IDE7XG5cbiAgICAgICAgICBjb25zdCBxdWVyeSA9IGl0ZW1bNV07XG4gICAgICAgICAgaWYgKGl0ZW1bNl0pIHtcbiAgICAgICAgICAgIGl0ZW1bNl1bMF0gPSBbcXVlcnksIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBsYWNlVGhyZWFkc0luUmVzcG9uc2UoKTogTWlzc2luZyBpdGVtWzZdJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzBdID09PSAndGInKSB7XG4gICAgICAgIGhhc1NlZW5UYiA9IHRiU2VlbkluVGhpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByZVRiR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgcHJlVGJJdGVtcyA9IHByZVRiR3JvdXA7XG4gICAgICAgIH1cbiAgICAgICAgcG9zdFRiSXRlbXMgPSBwb3N0VGJHcm91cDtcbiAgICAgIH0gZWxzZSBpZiAoIWhhc1NlZW5UYikge1xuICAgICAgICBwcmVUYkdyb3VwLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0VGJHcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdGJTZWVuSW5UaGlzR3JvdXApIHtcbiAgICAgIGlmICghaGFzU2VlblRiKSB7XG4gICAgICAgIHByZVRiR3JvdXBzLnB1c2gocHJlVGJHcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0VGJHcm91cHMucHVzaChwb3N0VGJHcm91cCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBuZXdUYnMgPSBfdGhyZWFkc1RvVGJHcm91cHMocmVwbGFjZW1lbnRUaHJlYWRzLCBzdGFydCk7XG4gIGlmIChwcmVUYkl0ZW1zLmxlbmd0aCkge1xuICAgIG5ld1Ric1swXSA9IHByZVRiSXRlbXMuY29uY2F0KG5ld1Ric1swXSB8fCBbXSk7XG4gIH1cbiAgaWYgKHBvc3RUYkl0ZW1zLmxlbmd0aCkge1xuICAgIGlmIChuZXdUYnMubGVuZ3RoKSB7XG4gICAgICBuZXdUYnNbbmV3VGJzLmxlbmd0aCAtIDFdID0gbmV3VGJzW25ld1Ricy5sZW5ndGggLSAxXS5jb25jYXQocG9zdFRiSXRlbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdUYnMucHVzaChwb3N0VGJJdGVtcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcnNlZE5ldyA9IGZsYXR0ZW4oW3ByZVRiR3JvdXBzLCBuZXdUYnMsIHBvc3RUYkdyb3Vwc10pO1xuXG4gIGNvbnN0IGFsbFNlY3Rpb25zID0gZmxhdHRlbihwYXJzZWROZXcpO1xuICBjb25zdCBlbmRTZWN0aW9uID0gbGFzdChhbGxTZWN0aW9ucyk7XG5cbiAgaWYgKGVuZFNlY3Rpb25bMF0gIT09ICdlJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgZW5kIHNlY3Rpb24nKTtcbiAgfVxuICBlbmRTZWN0aW9uWzFdID0gYWxsU2VjdGlvbnMubGVuZ3RoO1xuXG4gIGNvbnN0IGZ1bGxOZXcgPSBhY3Rpb25SZXNwb25zZU1vZGVcbiAgICA/IFtbZmxhdHRlbihwYXJzZWROZXcpLCB2YWx1ZVswXVsxXV1dXG4gICAgOiBwYXJzZWROZXc7XG4gIHJldHVybiBzZXJpYWxpemUoZnVsbE5ldywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGhyZWFkcyhyZXNwb25zZTogc3RyaW5nKTogVGhyZWFkW10ge1xuICByZXR1cm4gZXh0cmFjdFRocmVhZHNGcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplKHJlc3BvbnNlKS52YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGhyZWFkc0Zyb21EZXNlcmlhbGl6ZWQodmFsdWU6IGFueVtdKTogVGhyZWFkW10ge1xuICBpZiAoXG4gICAgdmFsdWUubGVuZ3RoID09PSAxICYmXG4gICAgdmFsdWVbMF0ubGVuZ3RoID09PSAyICYmXG4gICAgdHlwZW9mIHZhbHVlWzBdWzFdID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICB2YWx1ZSA9IFt2YWx1ZVswXVswXV07XG4gIH1cbiAgcmV0dXJuIF9leHRyYWN0VGhyZWFkQXJyYXlzRnJvbVJlc3BvbnNlQXJyYXkodmFsdWUpLm1hcCgodGhyZWFkKSA9PlxuICAgIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHtcbiAgICAgICAgICBzdWJqZWN0OiBodG1sVG9UZXh0KHRocmVhZFs5XSksXG4gICAgICAgICAgc2hvcnREYXRlOiBodG1sVG9UZXh0KHRocmVhZFsxNF0pLFxuICAgICAgICAgIHRpbWVTdHJpbmc6IGh0bWxUb1RleHQodGhyZWFkWzE1XSksXG4gICAgICAgICAgcGVvcGxlSHRtbDogY2xlYW51cFBlb3BsZUxpbmUodGhyZWFkWzddKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IHRocmVhZFsxNl0gLyAxMDAwLFxuICAgICAgICAgIGlzVW5yZWFkOiB0aHJlYWRbOV0uaW5kZXhPZignPGI+JykgPiAtMSxcbiAgICAgICAgICBsYXN0RW1haWxBZGRyZXNzOiB0aHJlYWRbMjhdLFxuICAgICAgICAgIGJvZHlQcmV2aWV3SHRtbDogdGhyZWFkWzEwXSxcbiAgICAgICAgICBzb21lR21haWxNZXNzYWdlSWRzOiBbdGhyZWFkWzFdLCB0aHJlYWRbMl1dLFxuICAgICAgICAgIGdtYWlsVGhyZWFkSWQ6IHRocmVhZFswXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ19vcmlnaW5hbEdtYWlsRm9ybWF0JyxcbiAgICAgICAgeyB2YWx1ZTogdGhyZWFkIH0sXG4gICAgICApLFxuICAgICksXG4gICk7XG59XG5cbmNvbnN0IF9leHRyYWN0TWVzc2FnZUlkc0Zyb21UaHJlYWRCYXRjaFJlcXVlc3RYZiA9IHQuY29tcG9zZShcbiAgdC5jYXQsXG4gIHQuY2F0LFxuICB0LmZpbHRlcigoaXRlbTogYW55KSA9PiBpdGVtWzBdID09PSAnY3MnKSxcbiAgdC5tYXAoKGl0ZW06IGFueSkgPT4gW2l0ZW1bMV0sIGl0ZW1bMl1dKSxcbik7XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdE1lc3NhZ2VJZHNGcm9tVGhyZWFkQmF0Y2hSZXF1ZXN0KHJlc3BvbnNlOiBzdHJpbmcpOiB7XG4gIFt0aHJlYWRJZDogc3RyaW5nXTogc3RyaW5nO1xufSB7XG4gIGNvbnN0IHsgdmFsdWUgfSA9IGRlc2VyaWFsaXplKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHQudG9PYmoodmFsdWUsIF9leHRyYWN0TWVzc2FnZUlkc0Zyb21UaHJlYWRCYXRjaFJlcXVlc3RYZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwUGVvcGxlTGluZShwZW9wbGVIdG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBSZW1vdmVzIHBvc3NpYmxlIGhlYWRpbmdzIGxpa2UgXCJUbzogXCIgdGhhdCBnZXQgYWRkZWQgb24gdGhlIFNlbnQgcGFnZSwgYW5kXG4gIC8vIHJlbW92ZXMgYSBjbGFzcyB0aGF0J3Mgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgcHJldmlldyBwYW5lIHNldHRpbmcuXG4gIHJldHVybiBwZW9wbGVIdG1sXG4gICAgLnJlcGxhY2UoL15bXjxdKi8sICcnKVxuICAgIC5yZXBsYWNlKC8oPHNwYW5bXj5dKikgY2xhc3M9XCJbXlwiXSpcIi9nLCAnJDEnKTtcbn1cblxuY29uc3QgX2V4dHJhY3RUaHJlYWRBcnJheXNGcm9tUmVzcG9uc2VBcnJheVhmID0gdC5jb21wb3NlKFxuICB0LmNhdCxcbiAgdC5maWx0ZXIoKGl0ZW06IGFueSkgPT4gaXRlbVswXSA9PT0gJ3RiJyksXG4gIHQubWFwKChpdGVtOiBhbnkpID0+IGl0ZW1bMl0pLFxuICB0LmNhdCxcbik7XG5mdW5jdGlvbiBfZXh0cmFjdFRocmVhZEFycmF5c0Zyb21SZXNwb25zZUFycmF5KFxuICB0aHJlYWRSZXNwb25zZUFycmF5OiBhbnlbXSxcbik6IGFueVtdIHtcbiAgcmV0dXJuIHQudG9BcnJheShcbiAgICB0aHJlYWRSZXNwb25zZUFycmF5LFxuICAgIF9leHRyYWN0VGhyZWFkQXJyYXlzRnJvbVJlc3BvbnNlQXJyYXlYZixcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgZGF0ZTogbnVtYmVyO1xuICBtZXNzYWdlSUQ/OiBzdHJpbmc7XG4gIHJlY2lwaWVudHM/OiBBcnJheTx7XG4gICAgZW1haWxBZGRyZXNzOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgfT47XG59XG5cbmNvbnN0IF9leHRyYWN0VGhyZWFkc0Zyb21Db252ZXJzYXRpb25WaWV3UmVzcG9uc2VBcnJheVhmID0gdC5jb21wb3NlKFxuICB0LmNhdCxcbiAgdC5maWx0ZXIoKGl0ZW06IGFueSkgPT4gaXRlbVswXSA9PT0gJ2NzJyksXG4gIHQubWFwKChpdGVtOiBhbnkpID0+ICh7XG4gICAgdGhyZWFkSUQ6IGl0ZW1bMV0sXG4gICAgbWVzc2FnZUlEczogaXRlbVs4XSxcbiAgfSkpLFxuKTtcblxuY29uc3QgX2V4dHJhY3RNZXNzYWdlc0Zyb21SZXNwb25zZUFycmF5WGYgPSB0LmNvbXBvc2UoXG4gIHQuY2F0LFxuICB0LmZpbHRlcigoaXRlbTogYW55KSA9PiBpdGVtWzBdID09PSAnbXMnKSxcbiAgdC5tYXAoKGl0ZW06IGFueSkgPT4gKHtcbiAgICBtZXNzYWdlSUQ6IGl0ZW1bMV0sXG4gICAgZGF0ZTogaXRlbVs3XSxcbiAgfSkpLFxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhcbiAgcmVzcG9uc2U6IHN0cmluZyxcbik6IEFycmF5PHsgdGhyZWFkSUQ6IHN0cmluZzsgbWVzc2FnZXM6IE1lc3NhZ2VbXSB9PiB7XG4gIC8vIHJlZ3VsYXIgdmlldz1jdiByZXF1ZXN0cyBoYXZlIGEgdG9wIGxldmVsIGFycmF5IGxlbmd0aCBvZiAxXG4gIC8vIHdoZXJlYXMgdmlldz1jdiByZXF1ZXN0cyB3aGVuIHlvdSByZWZyZXNoIEdtYWlsIHdoaWxlIGxvb2tpbmcgYXQgYSB0aHJlYWRcbiAgLy8gaGF2ZSBhIHRvcCBsZXZlbCBhcnJheSB3aXRoIG1vcmUgZWxlbWVudHNcbiAgbGV0IHsgdmFsdWUgfSA9IGRlc2VyaWFsaXplKHJlc3BvbnNlKTtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgdmFsdWUgPSB2YWx1ZVswXTtcblxuICBjb25zdCB0aHJlYWRzOiBBcnJheTx7IHRocmVhZElEOiBzdHJpbmc7IG1lc3NhZ2VJRHM6IHN0cmluZ1tdIH0+ID0gdC50b0FycmF5KFxuICAgIHZhbHVlLFxuICAgIF9leHRyYWN0VGhyZWFkc0Zyb21Db252ZXJzYXRpb25WaWV3UmVzcG9uc2VBcnJheVhmLFxuICApO1xuICBjb25zdCBtZXNzYWdlcyA9IHQudG9BcnJheSh2YWx1ZSwgX2V4dHJhY3RNZXNzYWdlc0Zyb21SZXNwb25zZUFycmF5WGYpO1xuXG4gIGNvbnN0IG1lc3NhZ2VNYXA6IFJlY29yZDxzdHJpbmcsIE1lc3NhZ2U+ID0ge307XG4gIG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIG1lc3NhZ2VNYXBbbWVzc2FnZS5tZXNzYWdlSURdID0gbWVzc2FnZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRocmVhZHMubWFwKCh7IHRocmVhZElELCBtZXNzYWdlSURzIH0pID0+ICh7XG4gICAgdGhyZWFkSUQsXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VJRHMubWFwKChtZXNzYWdlSUQpID0+IG1lc3NhZ2VNYXBbbWVzc2FnZUlEXSksXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gX3RocmVhZHNUb1RiR3JvdXBzKHRocmVhZHM6IGFueVtdLCBzdGFydDogbnVtYmVyKTogQXJyYXk8QXJyYXk8YW55Pj4ge1xuICBjb25zdCBfdGhyZWFkc1RvVGJHcm91cHNYZiA9IHQuY29tcG9zZShcbiAgICB0Lm1hcCgodGhyZWFkOiBhbnkpID0+IHRocmVhZC5fb3JpZ2luYWxHbWFpbEZvcm1hdCksXG4gICAgdC5wYXJ0aXRpb24oMTApLFxuICAgIG1hcEluZGV4ZWQoKHRocmVhZHNDaHVuaywgaSkgPT4gW1sndGInLCBzdGFydCArIGkgKiAxMCwgdGhyZWFkc0NodW5rXV0pLFxuICApO1xuICByZXR1cm4gdC50b0FycmF5KHRocmVhZHMsIF90aHJlYWRzVG9UYkdyb3Vwc1hmKTtcbn1cblxuZnVuY3Rpb24gX3NlYXJjaEFycmF5KFxuICByZXNwb25zZUFycmF5OiBhbnksXG4gIG1hcmtlcjogc3RyaW5nLFxuICBtYXJrZXJBcnJheVZhbGlkYXRvcjogKG1hcmtlckFycmF5OiBhbnlbXSkgPT4gYm9vbGVhbixcbik6IGFueSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IF9zZWFyY2hPYmplY3QocmVzcG9uc2VBcnJheSwgbWFya2VyLCAxMDApO1xuXG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpaSsrKSB7XG4gICAgY29uc3QgcGF0aFRvTWFya2VyQXJyYXkgPSBwYXRoQXJyYXlbaWldLnBhdGguc2xpY2UoMCwgLTEpO1xuICAgIGNvbnN0IG1hcmtlckFycmF5ID0gX2dldEFycmF5VmFsdWVGcm9tUGF0aChcbiAgICAgIHJlc3BvbnNlQXJyYXksXG4gICAgICBwYXRoVG9NYXJrZXJBcnJheSxcbiAgICApO1xuXG4gICAgaWYgKG1hcmtlckFycmF5VmFsaWRhdG9yKG1hcmtlckFycmF5KSkge1xuICAgICAgcmV0dXJuIG1hcmtlckFycmF5O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfc2VhcmNoT2JqZWN0KGVsZW1lbnQ6IGFueSwgcXVlcnk6IHN0cmluZywgbWF4RGVwdGg6IG51bWJlcik6IGFueSB7XG4gIGNvbnN0IHJldFZhbCA9IFtdO1xuICBjb25zdCBpbml0aWFsTm9kZSA9IHtcbiAgICBlbDogZWxlbWVudCxcbiAgICBwYXRoOiBbXSBhcyBzdHJpbmdbXSxcbiAgfTtcbiAgY29uc3Qgbm9kZUxpc3QgPSBbaW5pdGlhbE5vZGVdO1xuXG4gIHdoaWxlIChub2RlTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMaXN0LnBvcCgpITtcbiAgICBpZiAobm9kZS5wYXRoLmxlbmd0aCA8PSBtYXhEZXB0aCkge1xuICAgICAgaWYgKG5vZGUuZWwgIT09IG51bGwgJiYgdHlwZW9mIG5vZGUuZWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmVsKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgZWw6IG5vZGUuZWxba2V5XSxcbiAgICAgICAgICAgIHBhdGg6IG5vZGUucGF0aC5jb25jYXQoW2tleV0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgbm9kZUxpc3QucHVzaChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUuZWwgPT09IHF1ZXJ5KSB7XG4gICAgICAgICAgcmV0VmFsLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn1cblxuZnVuY3Rpb24gX2dldEFycmF5VmFsdWVGcm9tUGF0aChyZXNwb25zZUFycmF5OiBhbnksIHBhdGg6IHN0cmluZ1tdKTogYW55IHtcbiAgbGV0IGN1cnJlbnRBcnJheSA9IHJlc3BvbnNlQXJyYXk7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBwYXRoLmxlbmd0aDsgaWkrKykge1xuICAgIGN1cnJlbnRBcnJheSA9IGN1cnJlbnRBcnJheVtwYXRoW2lpXV07XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRBcnJheTtcbn1cbiIsIi8qXG4gcmV0dXJucyBcIi91L05VTUJFUlwiIG9yIFwiL3UvTlVNQkVSL2QvREVMRUdBVEVfSURcIiBmb3IgZGVsZWdhdGVkIGFjY291bnRzXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWNjb3VudFVybFBhcnQoKTogc3RyaW5nIHtcbiAgY29uc3QgZGVsZWdhdGVkQWNjb3VudE1hdGNoID1cbiAgICBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5tYXRjaCgvXFwvYlxcLyguKz8pXFwvdVxcLyhcXGQrKS8pO1xuICBpZiAoZGVsZWdhdGVkQWNjb3VudE1hdGNoKSB7XG4gICAgY29uc3QgZGVsZWdhdGVkQWNjb3VudElkID0gZGVsZWdhdGVkQWNjb3VudE1hdGNoWzFdO1xuICAgIGNvbnN0IGRlbGVnYXRlZEFjY291bnROdW1iZXIgPSBkZWxlZ2F0ZWRBY2NvdW50TWF0Y2hbMl07XG4gICAgcmV0dXJuIGAvdS8ke2RlbGVnYXRlZEFjY291bnROdW1iZXJ9L2QvJHtkZWxlZ2F0ZWRBY2NvdW50SWR9YDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhY2NvdW50UGFyYW1NYXRjaCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC8oXFwvdVxcL1xcZCspXFwvL2kpO1xuICAgIC8vbm8gbWF0Y2ggaGFwcGVucyBpbiBpbmJveCB3aGVuIHVzZXIgb25seSBoYXMgb25lIGFjY291bnRcbiAgICBjb25zdCBhY2NvdW50UGFyYW0gPSBhY2NvdW50UGFyYW1NYXRjaCA/IGFjY291bnRQYXJhbU1hdGNoWzFdIDogJy91LzAnO1xuICAgIHJldHVybiBhY2NvdW50UGFyYW07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGltYWdlUmVxdWVzdCh1cmw6IHN0cmluZyk6IFByb21pc2U8SFRNTEltYWdlRWxlbWVudD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gcmVzb2x2ZShpbWcpKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgIGltZy5zcmMgPSB1cmw7XG4gIH0pO1xufVxuIiwiLy8gUmV0dXJucyBhIHdyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gd2hpY2ggcXVldWVzIHVwIGNhbGxUaW1lc3RhbXBzIHRvIHRoZVxuLy8gZnVuY3Rpb24gaWYgaXQgaXMgY2FsbGVkIG1vcmUgdGhhbiBjb3VudCB0aW1lcyB3aXRoaW4gcGVyaW9kIGFtb3VudCBvZiB0aW1lLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmF0ZUxpbWl0UXVldWVyPFxuICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueSkgPT4gUHJvbWlzZTxhbnk+LFxuPihmbjogVCwgcGVyaW9kOiBudW1iZXIsIGNvdW50OiBudW1iZXIpOiBUIHtcbiAgbGV0IGNhbGxUaW1lc3RhbXBzOiBBcnJheTxudW1iZXI+ID0gW107XG4gIGNvbnN0IHF1ZXVlOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICBsZXQgcnVubmluZ1F1ZXVlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcnVuSm9iKCkge1xuICAgIGNvbnN0IGpvYiA9IHF1ZXVlLnNoaWZ0KCkhO1xuICAgIGpvYigpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHJ1blF1ZXVlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bm5pbmdRdWV1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuICAgIHJ1bm5pbmdRdWV1ZSA9IHRydWU7XG5cbiAgICBjb25zdCB0aW1lVG9XYWl0ID0gZ2V0VGltZVRvVW5xdWV1ZUl0ZW0oKTtcbiAgICBpZiAodGltZVRvV2FpdCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQocnVuSm9iLCB0aW1lVG9XYWl0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVuSm9iKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGltZVRvVW5xdWV1ZUl0ZW0oKTogbnVtYmVyIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBlcmlvZEFnbyA9IG5vdyAtIHBlcmlvZDtcbiAgICBjYWxsVGltZXN0YW1wcyA9IGNhbGxUaW1lc3RhbXBzLmZpbHRlcigodGltZSkgPT4gdGltZSA+IHBlcmlvZEFnbyk7XG5cbiAgICBpZiAoY2FsbFRpbWVzdGFtcHMubGVuZ3RoID49IGNvdW50KSB7XG4gICAgICByZXR1cm4gY2FsbFRpbWVzdGFtcHNbMF0gLSBwZXJpb2RBZ287XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pIHtcbiAgICBsZXQgam9iO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBqb2IgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxUaW1lc3RhbXBzLnB1c2goRGF0ZS5ub3coKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZShmbi5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmICgham9iKSB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgaGFwcGVuJyk7XG5cbiAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgaWYgKCFydW5uaW5nUXVldWUpIHtcbiAgICAgIHJ1blF1ZXVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0gYXMgYW55O1xufVxuIiwiaW1wb3J0IHsgZGVmbiB9IGZyb20gJ3VkJztcbmltcG9ydCBLZWZpciBmcm9tICdrZWZpcic7XG5pbXBvcnQgaW1hZ2VSZXF1ZXN0IGZyb20gJy4uL2xpYi9pbWFnZVJlcXVlc3QnO1xuaW1wb3J0IHJhdGVMaW1pdFF1ZXVlciBmcm9tICcuLi8uLi9jb21tb24vcmF0ZS1saW1pdC1xdWV1ZXInO1xuaW1wb3J0IGFqYXggZnJvbSAnLi4vLi4vY29tbW9uL2FqYXgnO1xuXG5pbXBvcnQgeyBBamF4T3B0cywgQWpheFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vY29tbW9uL2FqYXgnO1xuXG5jb25zdCBJTUFHRV9SRVFVRVNUX1RJTUVPVVQgPSAxMDAwICogNjA7IC8vIG9uZSBtaW51dGVcblxuY29uc3QgbGltaXRlZEFqYXggPSByYXRlTGltaXRRdWV1ZXIoXG4gIHJhdGVMaW1pdFF1ZXVlcihhamF4LCAxMDAwLCA3KSxcbiAgMTAgKiAxMDAwLFxuICA1MCxcbik7XG5cbi8vIFRvb2wgZm9yIG1ha2luZyBhamF4IHJlcXVlc3RzIHRvIEdtYWlsIGVuZHBvaW50cy4gV2hlbiB1c2VkIGluIEluYm94LCB0aGlzXG4vLyBmdW5jdGlvbiBpcyBhYmxlIHRvIGhhbmRsZSB0aGUgaXNzdWUgdGhhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgaGFzIG5vIEdtYWlsXG4vLyBjb29raWVzLlxuYXN5bmMgZnVuY3Rpb24gZ21haWxBamF4KG9wdHM6IEFqYXhPcHRzKTogUHJvbWlzZTxBamF4UmVzcG9uc2U+IHtcbiAgaWYgKCEvXmh0dHBzOlxcL1xcL21haWxcXC5nb29nbGVcXC5jb20oPzokfFxcLykvLnRlc3Qob3B0cy51cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGhhcHBlbjogZ21haWxBamF4IGNhbGxlZCB3aXRoIG5vbi1nbWFpbCB1cmwnKTtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4gPT09ICdodHRwczovL21haWwuZ29vZ2xlLmNvbScpIHtcbiAgICByZXR1cm4gYXdhaXQgbGltaXRlZEFqYXgob3B0cyk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBsaW1pdGVkQWpheCh7IC4uLm9wdHMsIGNhblJldHJ5OiBmYWxzZSB9KTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgaWYgKGUgJiYgZS5zdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFRoZSBjb25uZWN0aW9uIGZhaWxlZCBmb3IgYW4gdW5zcGVjaWZpZWQgcmVhc29uLiBPbmUgcG9zc2libGUgcmVhc29uXG4gICAgICAvLyBpcyB0aGF0IHdlIGhhdmUgbm8gR21haWwgY29va2llcywgYW5kIHRoZSBjb25uZWN0aW9uIHRyaWVkIHRvIHJlZGlyZWN0XG4gICAgICAvLyB0byBhbiBhY2NvdW50cy5nb29nbGUuY29tIFVSTCBzbyB0aGUgR21haWwgY29va2llcyBjb3VsZCBiZSBzZXQsIGJ1dFxuICAgICAgLy8gdGhlbiB0aGlzIGNvbm5lY3Rpb24gZmFpbGVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhamF4IHBlcm1pc3Npb24gdG9cbiAgICAgIC8vIGFjY291bnRzLmdvb2dsZS5jb20uIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHRyeWluZyBhbiBpbWFnZVxuICAgICAgLy8gcmVxdWVzdCAod2hpY2ggZG9lc24ndCBoYXZlIGNyb3NzLWRvbWFpbiByZXN0cmljdGlvbnMpIHNvIHRoZSBHbWFpbFxuICAgICAgLy8gY29va2llcyBnZXQgc2V0LCBhbmQgdGhlbiByZXRyeWluZyB0aGUgb3JpZ2luYWwgYWpheCByZXF1ZXN0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgS2VmaXIuZnJvbVByb21pc2UoXG4gICAgICAgICAgaW1hZ2VSZXF1ZXN0KCdodHRwczovL21haWwuZ29vZ2xlLmNvbS9tYWlsL3UvMC8nKSxcbiAgICAgICAgKVxuICAgICAgICAgIC5tZXJnZShLZWZpci5sYXRlcihJTUFHRV9SRVFVRVNUX1RJTUVPVVQsIHVuZGVmaW5lZCkpXG4gICAgICAgICAgLnRha2UoMSlcbiAgICAgICAgICAudGFrZUVycm9ycygxKVxuICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlLiBJZiB3ZSBnb3QgYW4gZXJyb3IgaGVyZSwgdGhlcmUgYXJlIHNldmVyYWwgcG9zc2libGUgY2F1c2VzOlxuICAgICAgICAvLyAxLiBUaGUgdXNlciBoYXMgR21haWwgY29va2llcywgYnV0IHRoZSBmaXJzdCBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgLy8gICAgZmFpbGVkIGZvciBhbm90aGVyIHJlYXNvbi4gSW4gdGhpcyBjYXNlLCB3ZSBkb24ndCBjYXJlIGFib3V0IGhvd1xuICAgICAgICAvLyAgICB0aGlzIGltYWdlIHJlcXVlc3QgdHVybmVkIG91dC5cbiAgICAgICAgLy8gMi4gVGhlIHVzZXIgZGlkIG5vdCBoYXZlIEdtYWlsIGNvb2tpZXMsIGFuZCB0aGUgaW1hZ2UncyBvcmlnaW5hbFxuICAgICAgICAvLyAgICByZXF1ZXN0IGFuZCBpdHMgZmlyc3QgZmV3IHJlZGlyZWN0cyBzdWNjZWVkZWQsIHNldHRpbmcgdGhlXG4gICAgICAgIC8vICAgIGNvb2tpZXMsIGJ1dCB0aGUgZmluYWwgcmVxdWVzdCwgYWZ0ZXIgdGhlIGNvb2tpZXMgd2VyZSBzZXQsXG4gICAgICAgIC8vICAgIGZhaWxlZC4gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgaW1hZ2UncyBmaW5hbCByZXF1ZXN0LlxuICAgICAgICAvLyAzLiBUaGUgdXNlciBkaWQgbm90IGhhdmUgR21haWwgY29va2llcywgYW5kIHRoZSBpbWFnZSByZXF1ZXN0IGRpZG4ndFxuICAgICAgICAvLyAgICB3b3JrIGF0IGFsbC5cbiAgICAgICAgLy8gSW4gdGhlIGZpbmFsIGNhc2UsIGlkZWFsbHkgd2Ugd291bGQgcmV0cnkgdGhlIGltYWdlIHJlcXVlc3QsIGJ1dCB3ZVxuICAgICAgICAvLyBjYW4ndCBkaXN0aW5ndWlzaCB0aGF0IGNhc2UgZnJvbSB0aGUgb3RoZXIgY2FzZXMgYW5kIGRvaW5nIHJldHJpZXNcbiAgICAgICAgLy8gb2YgdGhlIGltYWdlIHJlcXVlc3Qgd291bGQgc2xvdyBkb3duIHRoZSBvdGhlciBjYXNlcy4gVGhlIGZpcnN0IGNhc2VcbiAgICAgICAgLy8gaXMgZXhwZWN0ZWQgdG8gYmUgc2lnbmlmaWNhbnRseSBtb3JlIGNvbW1vbiAtLSB0aGUgc2Vjb25kIHR3byBjYXNlc1xuICAgICAgICAvLyB3aGVyZSB0aGUgdXNlciBoYXMgbm8gR21haWwgY29va2llcyBpcyBleHBlY3RlZCB0byBoYXBwZW4gbWF5YmUgb25jZVxuICAgICAgICAvLyBpbiB0b3RhbCB0byBhbiBpbmRpdmlkdWFsIHVzZXIuXG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgbGltaXRlZEFqYXgob3B0cyk7XG4gICAgfSBlbHNlIGlmIChlICYmIHR5cGVvZiBlLnN0YXR1cyA9PT0gJ251bWJlcicgJiYgZS5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICByZXR1cm4gYXdhaXQgbGltaXRlZEFqYXgob3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZm4obW9kdWxlLCBnbWFpbEFqYXgpO1xuIiwiaW1wb3J0IHsgZGVmbiB9IGZyb20gJ3VkJztcbmltcG9ydCBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgZ21haWxBamF4IGZyb20gJy4vZ21haWxBamF4JztcbmltcG9ydCBnZXRBY2NvdW50VXJsUGFydCBmcm9tICcuL2dldEFjY291bnRVcmxQYXJ0JztcblxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEdtYWlsVGhyZWFkKFxuICBpa1ZhbHVlOiBzdHJpbmcsXG4gIHRocmVhZElkOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7XG4gICAgdWk6IDIsXG4gICAgaWs6IGlrVmFsdWUsXG4gICAgdmlldzogJ2N2JyxcbiAgICB0aDogdGhyZWFkSWQsXG4gICAgcGNkOiAxLFxuICAgIG1iOiAwLFxuICAgIHJ0OiAnYycsXG4gICAgc2VhcmNoOiAnaW5ib3gnLFxuICAgIHR5cGU6IHRocmVhZElkLFxuICB9O1xuICBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGdtYWlsQWpheCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiBgaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbCR7Z2V0QWNjb3VudFVybFBhcnQoKX0/JHtxdWVyeXN0cmluZy5zdHJpbmdpZnkoXG4gICAgICBxdWVyeVBhcmFtZXRlcnMsXG4gICAgKX1gLFxuICAgIGNhblJldHJ5OiB0cnVlLFxuICB9KTtcbiAgcmV0dXJuIHRleHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZm4obW9kdWxlLCByZXF1ZXN0R21haWxUaHJlYWQpO1xuIiwiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMC4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjAgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XG5cbnZhciBfbWF0Y2hlc1NlbGVjdG9yTmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJtYXRjaGVzLXNlbGVjdG9yLW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHByb3RvID0gZ2xvYmFsLkVsZW1lbnQgJiYgZ2xvYmFsLkVsZW1lbnQucHJvdG90eXBlO1xudmFyIHZlbmRvciA9IHByb3RvICYmIHByb3RvLmNsb3Nlc3Q7XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgdmFyIHBhcmVudCA9IGVsZW1lbnQ7XG5cbiAgZG8ge1xuICAgIGlmICgoMCwgX21hdGNoZXNTZWxlY3Rvck5nLmRlZmF1bHQpKHBhcmVudCwgc2VsZWN0b3IpKSByZXR1cm4gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSBnbG9iYWwuZG9jdW1lbnQpO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OXBibVJsZUM1cWN5SmRMQ0p1WVcxbGN5STZXeUp3Y205MGJ5SXNJbWRzYjJKaGJDSXNJa1ZzWlcxbGJuUWlMQ0p3Y205MGIzUjVjR1VpTENKMlpXNWtiM0lpTENKamJHOXpaWE4wSWl3aVpXeGxiV1Z1ZENJc0luTmxiR1ZqZEc5eUlpd2lZMkZzYkNJc0luQmhjbVZ1ZENJc0luQmhjbVZ1ZEU1dlpHVWlMQ0prYjJOMWJXVnVkQ0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3UVVGRlFUczdPenRCUVVWQkxFbEJRVTFCTEV0QlFVc3NSMEZCUjBNc1RVRkJUU3hEUVVGRFF5eFBRVUZRTEVsQlFXdENSQ3hOUVVGTkxFTkJRVU5ETEU5QlFWQXNRMEZCWlVNc1UwRkJMME03UVVGRFFTeEpRVUZOUXl4TlFVRk5MRWRCUVVkS0xFdEJRVXNzU1VGQlNVRXNTMEZCU3l4RFFVRkRTeXhQUVVFNVFqczdRVUZGWlN4VFFVRlRRU3hQUVVGVUxFTkJRV2xDUXl4UFFVRnFRaXhGUVVGMVEwTXNVVUZCZGtNc1JVRkJOa1U3UVVGRE1VWXNUVUZCU1Vnc1RVRkJTaXhGUVVGWkxFOUJRVTlCTEUxQlFVMHNRMEZCUTBrc1NVRkJVQ3hEUVVGWlJpeFBRVUZhTEVWQlFYRkNReXhSUVVGeVFpeERRVUZRTzBGQlExb3NUVUZCU1VVc1RVRkJUU3hIUVVGSFNDeFBRVUZpT3p0QlFVTkJMRXRCUVVjN1FVRkRSQ3hSUVVGSkxHZERRVUZSUnl4TlFVRlNMRVZCUVdkQ1JpeFJRVUZvUWl4RFFVRktMRVZCUVN0Q0xFOUJRVTlGTEUxQlFWQTdRVUZETDBKQkxFbEJRVUZCTEUxQlFVMHNSMEZCUjBFc1RVRkJUU3hEUVVGRFF5eFZRVUZvUWp0QlFVTkVMRWRCU0VRc1VVRkhVMFFzVFVGQlRTeEpRVUZKUVN4TlFVRk5MRXRCUVV0U0xFMUJRVTBzUTBGQlExVXNVVUZJY2tNN08wRkJTVUVzVTBGQlR5eEpRVUZRTzBGQlEwUWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUl2S2lCQVpteHZkeUFxTDF4dVhHNXBiWEJ2Y25RZ2JXRjBZMmhsY3lCbWNtOXRJQ2R0WVhSamFHVnpMWE5sYkdWamRHOXlMVzVuSnp0Y2JseHVZMjl1YzNRZ2NISnZkRzhnUFNCbmJHOWlZV3d1Uld4bGJXVnVkQ0FtSmlCbmJHOWlZV3d1Uld4bGJXVnVkQzV3Y205MGIzUjVjR1U3WEc1amIyNXpkQ0IyWlc1a2IzSWdQU0J3Y205MGJ5QW1KaUJ3Y205MGJ5NWpiRzl6WlhOME8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQm1kVzVqZEdsdmJpQmpiRzl6WlhOMEtHVnNaVzFsYm5RNklFaFVUVXhGYkdWdFpXNTBMQ0J6Wld4bFkzUnZjam9nYzNSeWFXNW5LVG9nU0ZSTlRFVnNaVzFsYm5RZ2ZDQnVkV3hzSUh0Y2JpQWdhV1lnS0habGJtUnZjaWtnY21WMGRYSnVJSFpsYm1SdmNpNWpZV3hzS0dWc1pXMWxiblFzSUhObGJHVmpkRzl5S1R0Y2JpQWdiR1YwSUhCaGNtVnVkQ0E5SUdWc1pXMWxiblE3WEc0Z0lHUnZJSHRjYmlBZ0lDQnBaaUFvYldGMFkyaGxjeWh3WVhKbGJuUXNJSE5sYkdWamRHOXlLU2tnY21WMGRYSnVJSEJoY21WdWREdGNiaUFnSUNCd1lYSmxiblFnUFNCd1lYSmxiblF1Y0dGeVpXNTBUbTlrWlR0Y2JpQWdmU0IzYUdsc1pTQW9jR0Z5Wlc1MElDWW1JSEJoY21WdWRDQWhQVDBnWjJ4dlltRnNMbVJ2WTNWdFpXNTBLVHRjYmlBZ2NtVjBkWEp1SUc1MWJHdzdYRzU5WEc0aVhYMD0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1vZHVsZUlkID0gdm9pZCAwO1xudmFyIG1vZHVsZUlkID0gJzFmMjQgZTUzYSc7XG5leHBvcnRzLm1vZHVsZUlkID0gbW9kdWxlSWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGVJZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX3RyYW5zZmVycmFibGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2ZlcnJhYmxlc1wiKSk7XG5cbnZhciBfbW9kdWxlSWQgPSByZXF1aXJlKFwiLi9tb2R1bGVJZFwiKTtcblxuLy8gbXVzdCBiZSBleGVjdXRlZCBpbiBwYWdlJ3Mgd29ybGRcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vIHNhdmUgYSByZWZlcmVuY2UgdG8gWEhSIHNvIHdlIHVzZSB0aGUgb3JpZ2luYWwgaW5zdGVhZCBvZiBhbnkgcmVwbGFjZW1lbnRzIHRoYXQgZXh0ZW5zaW9ucyBtYXkgcGxhY2UuXG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcblxuICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5kYXRhIHx8IGV2ZW50LmRhdGEudHlwZSAhPT0gJ2V4dC1jb3JiLXdvcmthcm91bmRfcG9ydCcgfHwgZXZlbnQuZGF0YS5tb2R1bGVJZCAhPT0gX21vZHVsZUlkLm1vZHVsZUlkIHx8IGV2ZW50Ll9fZXh0X2NsYWltZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5fX2V4dF9jbGFpbWVkID0gdHJ1ZTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpO1xuICAgIHZhciBwb3J0ID0gZXZlbnQuZGF0YS5wb3J0O1xuICAgIHZhciBpbnN0YW5jZXNCeUlkID0ge307XG4gICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgaWQgPSBldmVudC5kYXRhLmlkO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICdORVdfWEhSJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgeGhyID0gaW5zdGFuY2VzQnlJZFtpZF0gPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgaW5zdGFuY2VzQnlJZFtpZF07XG4gICAgICAgICAgICAgIHZhciByZXNwb25zZVRleHQ7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsvLyBpZ25vcmVcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDT01QTEVURScsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiB4aHIucmVhZHlTdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VVUkw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogeGhyLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgIH0sICgwLCBfdHJhbnNmZXJyYWJsZXNbXCJkZWZhdWx0XCJdKShbeGhyLnJlc3BvbnNlXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnU0VUJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2V2ZW50JGRhdGEgPSBldmVudC5kYXRhLFxuICAgICAgICAgICAgICAgIHByb3AgPSBfZXZlbnQkZGF0YS5wcm9wLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2V2ZW50JGRhdGEudmFsdWU7XG4gICAgICAgICAgICBpbnN0YW5jZXNCeUlkW2lkXVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0NBTEwnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgICAgICB2YXIgX2V2ZW50JGRhdGEyID0gZXZlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBfZXZlbnQkZGF0YTIubWV0aG9kLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBfZXZlbnQkZGF0YTIuYXJnczsgLy8gTGV0IGFib3J0IGNhbGxzIHNpbGVudGx5IGZhaWwgaWYgdGhlIFhIUiBpc24ndCBwcmVzZW50LlxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAnYWJvcnQnICYmICFpbnN0YW5jZXNCeUlkW2lkXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF9yZWYgPSBpbnN0YW5jZXNCeUlkW2lkXSlbbWV0aG9kXS5hcHBseShfcmVmLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5MltcImRlZmF1bHRcIl0pKGFyZ3MpKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2V4dC1jb3JiLXdvcmthcm91bmQ6IFVua25vd24gZXZlbnQgaW4gcGFnZSB3b3JsZDonLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZWVycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignZXh0LWNvcmItd29ya2Fyb3VuZDogVW5rbm93biBlcnJvciBpbiBwYWdlIHdvcmxkOicsIGV2ZW50KTtcbiAgICB9KTtcbiAgICBwb3J0LnN0YXJ0KCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZVdvcmxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdHJhbnNmZXJyYWJsZXM7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxuZnVuY3Rpb24gdHJhbnNmZXJyYWJsZXMobGlzdCkge1xuICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX19wcm90b19fKSB7XG4gICAgICBpZiAodmFsdWUuX19wcm90b19fLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuX19wcm90b19fLl9fcHJvdG9fXyAmJiB2YWx1ZS5fX3Byb3RvX18uX19wcm90b19fLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdUeXBlZEFycmF5Jykge1xuICAgICAgICByZXR1cm4gdmFsdWUuYnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmZXJyYWJsZXMuanMubWFwIiwiLyohIEtlZmlyLmpzIHYzLjguOFxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWZpcmpzL2tlZmlyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT2JqKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRigpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0IC8qLCBtaXhpbjEsIG1peGluMi4uLiovKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgaSA9IHZvaWQgMCxcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIHRhcmdldFtwcm9wXSA9IGFyZ3VtZW50c1tpXVtwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5oZXJpdChDaGlsZCwgUGFyZW50IC8qLCBtaXhpbjEsIG1peGluMi4uLiovKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgaSA9IHZvaWQgMDtcbiAgQ2hpbGQucHJvdG90eXBlID0gY3JlYXRlT2JqKFBhcmVudC5wcm90b3R5cGUpO1xuICBDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgZm9yIChpID0gMjsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZXh0ZW5kKENoaWxkLnByb3RvdHlwZSwgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gQ2hpbGQ7XG59XG5cbnZhciBOT1RISU5HID0gWyc8bm90aGluZz4nXTtcbnZhciBFTkQgPSAnZW5kJztcbnZhciBWQUxVRSA9ICd2YWx1ZSc7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIEFOWSA9ICdhbnknO1xuXG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gdm9pZCAwLFxuICAgICAgbGVuZ3RoID0gdm9pZCAwLFxuICAgICAgaSA9IHZvaWQgMCxcbiAgICAgIGogPSB2b2lkIDA7XG4gIGlmIChhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGogPSAwO1xuICByZXN1bHQgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gIGxlbmd0aCA9IGEubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyssIGorKykge1xuICAgIHJlc3VsdFtqXSA9IGFbaV07XG4gIH1cbiAgbGVuZ3RoID0gYi5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKywgaisrKSB7XG4gICAgcmVzdWx0W2pdID0gYltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kKGFyciwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZmluZEJ5UHJlZChhcnIsIHByZWQpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZChhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGlucHV0KSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKSxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGlucHV0W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShpbnB1dCwgaW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMCxcbiAgICAgIGkgPSB2b2lkIDAsXG4gICAgICBqID0gdm9pZCAwO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAtIDEpO1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHRbal0gPSBpbnB1dFtpXTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXAoaW5wdXQsIGZuKSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKSxcbiAgICAgIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGZuKGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKGFyciwgZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmbihhcnJbaV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxBcnJheShhcnIsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgaSA9IHZvaWQgMDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYXJyLCB2YWx1ZSkge1xuICByZXR1cm4gZmluZChhcnIsIHZhbHVlKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIHNsaWRlKGN1ciwgbmV4dCwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihtYXgsIGN1ci5sZW5ndGggKyAxKSxcbiAgICAgIG9mZnNldCA9IGN1ci5sZW5ndGggLSBsZW5ndGggKyAxLFxuICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCksXG4gICAgICBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpIC0gb2Zmc2V0XSA9IGN1cltpXTtcbiAgfVxuICByZXN1bHRbbGVuZ3RoIC0gMV0gPSBuZXh0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYWxsU3Vic2NyaWJlcih0eXBlLCBmbiwgZXZlbnQpIHtcbiAgaWYgKHR5cGUgPT09IEFOWSkge1xuICAgIGZuKGV2ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBldmVudC50eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IFZBTFVFIHx8IHR5cGUgPT09IEVSUk9SKSB7XG4gICAgICBmbihldmVudC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gIHRoaXMuX2l0ZW1zID0gW107XG4gIHRoaXMuX3NwaWVzID0gW107XG4gIHRoaXMuX2luTG9vcCA9IDA7XG4gIHRoaXMuX3JlbW92ZWRJdGVtcyA9IG51bGw7XG59XG5cbmV4dGVuZChEaXNwYXRjaGVyLnByb3RvdHlwZSwge1xuICBhZGQ6IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIHRoaXMuX2l0ZW1zID0gY29uY2F0KHRoaXMuX2l0ZW1zLCBbeyB0eXBlOiB0eXBlLCBmbjogZm4gfV0pO1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEJ5UHJlZCh0aGlzLl9pdGVtcywgZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnR5cGUgPT09IHR5cGUgJiYgeC5mbiA9PT0gZm47XG4gICAgfSk7XG5cbiAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gYSBub3RpZmljYXRpb24gbG9vcCxcbiAgICAvLyByZW1lbWJlciB0aGlzIHN1YnNjcmliZXIgd2FzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5faW5Mb29wICE9PSAwICYmIGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKHRoaXMuX3JlbW92ZWRJdGVtcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVkSXRlbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZWRJdGVtcy5wdXNoKHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gICAgfVxuXG4gICAgdGhpcy5faXRlbXMgPSByZW1vdmUodGhpcy5faXRlbXMsIGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9LFxuICBhZGRTcHk6IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuX3NwaWVzID0gY29uY2F0KHRoaXMuX3NwaWVzLCBbZm5dKTtcbiAgICByZXR1cm4gdGhpcy5fc3BpZXMubGVuZ3RoO1xuICB9LFxuXG5cbiAgLy8gQmVjYXVzZSBzcGllcyBhcmUgb25seSBldmVyIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtIGxvZ2dpbmcgYXNcbiAgLy8gdGhlaXIgb25seSBzaWRlIGVmZmVjdCwgd2UgZG9uJ3QgbmVlZCB0aGUgc2FtZSBjb21wbGljYXRlZFxuICAvLyByZW1vdmFsIGxvZ2ljIGxpa2UgaW4gcmVtb3ZlKClcbiAgcmVtb3ZlU3B5OiBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLl9zcGllcyA9IHJlbW92ZSh0aGlzLl9zcGllcywgdGhpcy5fc3BpZXMuaW5kZXhPZihmbikpO1xuICAgIHJldHVybiB0aGlzLl9zcGllcy5sZW5ndGg7XG4gIH0sXG4gIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9pbkxvb3ArKztcbiAgICBmb3IgKHZhciBpID0gMCwgc3BpZXMgPSB0aGlzLl9zcGllczsgdGhpcy5fc3BpZXMgIT09IG51bGwgJiYgaSA8IHNwaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzcGllc1tpXShldmVudCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBpdGVtcyA9IHRoaXMuX2l0ZW1zOyBfaSA8IGl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgLy8gY2xlYW51cCB3YXMgY2FsbGVkXG4gICAgICBpZiAodGhpcy5faXRlbXMgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgc3Vic2NyaWJlciB3YXMgcmVtb3ZlZFxuICAgICAgaWYgKHRoaXMuX3JlbW92ZWRJdGVtcyAhPT0gbnVsbCAmJiBjb250YWlucyh0aGlzLl9yZW1vdmVkSXRlbXMsIGl0ZW1zW19pXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNhbGxTdWJzY3JpYmVyKGl0ZW1zW19pXS50eXBlLCBpdGVtc1tfaV0uZm4sIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5faW5Mb29wLS07XG4gICAgaWYgKHRoaXMuX2luTG9vcCA9PT0gMCkge1xuICAgICAgdGhpcy5fcmVtb3ZlZEl0ZW1zID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fc3BpZXMgPSBudWxsO1xuICB9XG59KTtcblxuZnVuY3Rpb24gT2JzZXJ2YWJsZSgpIHtcbiAgdGhpcy5fZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9hbGl2ZSA9IHRydWU7XG4gIHRoaXMuX2FjdGl2YXRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fbG9nSGFuZGxlcnMgPSBudWxsO1xuICB0aGlzLl9zcHlIYW5kbGVycyA9IG51bGw7XG59XG5cbmV4dGVuZChPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBfbmFtZTogJ29ic2VydmFibGUnLFxuXG4gIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHt9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHt9LFxuICBfc2V0QWN0aXZlOiBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vbkFjdGl2YXRpb24oKTtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb25EZWFjdGl2YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3NldEFjdGl2ZShmYWxzZSk7XG4gICAgdGhpcy5fZGlzcGF0Y2hlci5jbGVhbnVwKCk7XG4gICAgdGhpcy5fZGlzcGF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5fbG9nSGFuZGxlcnMgPSBudWxsO1xuICB9LFxuICBfZW1pdDogZnVuY3Rpb24gKHR5cGUsIHgpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVkFMVUU6XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgICBjYXNlIEVSUk9SOlxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKHgpO1xuICAgICAgY2FzZSBFTkQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9LFxuICBfZW1pdFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2goeyB0eXBlOiBWQUxVRSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSxcbiAgX2VtaXRFcnJvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKHsgdHlwZTogRVJST1IsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0sXG4gIF9lbWl0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2FsaXZlKSB7XG4gICAgICB0aGlzLl9hbGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaCh7IHR5cGU6IEVORCB9KTtcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9LFxuICBfb246IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fZGlzcGF0Y2hlci5hZGQodHlwZSwgZm4pO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsU3Vic2NyaWJlcih0eXBlLCBmbiwgeyB0eXBlOiBFTkQgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHZhciBjb3VudCA9IHRoaXMuX2Rpc3BhdGNoZXIucmVtb3ZlKHR5cGUsIGZuKTtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25WYWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKFZBTFVFLCBmbik7XG4gIH0sXG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB0aGlzLl9vbihFUlJPUiwgZm4pO1xuICB9LFxuICBvbkVuZDogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKEVORCwgZm4pO1xuICB9LFxuICBvbkFueTogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKEFOWSwgZm4pO1xuICB9LFxuICBvZmZWYWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZihWQUxVRSwgZm4pO1xuICB9LFxuICBvZmZFcnJvcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZihFUlJPUiwgZm4pO1xuICB9LFxuICBvZmZFbmQ6IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB0aGlzLl9vZmYoRU5ELCBmbik7XG4gIH0sXG4gIG9mZkFueTogZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZihBTlksIGZuKTtcbiAgfSxcbiAgb2JzZXJ2ZTogZnVuY3Rpb24gKG9ic2VydmVyT3JPblZhbHVlLCBvbkVycm9yLCBvbkVuZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG9ic2VydmVyID0gIW9ic2VydmVyT3JPblZhbHVlIHx8IHR5cGVvZiBvYnNlcnZlck9yT25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHsgdmFsdWU6IG9ic2VydmVyT3JPblZhbHVlLCBlcnJvcjogb25FcnJvciwgZW5kOiBvbkVuZCB9IDogb2JzZXJ2ZXJPck9uVmFsdWU7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFZBTFVFICYmIG9ic2VydmVyLnZhbHVlKSB7XG4gICAgICAgIG9ic2VydmVyLnZhbHVlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IgJiYgb2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXZlbnQudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBFTkQgJiYgb2JzZXJ2ZXIuZW5kKSB7XG4gICAgICAgIG9ic2VydmVyLmVuZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25BbnkoaGFuZGxlcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICBfdGhpcy5vZmZBbnkoaGFuZGxlcik7XG4gICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG5cbiAgLy8gQSBhbmQgQiBtdXN0IGJlIHN1YmNsYXNzZXMgb2YgU3RyZWFtIGFuZCBQcm9wZXJ0eSAob3JkZXIgZG9lc24ndCBtYXR0ZXIpXG4gIF9vZlNhbWVUeXBlOiBmdW5jdGlvbiAoQSwgQikge1xuICAgIHJldHVybiBBLnByb3RvdHlwZS5nZXRUeXBlKCkgPT09IHRoaXMuZ2V0VHlwZSgpID8gQSA6IEI7XG4gIH0sXG4gIHNldE5hbWU6IGZ1bmN0aW9uIChzb3VyY2VPYnMgLyogb3B0aW9uYWwgKi8sIHNlbGZOYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IHNlbGZOYW1lID8gc291cmNlT2JzLl9uYW1lICsgJy4nICsgc2VsZk5hbWUgOiBzb3VyY2VPYnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGxvZzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgaXNDdXJyZW50ID0gdm9pZCAwO1xuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdHlwZSA9ICc8JyArIGV2ZW50LnR5cGUgKyAoaXNDdXJyZW50ID8gJzpjdXJyZW50JyA6ICcnKSArICc+JztcbiAgICAgIGlmIChldmVudC50eXBlID09PSBFTkQpIHtcbiAgICAgICAgY29uc29sZS5sb2cobmFtZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCB0eXBlLCBldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2dIYW5kbGVycykge1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nSGFuZGxlcnMucHVzaCh7IG5hbWU6IG5hbWUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfVxuXG4gICAgaXNDdXJyZW50ID0gdHJ1ZTtcbiAgICB0aGlzLm9uQW55KGhhbmRsZXIpO1xuICAgIGlzQ3VycmVudCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9mZkxvZzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5fbG9nSGFuZGxlcnMpIHtcbiAgICAgIHZhciBoYW5kbGVySW5kZXggPSBmaW5kQnlQcmVkKHRoaXMuX2xvZ0hhbmRsZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmoubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhbmRsZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5vZmZBbnkodGhpcy5fbG9nSGFuZGxlcnNbaGFuZGxlckluZGV4XS5oYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNweTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHR5cGUgPSAnPCcgKyBldmVudC50eXBlICsgJz4nO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG5hbWUsIHR5cGUsIGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgaWYgKCF0aGlzLl9zcHlIYW5kbGVycykge1xuICAgICAgICB0aGlzLl9zcHlIYW5kbGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3B5SGFuZGxlcnMucHVzaCh7IG5hbWU6IG5hbWUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgICB0aGlzLl9kaXNwYXRjaGVyLmFkZFNweShoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9mZlNweTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5fc3B5SGFuZGxlcnMpIHtcbiAgICAgIHZhciBoYW5kbGVySW5kZXggPSBmaW5kQnlQcmVkKHRoaXMuX3NweUhhbmRsZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmoubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhbmRsZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5yZW1vdmVTcHkodGhpcy5fc3B5SGFuZGxlcnNbaGFuZGxlckluZGV4XS5oYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fc3B5SGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kKCkgY2FuJ3QgaGFuZGxlIGB0b1N0cmluZ2AgaW4gSUU4XG5PYnNlcnZhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdbJyArIHRoaXMuX25hbWUgKyAnXSc7XG59O1xuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIE9ic2VydmFibGUuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdChTdHJlYW0sIE9ic2VydmFibGUsIHtcbiAgX25hbWU6ICdzdHJlYW0nLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3N0cmVhbSc7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBQcm9wZXJ0eSgpIHtcbiAgT2JzZXJ2YWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLl9jdXJyZW50RXZlbnQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByb3BlcnR5LCBPYnNlcnZhYmxlLCB7XG4gIF9uYW1lOiAncHJvcGVydHknLFxuXG4gIF9lbWl0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEV2ZW50ID0geyB0eXBlOiBWQUxVRSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICBpZiAoIXRoaXMuX2FjdGl2YXRpbmcpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaCh7IHR5cGU6IFZBTFVFLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZW1pdEVycm9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFdmVudCA9IHsgdHlwZTogRVJST1IsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgaWYgKCF0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2goeyB0eXBlOiBFUlJPUiwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2VtaXRFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYWxpdmUpIHtcbiAgICAgIHRoaXMuX2FsaXZlID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX2FjdGl2YXRpbmcpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5kaXNwYXRjaCh7IHR5cGU6IEVORCB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9LFxuICBfb246IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGlmICh0aGlzLl9hbGl2ZSkge1xuICAgICAgdGhpcy5fZGlzcGF0Y2hlci5hZGQodHlwZSwgZm4pO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlKHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VycmVudEV2ZW50ICE9PSBudWxsKSB7XG4gICAgICBjYWxsU3Vic2NyaWJlcih0eXBlLCBmbiwgdGhpcy5fY3VycmVudEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9hbGl2ZSkge1xuICAgICAgY2FsbFN1YnNjcmliZXIodHlwZSwgZm4sIHsgdHlwZTogRU5EIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAncHJvcGVydHknO1xuICB9XG59KTtcblxudmFyIG5ldmVyUyA9IG5ldyBTdHJlYW0oKTtcbm5ldmVyUy5fZW1pdEVuZCgpO1xubmV2ZXJTLl9uYW1lID0gJ25ldmVyJztcblxuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gIHJldHVybiBuZXZlclM7XG59XG5cbmZ1bmN0aW9uIHRpbWVCYXNlZChtaXhpbikge1xuICBmdW5jdGlvbiBBbm9ueW1vdXNTdHJlYW0od2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgICB0aGlzLl93YWl0ID0gd2FpdDtcbiAgICB0aGlzLl9pbnRlcnZhbElkID0gbnVsbDtcbiAgICB0aGlzLl8kb25UaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9vblRpY2soKTtcbiAgICB9O1xuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gIH1cblxuICBpbmhlcml0KEFub255bW91c1N0cmVhbSwgU3RyZWFtLCB7XG4gICAgX2luaXQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9mcmVlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBfb25UaWNrOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy5fJG9uVGljaywgdGhpcy5fd2FpdCk7XG4gICAgfSxcbiAgICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbElkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTdHJlYW0ucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fJG9uVGljayA9IG51bGw7XG4gICAgICB0aGlzLl9mcmVlKCk7XG4gICAgfVxuICB9LCBtaXhpbik7XG5cbiAgcmV0dXJuIEFub255bW91c1N0cmVhbTtcbn1cblxudmFyIFMgPSB0aW1lQmFzZWQoe1xuICBfbmFtZTogJ2xhdGVyJyxcblxuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgeCA9IF9yZWYueDtcblxuICAgIHRoaXMuX3ggPSB4O1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ggPSBudWxsO1xuICB9LFxuICBfb25UaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX3gpO1xuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGxhdGVyKHdhaXQsIHgpIHtcbiAgcmV0dXJuIG5ldyBTKHdhaXQsIHsgeDogeCB9KTtcbn1cblxudmFyIFMkMSA9IHRpbWVCYXNlZCh7XG4gIF9uYW1lOiAnaW50ZXJ2YWwnLFxuXG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB4ID0gX3JlZi54O1xuXG4gICAgdGhpcy5feCA9IHg7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5feCA9IG51bGw7XG4gIH0sXG4gIF9vblRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5feCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpbnRlcnZhbCh3YWl0LCB4KSB7XG4gIHJldHVybiBuZXcgUyQxKHdhaXQsIHsgeDogeCB9KTtcbn1cblxudmFyIFMkMiA9IHRpbWVCYXNlZCh7XG4gIF9uYW1lOiAnc2VxdWVudGlhbGx5JyxcblxuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgeHMgPSBfcmVmLnhzO1xuXG4gICAgdGhpcy5feHMgPSBjbG9uZUFycmF5KHhzKTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl94cyA9IG51bGw7XG4gIH0sXG4gIF9vblRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5feHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5feHNbMF0pO1xuICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5feHMuc2hpZnQoKSk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gc2VxdWVudGlhbGx5KHdhaXQsIHhzKSB7XG4gIHJldHVybiB4cy5sZW5ndGggPT09IDAgPyBuZXZlcigpIDogbmV3IFMkMih3YWl0LCB7IHhzOiB4cyB9KTtcbn1cblxudmFyIFMkMyA9IHRpbWVCYXNlZCh7XG4gIF9uYW1lOiAnZnJvbVBvbGwnLFxuXG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX29uVGljazogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHRoaXMuX2VtaXRWYWx1ZShmbigpKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGZyb21Qb2xsKHdhaXQsIGZuKSB7XG4gIHJldHVybiBuZXcgUyQzKHdhaXQsIHsgZm46IGZuIH0pO1xufVxuXG5mdW5jdGlvbiBlbWl0dGVyKG9icykge1xuICBmdW5jdGlvbiB2YWx1ZSh4KSB7XG4gICAgb2JzLl9lbWl0VmFsdWUoeCk7XG4gICAgcmV0dXJuIG9icy5fYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IoeCkge1xuICAgIG9icy5fZW1pdEVycm9yKHgpO1xuICAgIHJldHVybiBvYnMuX2FjdGl2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCgpIHtcbiAgICBvYnMuX2VtaXRFbmQoKTtcbiAgICByZXR1cm4gb2JzLl9hY3RpdmU7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudChlKSB7XG4gICAgb2JzLl9lbWl0KGUudHlwZSwgZS52YWx1ZSk7XG4gICAgcmV0dXJuIG9icy5fYWN0aXZlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZXJyb3I6IGVycm9yLFxuICAgIGVuZDogZW5kLFxuICAgIGV2ZW50OiBldmVudCxcblxuICAgIC8vIGxlZ2FjeVxuICAgIGVtaXQ6IHZhbHVlLFxuICAgIGVtaXRFdmVudDogZXZlbnRcbiAgfTtcbn1cblxudmFyIFMkNCA9IHRpbWVCYXNlZCh7XG4gIF9uYW1lOiAnd2l0aEludGVydmFsJyxcblxuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlcih0aGlzKTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XG4gIH0sXG4gIF9vblRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBmbih0aGlzLl9lbWl0dGVyKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdpdGhJbnRlcnZhbCh3YWl0LCBmbikge1xuICByZXR1cm4gbmV3IFMkNCh3YWl0LCB7IGZuOiBmbiB9KTtcbn1cblxuZnVuY3Rpb24gUyQ1KGZuKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuICB0aGlzLl9mbiA9IGZuO1xuICB0aGlzLl91bnN1YnNjcmliZSA9IG51bGw7XG59XG5cbmluaGVyaXQoUyQ1LCBTdHJlYW0sIHtcbiAgX25hbWU6ICdzdHJlYW0nLFxuXG4gIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBmbihlbWl0dGVyKHRoaXMpKTtcbiAgICB0aGlzLl91bnN1YnNjcmliZSA9IHR5cGVvZiB1bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyA/IHVuc3Vic2NyaWJlIDogbnVsbDtcblxuICAgIC8vIGZpeCBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvMzVcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fY2FsbFVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LFxuICBfY2FsbFVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgX29uRGVhY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FsbFVuc3Vic2NyaWJlKCk7XG4gIH0sXG4gIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9XG59KTtcblxuZnVuY3Rpb24gc3RyZWFtKGZuKSB7XG4gIHJldHVybiBuZXcgUyQ1KGZuKTtcbn1cblxuZnVuY3Rpb24gZnJvbUNhbGxiYWNrKGNhbGxiYWNrQ29uc3VtZXIpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBzdHJlYW0oZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGJhY2tDb25zdW1lcihmdW5jdGlvbiAoeCkge1xuICAgICAgICBlbWl0dGVyLmVtaXQoeCk7XG4gICAgICAgIGVtaXR0ZXIuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICB9KS5zZXROYW1lKCdmcm9tQ2FsbGJhY2snKTtcbn1cblxuZnVuY3Rpb24gZnJvbU5vZGVDYWxsYmFjayhjYWxsYmFja0NvbnN1bWVyKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gc3RyZWFtKGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxiYWNrQ29uc3VtZXIoZnVuY3Rpb24gKGVycm9yLCB4KSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGVtaXR0ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVtaXR0ZXIuZW1pdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLmVuZCgpO1xuICAgICAgfSk7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSkuc2V0TmFtZSgnZnJvbU5vZGVDYWxsYmFjaycpO1xufVxuXG5mdW5jdGlvbiBzcHJlYWQoZm4sIGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0pO1xuICAgICAgfTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0sIGFbMV0pO1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgfTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhKTtcbiAgICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHkoZm4sIGMsIGEpIHtcbiAgdmFyIGFMZW5ndGggPSBhID8gYS5sZW5ndGggOiAwO1xuICBpZiAoYyA9PSBudWxsKSB7XG4gICAgc3dpdGNoIChhTGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZm4oYVswXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBmbihhWzBdLCBhWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIGZuKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gZm4oYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoYUxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZm4uY2FsbChjKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjLCBhKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbVN1YlVuc3ViKHN1YiwgdW5zdWIsIHRyYW5zZm9ybWVyIC8qIEZ1bmN0aW9uIHwgZmFsc2V5ICovKSB7XG4gIHJldHVybiBzdHJlYW0oZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRyYW5zZm9ybWVyID8gZnVuY3Rpb24gKCkge1xuICAgICAgZW1pdHRlci5lbWl0KGFwcGx5KHRyYW5zZm9ybWVyLCB0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9IDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCh4KTtcbiAgICB9O1xuXG4gICAgc3ViKGhhbmRsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5zdWIoaGFuZGxlcik7XG4gICAgfTtcbiAgfSkuc2V0TmFtZSgnZnJvbVN1YlVuc3ViJyk7XG59XG5cbnZhciBwYWlycyA9IFtbJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lciddLCBbJ2FkZExpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ10sIFsnb24nLCAnb2ZmJ11dO1xuXG5mdW5jdGlvbiBmcm9tRXZlbnRzKHRhcmdldCwgZXZlbnROYW1lLCB0cmFuc2Zvcm1lcikge1xuICB2YXIgc3ViID0gdm9pZCAwLFxuICAgICAgdW5zdWIgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0W3BhaXJzW2ldWzBdXSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGFyZ2V0W3BhaXJzW2ldWzFdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3ViID0gcGFpcnNbaV1bMF07XG4gICAgICB1bnN1YiA9IHBhaXJzW2ldWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1YiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGRvbid0IHN1cHBvcnQgYW55IG9mIFwiICsgJ2FkZEV2ZW50TGlzdGVuZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYWRkTGlzdGVuZXIvcmVtb3ZlTGlzdGVuZXIsIG9uL29mZiBtZXRob2QgcGFpcicpO1xuICB9XG5cbiAgcmV0dXJuIGZyb21TdWJVbnN1YihmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0YXJnZXRbc3ViXShldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9LCBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0YXJnZXRbdW5zdWJdKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0sIHRyYW5zZm9ybWVyKS5zZXROYW1lKCdmcm9tRXZlbnRzJyk7XG59XG5cbi8vIEhBQ0s6XG4vLyAgIFdlIGRvbid0IGNhbGwgcGFyZW50IENsYXNzIGNvbnN0cnVjdG9yLCBidXQgaW5zdGVhZCBwdXR0aW5nIGFsbCBuZWNlc3Nhcnlcbi8vICAgcHJvcGVydGllcyBpbnRvIHByb3RvdHlwZSB0byBzaW11bGF0ZSBlbmRlZCBQcm9wZXJ0eVxuLy8gICAoc2VlIFByb3BwZXJ0eSBhbmQgT2JzZXJ2YWJsZSBjbGFzc2VzKS5cblxuZnVuY3Rpb24gUCh2YWx1ZSkge1xuICB0aGlzLl9jdXJyZW50RXZlbnQgPSB7IHR5cGU6ICd2YWx1ZScsIHZhbHVlOiB2YWx1ZSwgY3VycmVudDogdHJ1ZSB9O1xufVxuXG5pbmhlcml0KFAsIFByb3BlcnR5LCB7XG4gIF9uYW1lOiAnY29uc3RhbnQnLFxuICBfYWN0aXZlOiBmYWxzZSxcbiAgX2FjdGl2YXRpbmc6IGZhbHNlLFxuICBfYWxpdmU6IGZhbHNlLFxuICBfZGlzcGF0Y2hlcjogbnVsbCxcbiAgX2xvZ0hhbmRsZXJzOiBudWxsXG59KTtcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gbmV3IFAoeCk7XG59XG5cbi8vIEhBQ0s6XG4vLyAgIFdlIGRvbid0IGNhbGwgcGFyZW50IENsYXNzIGNvbnN0cnVjdG9yLCBidXQgaW5zdGVhZCBwdXR0aW5nIGFsbCBuZWNlc3Nhcnlcbi8vICAgcHJvcGVydGllcyBpbnRvIHByb3RvdHlwZSB0byBzaW11bGF0ZSBlbmRlZCBQcm9wZXJ0eVxuLy8gICAoc2VlIFByb3BwZXJ0eSBhbmQgT2JzZXJ2YWJsZSBjbGFzc2VzKS5cblxuZnVuY3Rpb24gUCQxKHZhbHVlKSB7XG4gIHRoaXMuX2N1cnJlbnRFdmVudCA9IHsgdHlwZTogJ2Vycm9yJywgdmFsdWU6IHZhbHVlLCBjdXJyZW50OiB0cnVlIH07XG59XG5cbmluaGVyaXQoUCQxLCBQcm9wZXJ0eSwge1xuICBfbmFtZTogJ2NvbnN0YW50RXJyb3InLFxuICBfYWN0aXZlOiBmYWxzZSxcbiAgX2FjdGl2YXRpbmc6IGZhbHNlLFxuICBfYWxpdmU6IGZhbHNlLFxuICBfZGlzcGF0Y2hlcjogbnVsbCxcbiAgX2xvZ0hhbmRsZXJzOiBudWxsXG59KTtcblxuZnVuY3Rpb24gY29uc3RhbnRFcnJvcih4KSB7XG4gIHJldHVybiBuZXcgUCQxKHgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb25zdHJ1Y3RvcihCYXNlQ2xhc3MsIG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEFub255bW91c09ic2VydmFibGUoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIEJhc2VDbGFzcy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9uYW1lID0gc291cmNlLl9uYW1lICsgJy4nICsgbmFtZTtcbiAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIHRoaXMuXyRoYW5kbGVBbnkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlQW55KGV2ZW50KTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc01ldGhvZHMoQmFzZUNsYXNzKSB7XG4gIHJldHVybiB7XG4gICAgX2luaXQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9mcmVlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfSxcbiAgICBfaGFuZGxlRXJyb3I6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IoeCk7XG4gICAgfSxcbiAgICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSxcbiAgICBfaGFuZGxlQW55OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFZBTFVFOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVWYWx1ZShldmVudC52YWx1ZSk7XG4gICAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUVuZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc291cmNlLm9uQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgIH0sXG4gICAgX29uRGVhY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgIH0sXG4gICAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBCYXNlQ2xhc3MucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuXyRoYW5kbGVBbnkgPSBudWxsO1xuICAgICAgdGhpcy5fZnJlZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtKG5hbWUsIG1peGluKSB7XG4gIHZhciBTID0gY3JlYXRlQ29uc3RydWN0b3IoU3RyZWFtLCBuYW1lKTtcbiAgaW5oZXJpdChTLCBTdHJlYW0sIGNyZWF0ZUNsYXNzTWV0aG9kcyhTdHJlYW0pLCBtaXhpbik7XG4gIHJldHVybiBTO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eShuYW1lLCBtaXhpbikge1xuICB2YXIgUCA9IGNyZWF0ZUNvbnN0cnVjdG9yKFByb3BlcnR5LCBuYW1lKTtcbiAgaW5oZXJpdChQLCBQcm9wZXJ0eSwgY3JlYXRlQ2xhc3NNZXRob2RzKFByb3BlcnR5KSwgbWl4aW4pO1xuICByZXR1cm4gUDtcbn1cblxudmFyIFAkMiA9IGNyZWF0ZVByb3BlcnR5KCd0b1Byb3BlcnR5Jywge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZ2V0SW5pdGlhbEN1cnJlbnQgPSBmbjtcbiAgfSxcbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9nZXRJbml0aWFsQ3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGdldEluaXRpYWwgPSB0aGlzLl9nZXRJbml0aWFsQ3VycmVudDtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZShnZXRJbml0aWFsKCkpO1xuICAgIH1cbiAgICB0aGlzLl9zb3VyY2Uub25BbnkodGhpcy5fJGhhbmRsZUFueSk7IC8vIGNvcGllZCBmcm9tIHBhdHRlcm5zL29uZS1zb3VyY2VcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRvUHJvcGVydHkob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICBpZiAoZm4gIT09IG51bGwgJiYgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2hvdWxkIGNhbGwgdG9Qcm9wZXJ0eSgpIHdpdGggYSBmdW5jdGlvbiBvciBubyBhcmd1bWVudHMuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQJDIob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIFMkNiA9IGNyZWF0ZVN0cmVhbSgnY2hhbmdlcycsIHtcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIGlmICghdGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIGlmICghdGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKHgpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNoYW5nZXMob2JzKSB7XG4gIHJldHVybiBuZXcgUyQ2KG9icyk7XG59XG5cbmZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHZhciByZXN1bHQgPSBzdHJlYW0oZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdmFyIG9uVmFsdWUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBlbWl0dGVyLmVtaXQoeCk7XG4gICAgICAgIGVtaXR0ZXIuZW5kKCk7XG4gICAgICB9O1xuICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBlbWl0dGVyLmVycm9yKHgpO1xuICAgICAgICBlbWl0dGVyLmVuZCgpO1xuICAgICAgfTtcbiAgICAgIHZhciBfcHJvbWlzZSA9IHByb21pc2UudGhlbihvblZhbHVlLCBvbkVycm9yKTtcblxuICAgICAgLy8gcHJldmVudCBsaWJyYXJpZXMgbGlrZSAnUScgb3IgJ3doZW4nIGZyb20gc3dhbGxvd2luZyBleGNlcHRpb25zXG4gICAgICBpZiAoX3Byb21pc2UgJiYgdHlwZW9mIF9wcm9taXNlLmRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3Byb21pc2UuZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRvUHJvcGVydHkocmVzdWx0LCBudWxsKS5zZXROYW1lKCdmcm9tUHJvbWlzZScpO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9kYWxQcm9taXNlKCkge1xuICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gUHJvbWlzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpc24ndCBkZWZhdWx0IFByb21pc2UsIHVzZSBzaGltIG9yIHBhcmFtZXRlclwiKTtcbiAgfVxufVxuXG52YXIgdG9Qcm9taXNlID0gZnVuY3Rpb24gKG9icykge1xuICB2YXIgUHJvbWlzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZ2V0R2xvZGFsUHJvbWlzZSgpO1xuXG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBvYnMub25BbnkoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRU5EICYmIGxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgKGxhc3QudHlwZSA9PT0gVkFMVUUgPyByZXNvbHZlIDogcmVqZWN0KShsYXN0LnZhbHVlKTtcbiAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0ID0gZXZlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiBnbG9iYWwgd2luZG93ICovXG52YXIgcm9vdDtcblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpO1xuXG4vLyB0aGlzIGZpbGUgY29udGFpbnMgc29tZSBob3QgSlMgbW9kdWxlcyBzeXN0ZW1zIHN0dWZmXG5cbnZhciAkJG9ic2VydmFibGUgPSByZXN1bHQuZGVmYXVsdCA/IHJlc3VsdC5kZWZhdWx0IDogcmVzdWx0O1xuXG5mdW5jdGlvbiBmcm9tRVNPYnNlcnZhYmxlKF9vYnNlcnZhYmxlKSB7XG4gIHZhciBvYnNlcnZhYmxlID0gX29ic2VydmFibGVbJCRvYnNlcnZhYmxlXSA/IF9vYnNlcnZhYmxlWyQkb2JzZXJ2YWJsZV0oKSA6IF9vYnNlcnZhYmxlO1xuICByZXR1cm4gc3RyZWFtKGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gICAgdmFyIHVuc3ViID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBlbWl0dGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgZW1pdHRlci5lbmQoKTtcbiAgICAgIH0sXG4gICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBlbWl0dGVyLmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHVuc3ViLnVuc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bnN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIH1cbiAgfSkuc2V0TmFtZSgnZnJvbUVTT2JzZXJ2YWJsZScpO1xufVxuXG5mdW5jdGlvbiBFU09ic2VydmFibGUob2JzZXJ2YWJsZSkge1xuICB0aGlzLl9vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZS50YWtlRXJyb3JzKDEpO1xufVxuXG5leHRlbmQoRVNPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvYnNlcnZlciA9IHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnZnVuY3Rpb24nID8geyBuZXh0OiBvYnNlcnZlck9yT25OZXh0LCBlcnJvcjogb25FcnJvciwgY29tcGxldGU6IG9uQ29tcGxldGUgfSA6IG9ic2VydmVyT3JPbk5leHQ7XG5cbiAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBFTkQpIHtcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFZBTFVFICYmIG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChldmVudC52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SICYmIG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRU5EICYmIG9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fb2JzZXJ2YWJsZS5vbkFueShmbik7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLl9vYnNlcnZhYmxlLm9mZkFueShmbik7XG4gICAgICB9LFxuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbn0pO1xuXG4vLyBOZWVkIHRvIGFzc2lnbiBkaXJlY3RseSBiL2MgU3ltYm9scyBhcmVuJ3QgZW51bWVyYWJsZS5cbkVTT2JzZXJ2YWJsZS5wcm90b3R5cGVbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB0b0VTT2JzZXJ2YWJsZSgpIHtcbiAgcmV0dXJuIG5ldyBFU09ic2VydmFibGUodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Qoc291cmNlLCBrZXlzLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB2YWx1ZXMucHVzaChzb3VyY2VbcHJvcF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JzQ29tYmluYXRvcihlcnJvcnMpIHtcbiAgdmFyIGxhdGVzdEVycm9yID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlcnJvcnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGxhdGVzdEVycm9yID09PSB1bmRlZmluZWQgfHwgbGF0ZXN0RXJyb3IuaW5kZXggPCBlcnJvcnNbaV0uaW5kZXgpIHtcbiAgICAgICAgbGF0ZXN0RXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXRlc3RFcnJvci5lcnJvcjtcbn1cblxuZnVuY3Rpb24gQ29tYmluZShhY3RpdmUsIHBhc3NpdmUsIGNvbWJpbmF0b3IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgdGhpcy5fYWN0aXZlQ291bnQgPSBhY3RpdmUubGVuZ3RoO1xuICB0aGlzLl9zb3VyY2VzID0gY29uY2F0KGFjdGl2ZSwgcGFzc2l2ZSk7XG4gIHRoaXMuX2NvbWJpbmF0b3IgPSBjb21iaW5hdG9yO1xuICB0aGlzLl9hbGl2ZUNvdW50ID0gMDtcbiAgdGhpcy5fbGF0ZXN0VmFsdWVzID0gbmV3IEFycmF5KHRoaXMuX3NvdXJjZXMubGVuZ3RoKTtcbiAgdGhpcy5fbGF0ZXN0RXJyb3JzID0gbmV3IEFycmF5KHRoaXMuX3NvdXJjZXMubGVuZ3RoKTtcbiAgZmlsbEFycmF5KHRoaXMuX2xhdGVzdFZhbHVlcywgTk9USElORyk7XG4gIHRoaXMuX2VtaXRBZnRlckFjdGl2YXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fZW5kQWZ0ZXJBY3RpdmF0aW9uID0gZmFsc2U7XG4gIHRoaXMuX2xhdGVzdEVycm9ySW5kZXggPSAwO1xuXG4gIHRoaXMuXyRoYW5kbGVycyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgX3RoaXMuXyRoYW5kbGVycy5wdXNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoaSwgZXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG59XG5cbmluaGVyaXQoQ29tYmluZSwgU3RyZWFtLCB7XG4gIF9uYW1lOiAnY29tYmluZScsXG5cbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FsaXZlQ291bnQgPSB0aGlzLl9hY3RpdmVDb3VudDtcblxuICAgIC8vIHdlIG5lZWQgdG8gc3VzY3JpYmUgdG8gX3Bhc3NpdmVfIHNvdXJjZXMgYmVmb3JlIF9hY3RpdmVfXG4gICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvOTgpXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2FjdGl2ZUNvdW50OyBpIDwgdGhpcy5fc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc291cmNlc1tpXS5vbkFueSh0aGlzLl8kaGFuZGxlcnNbaV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5fYWN0aXZlQ291bnQ7IF9pKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbX2ldLm9uQW55KHRoaXMuXyRoYW5kbGVyc1tfaV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0QWZ0ZXJBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLl9lbWl0QWZ0ZXJBY3RpdmF0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbWl0SWZGdWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmRBZnRlckFjdGl2YXRpb24pIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9zb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgaSA9IHZvaWQgMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbaV0ub2ZmQW55KHRoaXMuXyRoYW5kbGVyc1tpXSk7XG4gICAgfVxuICB9LFxuICBfZW1pdElmRnVsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNBbGxWYWx1ZXMgPSB0cnVlO1xuICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGF0ZXN0VmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzQ29weSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHZhciBlcnJvcnNDb3B5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNDb3B5W2ldID0gdGhpcy5fbGF0ZXN0VmFsdWVzW2ldO1xuICAgICAgZXJyb3JzQ29weVtpXSA9IHRoaXMuX2xhdGVzdEVycm9yc1tpXTtcblxuICAgICAgaWYgKHZhbHVlc0NvcHlbaV0gPT09IE5PVEhJTkcpIHtcbiAgICAgICAgaGFzQWxsVmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcnNDb3B5W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzQWxsVmFsdWVzKSB7XG4gICAgICB2YXIgY29tYmluYXRvciA9IHRoaXMuX2NvbWJpbmF0b3I7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoY29tYmluYXRvcih2YWx1ZXNDb3B5KSk7XG4gICAgfVxuICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihkZWZhdWx0RXJyb3JzQ29tYmluYXRvcihlcnJvcnNDb3B5KSk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlQW55OiBmdW5jdGlvbiAoaSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUgfHwgZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBWQUxVRSkge1xuICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZXNbaV0gPSBldmVudC52YWx1ZTtcbiAgICAgICAgdGhpcy5fbGF0ZXN0RXJyb3JzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SKSB7XG4gICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlc1tpXSA9IE5PVEhJTkc7XG4gICAgICAgIHRoaXMuX2xhdGVzdEVycm9yc1tpXSA9IHtcbiAgICAgICAgICBpbmRleDogdGhpcy5fbGF0ZXN0RXJyb3JJbmRleCsrLFxuICAgICAgICAgIGVycm9yOiBldmVudC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEFmdGVyQWN0aXZhdGlvbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW1pdElmRnVsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVORFxuXG4gICAgICBpZiAoaSA8IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2FsaXZlQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX2FsaXZlQ291bnQgPT09IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgICAgICAgdGhpcy5fZW5kQWZ0ZXJBY3RpdmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlc3RWYWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xhdGVzdEVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5fY29tYmluYXRvciA9IG51bGw7XG4gICAgdGhpcy5fJGhhbmRsZXJzID0gbnVsbDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc0FycmF5KGFjdGl2ZSkge1xuICB2YXIgcGFzc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciBjb21iaW5hdG9yID0gYXJndW1lbnRzWzJdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShwYXNzaXZlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tYmluZSBjYW4gb25seSBjb21iaW5lIGFjdGl2ZSBhbmQgcGFzc2l2ZSBjb2xsZWN0aW9ucyBvZiB0aGUgc2FtZSB0eXBlLicpO1xuICB9XG5cbiAgY29tYmluYXRvciA9IGNvbWJpbmF0b3IgPyBzcHJlYWQoY29tYmluYXRvciwgYWN0aXZlLmxlbmd0aCArIHBhc3NpdmUubGVuZ3RoKSA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG4gIHJldHVybiBhY3RpdmUubGVuZ3RoID09PSAwID8gbmV2ZXIoKSA6IG5ldyBDb21iaW5lKGFjdGl2ZSwgcGFzc2l2ZSwgY29tYmluYXRvcik7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc09iamVjdChhY3RpdmUpIHtcbiAgdmFyIHBhc3NpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY29tYmluYXRvciA9IGFyZ3VtZW50c1syXTtcblxuICBpZiAodHlwZW9mIHBhc3NpdmUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocGFzc2l2ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmUgY2FuIG9ubHkgY29tYmluZSBhY3RpdmUgYW5kIHBhc3NpdmUgY29sbGVjdGlvbnMgb2YgdGhlIHNhbWUgdHlwZS4nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW10sXG4gICAgICBhY3RpdmVPYnNlcnZhYmxlcyA9IFtdLFxuICAgICAgcGFzc2l2ZU9ic2VydmFibGVzID0gW107XG5cbiAgY29sbGVjdChhY3RpdmUsIGtleXMsIGFjdGl2ZU9ic2VydmFibGVzKTtcbiAgY29sbGVjdChwYXNzaXZlLCBrZXlzLCBwYXNzaXZlT2JzZXJ2YWJsZXMpO1xuXG4gIHZhciBvYmplY3RpZnkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIGV2ZW50ID0ge307XG4gICAgZm9yICh2YXIgaSA9IHZhbHVlcy5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgZXZlbnRba2V5c1tpXV0gPSB2YWx1ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5hdG9yID8gY29tYmluYXRvcihldmVudCkgOiBldmVudDtcbiAgfTtcblxuICByZXR1cm4gYWN0aXZlT2JzZXJ2YWJsZXMubGVuZ3RoID09PSAwID8gbmV2ZXIoKSA6IG5ldyBDb21iaW5lKGFjdGl2ZU9ic2VydmFibGVzLCBwYXNzaXZlT2JzZXJ2YWJsZXMsIG9iamVjdGlmeSk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmUoYWN0aXZlLCBwYXNzaXZlLCBjb21iaW5hdG9yKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbWJpbmF0b3IgPSBwYXNzaXZlO1xuICAgIHBhc3NpdmUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhY3RpdmUpID8gY29tYmluZUFzQXJyYXkoYWN0aXZlLCBwYXNzaXZlLCBjb21iaW5hdG9yKSA6IGNvbWJpbmVBc09iamVjdChhY3RpdmUsIHBhc3NpdmUsIGNvbWJpbmF0b3IpO1xufVxuXG52YXIgT2JzZXJ2YWJsZSQyID0ge1xuICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXZlcigpO1xuICB9LFxuXG5cbiAgLy8gTW9ub2lkIGJhc2VkIG9uIG1lcmdlKCkgc2VlbXMgbW9yZSB1c2VmdWwgdGhhbiBvbmUgYmFzZWQgb24gY29uY2F0KCkuXG4gIGNvbmNhdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5tZXJnZShiKTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGNvbnN0YW50KHgpO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uIChmbiwgb2JzKSB7XG4gICAgcmV0dXJuIG9icy5tYXAoZm4pO1xuICB9LFxuICBiaW1hcDogZnVuY3Rpb24gKGZuRXJyLCBmblZhbCwgb2JzKSB7XG4gICAgcmV0dXJuIG9icy5tYXBFcnJvcnMoZm5FcnIpLm1hcChmblZhbCk7XG4gIH0sXG5cblxuICAvLyBUaGlzIGFwIHN0cmljdGx5IHNwZWFraW5nIGluY29tcGF0aWJsZSB3aXRoIGNoYWluLiBJZiB3ZSBkZXJpdmUgYXAgZnJvbSBjaGFpbiB3ZSBnZXRcbiAgLy8gZGlmZmVyZW50IChub3QgdmVyeSB1c2VmdWwpIGJlaGF2aW9yLiBCdXQgc3BlYyByZXF1aXJlcyB0aGF0IGlmIG1ldGhvZCBjYW4gYmUgZGVyaXZlZFxuICAvLyBpdCBtdXN0IGhhdmUgdGhlIHNhbWUgYmVoYXZpb3IgYXMgaGFuZC13cml0dGVuIG1ldGhvZC4gV2UgaW50ZW50aW9uYWxseSB2aW9sYXRlIHRoZSBzcGVjXG4gIC8vIGluIGhvcGUgdGhhdCBpdCB3b24ndCBjYXVzZSBtYW55IHRyb3VibGVzIGluIHByYWN0aWNlLiBBbmQgaW4gcmV0dXJuIHdlIGhhdmUgbW9yZSB1c2VmdWwgdHlwZS5cbiAgYXA6IGZ1bmN0aW9uIChvYnNGbiwgb2JzVmFsKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUoW29ic0ZuLCBvYnNWYWxdLCBmdW5jdGlvbiAoZm4sIHZhbCkge1xuICAgICAgcmV0dXJuIGZuKHZhbCk7XG4gICAgfSk7XG4gIH0sXG4gIGNoYWluOiBmdW5jdGlvbiAoZm4sIG9icykge1xuICAgIHJldHVybiBvYnMuZmxhdE1hcChmbik7XG4gIH1cbn07XG5cblxuXG52YXIgc3RhdGljTGFuZCA9IE9iamVjdC5mcmVlemUoe1xuXHRPYnNlcnZhYmxlOiBPYnNlcnZhYmxlJDJcbn0pO1xuXG52YXIgbWl4aW4gPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHRoaXMuX2VtaXRWYWx1ZShmbih4KSk7XG4gIH1cbn07XG5cbnZhciBTJDcgPSBjcmVhdGVTdHJlYW0oJ21hcCcsIG1peGluKTtcbnZhciBQJDMgPSBjcmVhdGVQcm9wZXJ0eSgnbWFwJywgbWl4aW4pO1xuXG52YXIgaWQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIG1hcCQxKG9icykge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDcsIFAkMykpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQxID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAoZm4oeCkpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDggPSBjcmVhdGVTdHJlYW0oJ2ZpbHRlcicsIG1peGluJDEpO1xudmFyIFAkNCA9IGNyZWF0ZVByb3BlcnR5KCdmaWx0ZXInLCBtaXhpbiQxKTtcblxudmFyIGlkJDEgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlcihvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQxO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDgsIFAkNCkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQyID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbiA9IF9yZWYubjtcblxuICAgIHRoaXMuX24gPSBuO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9uLS07XG4gICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIGlmICh0aGlzLl9uID09PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQ5ID0gY3JlYXRlU3RyZWFtKCd0YWtlJywgbWl4aW4kMik7XG52YXIgUCQ1ID0gY3JlYXRlUHJvcGVydHkoJ3Rha2UnLCBtaXhpbiQyKTtcblxuZnVuY3Rpb24gdGFrZShvYnMsIG4pIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkOSwgUCQ1KSkob2JzLCB7IG46IG4gfSk7XG59XG5cbnZhciBtaXhpbiQzID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbiA9IF9yZWYubjtcblxuICAgIHRoaXMuX24gPSBuO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9uLS07XG4gICAgdGhpcy5fZW1pdEVycm9yKHgpO1xuICAgIGlmICh0aGlzLl9uID09PSAwKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMCA9IGNyZWF0ZVN0cmVhbSgndGFrZUVycm9ycycsIG1peGluJDMpO1xudmFyIFAkNiA9IGNyZWF0ZVByb3BlcnR5KCd0YWtlRXJyb3JzJywgbWl4aW4kMyk7XG5cbmZ1bmN0aW9uIHRha2VFcnJvcnMob2JzLCBuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEwLCBQJDYpKShvYnMsIHsgbjogbiB9KTtcbn1cblxudmFyIG1peGluJDQgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmIChmbih4KSkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMSA9IGNyZWF0ZVN0cmVhbSgndGFrZVdoaWxlJywgbWl4aW4kNCk7XG52YXIgUCQ3ID0gY3JlYXRlUHJvcGVydHkoJ3Rha2VXaGlsZScsIG1peGluJDQpO1xuXG52YXIgaWQkMiA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gdGFrZVdoaWxlKG9icykge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkJDI7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMTEsIFAkNykpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQ1ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IE5PVEhJTkc7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbGFzdFZhbHVlID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IHg7XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbGFzdFZhbHVlICE9PSBOT1RISU5HKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9XG59O1xuXG52YXIgUyQxMiA9IGNyZWF0ZVN0cmVhbSgnbGFzdCcsIG1peGluJDUpO1xudmFyIFAkOCA9IGNyZWF0ZVByb3BlcnR5KCdsYXN0JywgbWl4aW4kNSk7XG5cbmZ1bmN0aW9uIGxhc3Qob2JzKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEyLCBQJDgpKShvYnMpO1xufVxuXG52YXIgbWl4aW4kNiA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG4gPSBfcmVmLm47XG5cbiAgICB0aGlzLl9uID0gTWF0aC5tYXgoMCwgbik7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbiA9PT0gMCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uLS07XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxMyA9IGNyZWF0ZVN0cmVhbSgnc2tpcCcsIG1peGluJDYpO1xudmFyIFAkOSA9IGNyZWF0ZVByb3BlcnR5KCdza2lwJywgbWl4aW4kNik7XG5cbmZ1bmN0aW9uIHNraXAob2JzLCBuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDEzLCBQJDkpKShvYnMsIHsgbjogbiB9KTtcbn1cblxudmFyIG1peGluJDcgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmICh0aGlzLl9mbiAhPT0gbnVsbCAmJiAhZm4oeCkpIHtcbiAgICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZuID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNCA9IGNyZWF0ZVN0cmVhbSgnc2tpcFdoaWxlJywgbWl4aW4kNyk7XG52YXIgUCQxMCA9IGNyZWF0ZVByb3BlcnR5KCdza2lwV2hpbGUnLCBtaXhpbiQ3KTtcblxudmFyIGlkJDMgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIHNraXBXaGlsZShvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQzO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDE0LCBQJDEwKSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIG1peGluJDggPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX3ByZXYgPSBOT1RISU5HO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIGlmICh0aGlzLl9wcmV2ID09PSBOT1RISU5HIHx8ICFmbih0aGlzLl9wcmV2LCB4KSkge1xuICAgICAgdGhpcy5fcHJldiA9IHg7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNSA9IGNyZWF0ZVN0cmVhbSgnc2tpcER1cGxpY2F0ZXMnLCBtaXhpbiQ4KTtcbnZhciBQJDExID0gY3JlYXRlUHJvcGVydHkoJ3NraXBEdXBsaWNhdGVzJywgbWl4aW4kOCk7XG5cbnZhciBlcSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gc2tpcER1cGxpY2F0ZXMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZXE7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMTUsIFAkMTEpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kOSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbixcbiAgICAgICAgc2VlZCA9IF9yZWYuc2VlZDtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gICAgdGhpcy5fcHJldiA9IHNlZWQ7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX3ByZXYgIT09IE5PVEhJTkcpIHtcbiAgICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKGZuKHRoaXMuX3ByZXYsIHgpKTtcbiAgICB9XG4gICAgdGhpcy5fcHJldiA9IHg7XG4gIH1cbn07XG5cbnZhciBTJDE2ID0gY3JlYXRlU3RyZWFtKCdkaWZmJywgbWl4aW4kOSk7XG52YXIgUCQxMiA9IGNyZWF0ZVByb3BlcnR5KCdkaWZmJywgbWl4aW4kOSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRGbihhLCBiKSB7XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmZ1bmN0aW9uIGRpZmYob2JzLCBmbikge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTk9USElORztcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQxNiwgUCQxMikpKG9icywgeyBmbjogZm4gfHwgZGVmYXVsdEZuLCBzZWVkOiBzZWVkIH0pO1xufVxuXG52YXIgUCQxMyA9IGNyZWF0ZVByb3BlcnR5KCdzY2FuJywge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuLFxuICAgICAgICBzZWVkID0gX3JlZi5zZWVkO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9zZWVkID0gc2VlZDtcbiAgICBpZiAoc2VlZCAhPT0gTk9USElORykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHNlZWQpO1xuICAgIH1cbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgdGhpcy5fc2VlZCA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAodGhpcy5fY3VycmVudEV2ZW50ID09PSBudWxsIHx8IHRoaXMuX2N1cnJlbnRFdmVudC50eXBlID09PSBFUlJPUikge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX3NlZWQgPT09IE5PVEhJTkcgPyB4IDogZm4odGhpcy5fc2VlZCwgeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoZm4odGhpcy5fY3VycmVudEV2ZW50LnZhbHVlLCB4KSk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gc2NhbihvYnMsIGZuKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBOT1RISU5HO1xuXG4gIHJldHVybiBuZXcgUCQxMyhvYnMsIHsgZm46IGZuLCBzZWVkOiBzZWVkIH0pO1xufVxuXG52YXIgbWl4aW4kMTAgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHZhciB4cyA9IGZuKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4c1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQxNyA9IGNyZWF0ZVN0cmVhbSgnZmxhdHRlbicsIG1peGluJDEwKTtcblxudmFyIGlkJDQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWQkNDtcblxuICByZXR1cm4gbmV3IFMkMTcob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIEVORF9NQVJLRVIgPSB7fTtcblxudmFyIG1peGluJDExID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQ7XG5cbiAgICB0aGlzLl93YWl0ID0gTWF0aC5tYXgoMCwgd2FpdCk7XG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIHRoaXMuXyRzaGlmdEJ1ZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfdGhpcy5fYnVmZi5zaGlmdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBFTkRfTUFSS0VSKSB7XG4gICAgICAgIF90aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fZW1pdFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICAgIHRoaXMuXyRzaGlmdEJ1ZmYgPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2YXRpbmcpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmZi5wdXNoKHgpO1xuICAgICAgc2V0VGltZW91dCh0aGlzLl8kc2hpZnRCdWZmLCB0aGlzLl93YWl0KTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZmLnB1c2goRU5EX01BUktFUik7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMuXyRzaGlmdEJ1ZmYsIHRoaXMuX3dhaXQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMTggPSBjcmVhdGVTdHJlYW0oJ2RlbGF5JywgbWl4aW4kMTEpO1xudmFyIFAkMTQgPSBjcmVhdGVQcm9wZXJ0eSgnZGVsYXknLCBtaXhpbiQxMSk7XG5cbmZ1bmN0aW9uIGRlbGF5KG9icywgd2FpdCkge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQxOCwgUCQxNCkpKG9icywgeyB3YWl0OiB3YWl0IH0pO1xufVxuXG52YXIgbm93ID0gRGF0ZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxudmFyIG1peGluJDEyID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQsXG4gICAgICAgIGxlYWRpbmcgPSBfcmVmLmxlYWRpbmcsXG4gICAgICAgIHRyYWlsaW5nID0gX3JlZi50cmFpbGluZztcblxuICAgIHRoaXMuX3dhaXQgPSBNYXRoLm1heCgwLCB3YWl0KTtcbiAgICB0aGlzLl9sZWFkaW5nID0gbGVhZGluZztcbiAgICB0aGlzLl90cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5fZW5kTGF0ZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0Q2FsbFRpbWUgPSAwO1xuICAgIHRoaXMuXyR0cmFpbGluZ0NhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX3RyYWlsaW5nQ2FsbCgpO1xuICAgIH07XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fJHRyYWlsaW5nQ2FsbCA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyVGltZSA9IG5vdygpO1xuICAgICAgaWYgKHRoaXMuX2xhc3RDYWxsVGltZSA9PT0gMCAmJiAhdGhpcy5fbGVhZGluZykge1xuICAgICAgICB0aGlzLl9sYXN0Q2FsbFRpbWUgPSBjdXJUaW1lO1xuICAgICAgfVxuICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMuX3dhaXQgLSAoY3VyVGltZSAtIHRoaXMuX2xhc3RDYWxsVGltZSk7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsVHJhaWxpbmcoKTtcbiAgICAgICAgdGhpcy5fbGFzdENhbGxUaW1lID0gY3VyVGltZTtcbiAgICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90cmFpbGluZykge1xuICAgICAgICB0aGlzLl9jYW5jZWxUcmFpbGluZygpO1xuICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0geDtcbiAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl8kdHJhaWxpbmdDYWxsLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQpIHtcbiAgICAgICAgdGhpcy5fZW5kTGF0ZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NhbmNlbFRyYWlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgX3RyYWlsaW5nQ2FsbDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl90cmFpbGluZ1ZhbHVlKTtcbiAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RDYWxsVGltZSA9ICF0aGlzLl9sZWFkaW5nID8gMCA6IG5vdygpO1xuICAgIGlmICh0aGlzLl9lbmRMYXRlcikge1xuICAgICAgdGhpcy5fZW1pdEVuZCgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFMkMTkgPSBjcmVhdGVTdHJlYW0oJ3Rocm90dGxlJywgbWl4aW4kMTIpO1xudmFyIFAkMTUgPSBjcmVhdGVQcm9wZXJ0eSgndGhyb3R0bGUnLCBtaXhpbiQxMik7XG5cbmZ1bmN0aW9uIHRocm90dGxlKG9icywgd2FpdCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgX3JlZjIkbGVhZGluZyA9IF9yZWYyLmxlYWRpbmcsXG4gICAgICBsZWFkaW5nID0gX3JlZjIkbGVhZGluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJGxlYWRpbmcsXG4gICAgICBfcmVmMiR0cmFpbGluZyA9IF9yZWYyLnRyYWlsaW5nLFxuICAgICAgdHJhaWxpbmcgPSBfcmVmMiR0cmFpbGluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJHRyYWlsaW5nO1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDE5LCBQJDE1KSkob2JzLCB7IHdhaXQ6IHdhaXQsIGxlYWRpbmc6IGxlYWRpbmcsIHRyYWlsaW5nOiB0cmFpbGluZyB9KTtcbn1cblxudmFyIG1peGluJDEzID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHdhaXQgPSBfcmVmLndhaXQsXG4gICAgICAgIGltbWVkaWF0ZSA9IF9yZWYuaW1tZWRpYXRlO1xuXG4gICAgdGhpcy5fd2FpdCA9IE1hdGgubWF4KDAsIHdhaXQpO1xuICAgIHRoaXMuX2ltbWVkaWF0ZSA9IGltbWVkaWF0ZTtcbiAgICB0aGlzLl9sYXN0QXR0ZW1wdCA9IDA7XG4gICAgdGhpcy5fdGltZW91dElkID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlclZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9lbmRMYXRlciA9IGZhbHNlO1xuICAgIHRoaXMuXyRsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fbGF0ZXIoKTtcbiAgICB9O1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2xhdGVyVmFsdWUgPSBudWxsO1xuICAgIHRoaXMuXyRsYXRlciA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZhdGluZykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0QXR0ZW1wdCA9IG5vdygpO1xuICAgICAgaWYgKHRoaXMuX2ltbWVkaWF0ZSAmJiAhdGhpcy5fdGltZW91dElkKSB7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fdGltZW91dElkKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fJGxhdGVyLCB0aGlzLl93YWl0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuX2xhdGVyVmFsdWUgPSB4O1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmF0aW5nKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQgJiYgIXRoaXMuX2ltbWVkaWF0ZSkge1xuICAgICAgICB0aGlzLl9lbmRMYXRlciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfbGF0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IG5vdygpIC0gdGhpcy5fbGFzdEF0dGVtcHQ7XG4gICAgaWYgKGxhc3QgPCB0aGlzLl93YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl8kbGF0ZXIsIHRoaXMuX3dhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGltZW91dElkID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5faW1tZWRpYXRlKSB7XG4gICAgICAgIHZhciBfbGF0ZXJWYWx1ZSA9IHRoaXMuX2xhdGVyVmFsdWU7XG4gICAgICAgIHRoaXMuX2xhdGVyVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWUoX2xhdGVyVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2VuZExhdGVyKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDIwID0gY3JlYXRlU3RyZWFtKCdkZWJvdW5jZScsIG1peGluJDEzKTtcbnZhciBQJDE2ID0gY3JlYXRlUHJvcGVydHkoJ2RlYm91bmNlJywgbWl4aW4kMTMpO1xuXG5mdW5jdGlvbiBkZWJvdW5jZShvYnMsIHdhaXQpIHtcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIF9yZWYyJGltbWVkaWF0ZSA9IF9yZWYyLmltbWVkaWF0ZSxcbiAgICAgIGltbWVkaWF0ZSA9IF9yZWYyJGltbWVkaWF0ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmMiRpbW1lZGlhdGU7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMjAsIFAkMTYpKShvYnMsIHsgd2FpdDogd2FpdCwgaW1tZWRpYXRlOiBpbW1lZGlhdGUgfSk7XG59XG5cbnZhciBtaXhpbiQxNCA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlRXJyb3I6IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGZuID0gdGhpcy5fZm47XG4gICAgdGhpcy5fZW1pdEVycm9yKGZuKHgpKTtcbiAgfVxufTtcblxudmFyIFMkMjEgPSBjcmVhdGVTdHJlYW0oJ21hcEVycm9ycycsIG1peGluJDE0KTtcbnZhciBQJDE3ID0gY3JlYXRlUHJvcGVydHkoJ21hcEVycm9ycycsIG1peGluJDE0KTtcblxudmFyIGlkJDUgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIG1hcEVycm9ycyhvYnMpIHtcbiAgdmFyIGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZCQ1O1xuXG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDIxLCBQJDE3KSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIG1peGluJDE1ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZm4gPSBfcmVmLmZuO1xuXG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbiA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAoZm4oeCkpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDIyID0gY3JlYXRlU3RyZWFtKCdmaWx0ZXJFcnJvcnMnLCBtaXhpbiQxNSk7XG52YXIgUCQxOCA9IGNyZWF0ZVByb3BlcnR5KCdmaWx0ZXJFcnJvcnMnLCBtaXhpbiQxNSk7XG5cbnZhciBpZCQ2ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXJFcnJvcnMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWQkNjtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyMiwgUCQxOCkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQxNiA9IHtcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoKSB7fVxufTtcblxudmFyIFMkMjMgPSBjcmVhdGVTdHJlYW0oJ2lnbm9yZVZhbHVlcycsIG1peGluJDE2KTtcbnZhciBQJDE5ID0gY3JlYXRlUHJvcGVydHkoJ2lnbm9yZVZhbHVlcycsIG1peGluJDE2KTtcblxuZnVuY3Rpb24gaWdub3JlVmFsdWVzKG9icykge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyMywgUCQxOSkpKG9icyk7XG59XG5cbnZhciBtaXhpbiQxNyA9IHtcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoKSB7fVxufTtcblxudmFyIFMkMjQgPSBjcmVhdGVTdHJlYW0oJ2lnbm9yZUVycm9ycycsIG1peGluJDE3KTtcbnZhciBQJDIwID0gY3JlYXRlUHJvcGVydHkoJ2lnbm9yZUVycm9ycycsIG1peGluJDE3KTtcblxuZnVuY3Rpb24gaWdub3JlRXJyb3JzKG9icykge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyNCwgUCQyMCkpKG9icyk7XG59XG5cbnZhciBtaXhpbiQxOCA9IHtcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge31cbn07XG5cbnZhciBTJDI1ID0gY3JlYXRlU3RyZWFtKCdpZ25vcmVFbmQnLCBtaXhpbiQxOCk7XG52YXIgUCQyMSA9IGNyZWF0ZVByb3BlcnR5KCdpZ25vcmVFbmQnLCBtaXhpbiQxOCk7XG5cbmZ1bmN0aW9uIGlnbm9yZUVuZChvYnMpIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMjUsIFAkMjEpKShvYnMpO1xufVxuXG52YXIgbWl4aW4kMTkgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHRoaXMuX2VtaXRWYWx1ZShmbigpKTtcbiAgICB0aGlzLl9lbWl0RW5kKCk7XG4gIH1cbn07XG5cbnZhciBTJDI2ID0gY3JlYXRlU3RyZWFtKCdiZWZvcmVFbmQnLCBtaXhpbiQxOSk7XG52YXIgUCQyMiA9IGNyZWF0ZVByb3BlcnR5KCdiZWZvcmVFbmQnLCBtaXhpbiQxOSk7XG5cbmZ1bmN0aW9uIGJlZm9yZUVuZChvYnMsIGZuKSB7XG4gIHJldHVybiBuZXcgKG9icy5fb2ZTYW1lVHlwZShTJDI2LCBQJDIyKSkob2JzLCB7IGZuOiBmbiB9KTtcbn1cblxudmFyIG1peGluJDIwID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbWluID0gX3JlZi5taW4sXG4gICAgICAgIG1heCA9IF9yZWYubWF4O1xuXG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9idWZmID0gW107XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYnVmZiA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmID0gc2xpZGUodGhpcy5fYnVmZiwgeCwgdGhpcy5fbWF4KTtcbiAgICBpZiAodGhpcy5fYnVmZi5sZW5ndGggPj0gdGhpcy5fbWluKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fYnVmZik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQyNyA9IGNyZWF0ZVN0cmVhbSgnc2xpZGluZ1dpbmRvdycsIG1peGluJDIwKTtcbnZhciBQJDIzID0gY3JlYXRlUHJvcGVydHkoJ3NsaWRpbmdXaW5kb3cnLCBtaXhpbiQyMCk7XG5cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3cob2JzLCBtYXgpIHtcbiAgdmFyIG1pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyNywgUCQyMykpKG9icywgeyBtaW46IG1pbiwgbWF4OiBtYXggfSk7XG59XG5cbnZhciBtaXhpbiQyMSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbixcbiAgICAgICAgZmx1c2hPbkVuZCA9IF9yZWYuZmx1c2hPbkVuZDtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gICAgdGhpcy5fZmx1c2hPbkVuZCA9IGZsdXNoT25FbmQ7XG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICB9LFxuICBfZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYnVmZiAhPT0gbnVsbCAmJiB0aGlzLl9idWZmLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX2J1ZmYpO1xuICAgICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2J1ZmYucHVzaCh4KTtcbiAgICB2YXIgZm4gPSB0aGlzLl9mbjtcbiAgICBpZiAoIWZuKHgpKSB7XG4gICAgICB0aGlzLl9mbHVzaCgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaE9uRW5kKSB7XG4gICAgICB0aGlzLl9mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLl9lbWl0RW5kKCk7XG4gIH1cbn07XG5cbnZhciBTJDI4ID0gY3JlYXRlU3RyZWFtKCdidWZmZXJXaGlsZScsIG1peGluJDIxKTtcbnZhciBQJDI0ID0gY3JlYXRlUHJvcGVydHkoJ2J1ZmZlcldoaWxlJywgbWl4aW4kMjEpO1xuXG52YXIgaWQkNyA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gYnVmZmVyV2hpbGUob2JzLCBmbikge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgX3JlZjIkZmx1c2hPbkVuZCA9IF9yZWYyLmZsdXNoT25FbmQsXG4gICAgICBmbHVzaE9uRW5kID0gX3JlZjIkZmx1c2hPbkVuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJGZsdXNoT25FbmQ7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMjgsIFAkMjQpKShvYnMsIHsgZm46IGZuIHx8IGlkJDcsIGZsdXNoT25FbmQ6IGZsdXNoT25FbmQgfSk7XG59XG5cbnZhciBtaXhpbiQyMiA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGNvdW50ID0gX3JlZi5jb3VudCxcbiAgICAgICAgZmx1c2hPbkVuZCA9IF9yZWYuZmx1c2hPbkVuZDtcblxuICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgdGhpcy5fZmx1c2hPbkVuZCA9IGZsdXNoT25FbmQ7XG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICB9LFxuICBfZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYnVmZiAhPT0gbnVsbCAmJiB0aGlzLl9idWZmLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX2J1ZmYpO1xuICAgICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2J1ZmYucHVzaCh4KTtcbiAgICBpZiAodGhpcy5fYnVmZi5sZW5ndGggPj0gdGhpcy5fY291bnQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufTtcblxudmFyIFMkMjkgPSBjcmVhdGVTdHJlYW0oJ2J1ZmZlcldpdGhDb3VudCcsIG1peGluJDIyKTtcbnZhciBQJDI1ID0gY3JlYXRlUHJvcGVydHkoJ2J1ZmZlcldpdGhDb3VudCcsIG1peGluJDIyKTtcblxuZnVuY3Rpb24gYnVmZmVyV2hpbGUkMShvYnMsIGNvdW50KSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBfcmVmMiRmbHVzaE9uRW5kID0gX3JlZjIuZmx1c2hPbkVuZCxcbiAgICAgIGZsdXNoT25FbmQgPSBfcmVmMiRmbHVzaE9uRW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkZmx1c2hPbkVuZDtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQyOSwgUCQyNSkpKG9icywgeyBjb3VudDogY291bnQsIGZsdXNoT25FbmQ6IGZsdXNoT25FbmQgfSk7XG59XG5cbnZhciBtaXhpbiQyMyA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB3YWl0ID0gX3JlZi53YWl0LFxuICAgICAgICBjb3VudCA9IF9yZWYuY291bnQsXG4gICAgICAgIGZsdXNoT25FbmQgPSBfcmVmLmZsdXNoT25FbmQ7XG5cbiAgICB0aGlzLl93YWl0ID0gd2FpdDtcbiAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIHRoaXMuX2ZsdXNoT25FbmQgPSBmbHVzaE9uRW5kO1xuICAgIHRoaXMuX2ludGVydmFsSWQgPSBudWxsO1xuICAgIHRoaXMuXyRvblRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2ZsdXNoKCk7XG4gICAgfTtcbiAgICB0aGlzLl9idWZmID0gW107XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fJG9uVGljayA9IG51bGw7XG4gICAgdGhpcy5fYnVmZiA9IG51bGw7XG4gIH0sXG4gIF9mbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9idWZmICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUodGhpcy5fYnVmZik7XG4gICAgICB0aGlzLl9idWZmID0gW107XG4gICAgfVxuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgdGhpcy5fYnVmZi5wdXNoKHgpO1xuICAgIGlmICh0aGlzLl9idWZmLmxlbmd0aCA+PSB0aGlzLl9jb3VudCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy5fJG9uVGljaywgdGhpcy5fd2FpdCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25FbmQgJiYgdGhpcy5fYnVmZi5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfSxcbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLl8kb25UaWNrLCB0aGlzLl93YWl0KTtcbiAgICB0aGlzLl9zb3VyY2Uub25BbnkodGhpcy5fJGhhbmRsZUFueSk7IC8vIGNvcGllZCBmcm9tIHBhdHRlcm5zL29uZS1zb3VyY2VcbiAgfSxcbiAgX29uRGVhY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ludGVydmFsSWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fc291cmNlLm9mZkFueSh0aGlzLl8kaGFuZGxlQW55KTsgLy8gY29waWVkIGZyb20gcGF0dGVybnMvb25lLXNvdXJjZVxuICB9XG59O1xuXG52YXIgUyQzMCA9IGNyZWF0ZVN0cmVhbSgnYnVmZmVyV2l0aFRpbWVPckNvdW50JywgbWl4aW4kMjMpO1xudmFyIFAkMjYgPSBjcmVhdGVQcm9wZXJ0eSgnYnVmZmVyV2l0aFRpbWVPckNvdW50JywgbWl4aW4kMjMpO1xuXG5mdW5jdGlvbiBidWZmZXJXaXRoVGltZU9yQ291bnQob2JzLCB3YWl0LCBjb3VudCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9LFxuICAgICAgX3JlZjIkZmx1c2hPbkVuZCA9IF9yZWYyLmZsdXNoT25FbmQsXG4gICAgICBmbHVzaE9uRW5kID0gX3JlZjIkZmx1c2hPbkVuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJGZsdXNoT25FbmQ7XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMzAsIFAkMjYpKShvYnMsIHsgd2FpdDogd2FpdCwgY291bnQ6IGNvdW50LCBmbHVzaE9uRW5kOiBmbHVzaE9uRW5kIH0pO1xufVxuXG5mdW5jdGlvbiB4Zm9ybUZvck9icyhvYnMpIHtcbiAgcmV0dXJuIHtcbiAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzLCBpbnB1dCkge1xuICAgICAgb2JzLl9lbWl0VmFsdWUoaW5wdXQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9icy5fZW1pdEVuZCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWl4aW4kMjQgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB0cmFuc2R1Y2VyID0gX3JlZi50cmFuc2R1Y2VyO1xuXG4gICAgdGhpcy5feGZvcm0gPSB0cmFuc2R1Y2VyKHhmb3JtRm9yT2JzKHRoaXMpKTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl94Zm9ybSA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5feGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10obnVsbCwgeCkgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3hmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10obnVsbCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5feGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShudWxsKTtcbiAgfVxufTtcblxudmFyIFMkMzEgPSBjcmVhdGVTdHJlYW0oJ3RyYW5zZHVjZScsIG1peGluJDI0KTtcbnZhciBQJDI3ID0gY3JlYXRlUHJvcGVydHkoJ3RyYW5zZHVjZScsIG1peGluJDI0KTtcblxuZnVuY3Rpb24gdHJhbnNkdWNlKG9icywgdHJhbnNkdWNlcikge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQzMSwgUCQyNykpKG9icywgeyB0cmFuc2R1Y2VyOiB0cmFuc2R1Y2VyIH0pO1xufVxuXG52YXIgbWl4aW4kMjUgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9oYW5kbGVyID0gZm47XG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXIodGhpcyk7XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XG4gIH0sXG4gIF9oYW5kbGVBbnk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2hhbmRsZXIodGhpcy5fZW1pdHRlciwgZXZlbnQpO1xuICB9XG59O1xuXG52YXIgUyQzMiA9IGNyZWF0ZVN0cmVhbSgnd2l0aEhhbmRsZXInLCBtaXhpbiQyNSk7XG52YXIgUCQyOCA9IGNyZWF0ZVByb3BlcnR5KCd3aXRoSGFuZGxlcicsIG1peGluJDI1KTtcblxuZnVuY3Rpb24gd2l0aEhhbmRsZXIob2JzLCBmbikge1xuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQzMiwgUCQyOCkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBaaXAoc291cmNlcywgY29tYmluYXRvcikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX2J1ZmZlcnMgPSBtYXAoc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBpc0FycmF5KHNvdXJjZSkgPyBjbG9uZUFycmF5KHNvdXJjZSkgOiBbXTtcbiAgfSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBtYXAoc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBpc0FycmF5KHNvdXJjZSkgPyBuZXZlcigpIDogc291cmNlO1xuICB9KTtcblxuICB0aGlzLl9jb21iaW5hdG9yID0gY29tYmluYXRvciA/IHNwcmVhZChjb21iaW5hdG9yLCB0aGlzLl9zb3VyY2VzLmxlbmd0aCkgOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xuICB0aGlzLl9hbGl2ZUNvdW50ID0gMDtcblxuICB0aGlzLl8kaGFuZGxlcnMgPSBbXTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiAoaSkge1xuICAgIF90aGlzLl8kaGFuZGxlcnMucHVzaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlQW55KGksIGV2ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBfbG9vcChpKTtcbiAgfVxufVxuXG5pbmhlcml0KFppcCwgU3RyZWFtLCB7XG4gIF9uYW1lOiAnemlwJyxcblxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgYWxsIHNvdXJjZXMgYXJlIGFycmF5c1xuICAgIHdoaWxlICh0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgdGhpcy5fZW1pdCgpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcbiAgICB0aGlzLl9hbGl2ZUNvdW50ID0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICYmIHRoaXMuX2FjdGl2ZTsgaSsrKSB7XG4gICAgICB0aGlzLl9zb3VyY2VzW2ldLm9uQW55KHRoaXMuXyRoYW5kbGVyc1tpXSk7XG4gICAgfVxuICB9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NvdXJjZXNbaV0ub2ZmQW55KHRoaXMuXyRoYW5kbGVyc1tpXSk7XG4gICAgfVxuICB9LFxuICBfZW1pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5fYnVmZmVycy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdGhpcy5fYnVmZmVyc1tpXS5zaGlmdCgpO1xuICAgIH1cbiAgICB2YXIgY29tYmluYXRvciA9IHRoaXMuX2NvbWJpbmF0b3I7XG4gICAgdGhpcy5fZW1pdFZhbHVlKGNvbWJpbmF0b3IodmFsdWVzKSk7XG4gIH0sXG4gIF9pc0Z1bGw6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBfaGFuZGxlQW55OiBmdW5jdGlvbiAoaSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbaV0ucHVzaChldmVudC52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5faXNGdWxsKCkpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihldmVudC52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSBFTkQpIHtcbiAgICAgIHRoaXMuX2FsaXZlQ291bnQtLTtcbiAgICAgIGlmICh0aGlzLl9hbGl2ZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG51bGw7XG4gICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fY29tYmluYXRvciA9IG51bGw7XG4gICAgdGhpcy5fJGhhbmRsZXJzID0gbnVsbDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHppcChvYnNlcnZhYmxlcywgY29tYmluYXRvciAvKiBGdW5jdGlvbiB8IGZhbHNleSAqLykge1xuICByZXR1cm4gb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAwID8gbmV2ZXIoKSA6IG5ldyBaaXAob2JzZXJ2YWJsZXMsIGNvbWJpbmF0b3IpO1xufVxuXG52YXIgaWQkOCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gQWJzdHJhY3RQb29sKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkcXVldWVMaW0gPSBfcmVmLnF1ZXVlTGltLFxuICAgICAgcXVldWVMaW0gPSBfcmVmJHF1ZXVlTGltID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRxdWV1ZUxpbSxcbiAgICAgIF9yZWYkY29uY3VyTGltID0gX3JlZi5jb25jdXJMaW0sXG4gICAgICBjb25jdXJMaW0gPSBfcmVmJGNvbmN1ckxpbSA9PT0gdW5kZWZpbmVkID8gLTEgOiBfcmVmJGNvbmN1ckxpbSxcbiAgICAgIF9yZWYkZHJvcCA9IF9yZWYuZHJvcCxcbiAgICAgIGRyb3AgPSBfcmVmJGRyb3AgPT09IHVuZGVmaW5lZCA/ICduZXcnIDogX3JlZiRkcm9wO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX3F1ZXVlTGltID0gcXVldWVMaW0gPCAwID8gLTEgOiBxdWV1ZUxpbTtcbiAgdGhpcy5fY29uY3VyTGltID0gY29uY3VyTGltIDwgMCA/IC0xIDogY29uY3VyTGltO1xuICB0aGlzLl9kcm9wID0gZHJvcDtcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fY3VyU291cmNlcyA9IFtdO1xuICB0aGlzLl8kaGFuZGxlU3ViQW55ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIF90aGlzLl9oYW5kbGVTdWJBbnkoZXZlbnQpO1xuICB9O1xuICB0aGlzLl8kZW5kSGFuZGxlcnMgPSBbXTtcbiAgdGhpcy5fY3VycmVudGx5QWRkaW5nID0gbnVsbDtcblxuICBpZiAodGhpcy5fY29uY3VyTGltID09PSAwKSB7XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9XG59XG5cbmluaGVyaXQoQWJzdHJhY3RQb29sLCBTdHJlYW0sIHtcbiAgX25hbWU6ICdhYnN0cmFjdFBvb2wnLFxuXG4gIF9hZGQ6IGZ1bmN0aW9uIChvYmosIHRvT2JzIC8qIEZ1bmN0aW9uIHwgZmFsc2V5ICovKSB7XG4gICAgdG9PYnMgPSB0b09icyB8fCBpZCQ4O1xuICAgIGlmICh0aGlzLl9jb25jdXJMaW0gPT09IC0xIHx8IHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoIDwgdGhpcy5fY29uY3VyTGltKSB7XG4gICAgICB0aGlzLl9hZGRUb0N1cih0b09icyhvYmopKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3F1ZXVlTGltID09PSAtMSB8fCB0aGlzLl9xdWV1ZS5sZW5ndGggPCB0aGlzLl9xdWV1ZUxpbSkge1xuICAgICAgICB0aGlzLl9hZGRUb1F1ZXVlKHRvT2JzKG9iaikpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9kcm9wID09PSAnb2xkJykge1xuICAgICAgICB0aGlzLl9yZW1vdmVPbGRlc3QoKTtcbiAgICAgICAgdGhpcy5fYWRkKG9iaiwgdG9PYnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2FkZEFsbDogZnVuY3Rpb24gKG9ic3MpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZvckVhY2gob2JzcywgZnVuY3Rpb24gKG9icykge1xuICAgICAgcmV0dXJuIF90aGlzMi5fYWRkKG9icyk7XG4gICAgfSk7XG4gIH0sXG4gIF9yZW1vdmU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICBpZiAodGhpcy5fcmVtb3ZlQ3VyKG9icykgPT09IC0xKSB7XG4gICAgICB0aGlzLl9yZW1vdmVRdWV1ZShvYnMpO1xuICAgIH1cbiAgfSxcbiAgX2FkZFRvUXVldWU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IGNvbmNhdCh0aGlzLl9xdWV1ZSwgW29ic10pO1xuICB9LFxuICBfYWRkVG9DdXI6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyBIQUNLOlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGhhdmUgdHdvIG9wdGltaXphdGlvbnMgZm9yIGNhc2VzIHdoZW4gYG9ic2AgaXMgZW5kZWQuIFdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGFkZCBzdWNoIG9ic2VydmFibGUgdG8gdGhlIGxpc3QsIGJ1dCBvbmx5IHdhbnQgdG8gZW1pdCBldmVudHNcbiAgICAgIC8vIGZyb20gaXQgKGlmIGl0IGhhcyBzb21lKS5cbiAgICAgIC8vXG4gICAgICAvLyBJbnN0ZWFkIG9mIHRoaXMgaGFja3MsIHdlIGNvdWxkIGp1c3QgZGlkIGZvbGxvd2luZyxcbiAgICAgIC8vIGJ1dCBpdCB3b3VsZCBiZSA1LTggdGltZXMgc2xvd2VyOlxuICAgICAgLy9cbiAgICAgIC8vICAgICB0aGlzLl9jdXJTb3VyY2VzID0gY29uY2F0KHRoaXMuX2N1clNvdXJjZXMsIFtvYnNdKTtcbiAgICAgIC8vICAgICB0aGlzLl9zdWJzY3JpYmUob2JzKTtcbiAgICAgIC8vXG5cbiAgICAgIC8vICMxXG4gICAgICAvLyBUaGlzIG9uZSBmb3IgY2FzZXMgd2hlbiBgb2JzYCBhbHJlYWR5IGVuZGVkXG4gICAgICAvLyBlLmcuLCBLZWZpci5jb25zdGFudCgpIG9yIEtlZmlyLm5ldmVyKClcbiAgICAgIGlmICghb2JzLl9hbGl2ZSkge1xuICAgICAgICBpZiAob2JzLl9jdXJyZW50RXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KG9icy5fY3VycmVudEV2ZW50LnR5cGUsIG9icy5fY3VycmVudEV2ZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgX2VtaXQgYWJvdmUgY291bGQgaGF2ZSBjYXVzZWQgdGhpcyBzdHJlYW0gdG8gZW5kLlxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHVsbFF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fb25FbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vICMyXG4gICAgICAvLyBUaGlzIG9uZSBpcyBmb3IgY2FzZXMgd2hlbiBgb2JzYCBnb2luZyB0byBlbmQgc3luY2hyb25vdXNseSBvblxuICAgICAgLy8gZmlyc3Qgc3Vic2NyaWJlciBlLmcuLCBLZWZpci5zdHJlYW0oZW0gPT4ge2VtLmVtaXQoMSk7IGVtLmVuZCgpfSlcbiAgICAgIHRoaXMuX2N1cnJlbnRseUFkZGluZyA9IG9icztcbiAgICAgIG9icy5vbkFueSh0aGlzLl8kaGFuZGxlU3ViQW55KTtcbiAgICAgIHRoaXMuX2N1cnJlbnRseUFkZGluZyA9IG51bGw7XG4gICAgICBpZiAob2JzLl9hbGl2ZSkge1xuICAgICAgICB0aGlzLl9jdXJTb3VyY2VzID0gY29uY2F0KHRoaXMuX2N1clNvdXJjZXMsIFtvYnNdKTtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuX3N1YlRvRW5kKG9icyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLl9wdWxsUXVldWUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX29uRW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jdXJTb3VyY2VzID0gY29uY2F0KHRoaXMuX2N1clNvdXJjZXMsIFtvYnNdKTtcbiAgICB9XG4gIH0sXG4gIF9zdWJUb0VuZDogZnVuY3Rpb24gKG9icykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5fcmVtb3ZlQ3VyKG9icyk7XG4gICAgfTtcbiAgICB0aGlzLl8kZW5kSGFuZGxlcnMucHVzaCh7IG9iczogb2JzLCBoYW5kbGVyOiBvbkVuZCB9KTtcbiAgICBvYnMub25FbmQob25FbmQpO1xuICB9LFxuICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgb2JzLm9uQW55KHRoaXMuXyRoYW5kbGVTdWJBbnkpO1xuXG4gICAgLy8gaXQgY2FuIGJlY29tZSBpbmFjdGl2ZSBpbiByZXNwb25jZSBvZiBzdWJzY3JpYmluZyB0byBgb2JzLm9uQW55YCBhYm92ZVxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3N1YlRvRW5kKG9icyk7XG4gICAgfVxuICB9LFxuICBfdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICBvYnMub2ZmQW55KHRoaXMuXyRoYW5kbGVTdWJBbnkpO1xuXG4gICAgdmFyIG9uRW5kSSA9IGZpbmRCeVByZWQodGhpcy5fJGVuZEhhbmRsZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLm9icyA9PT0gb2JzO1xuICAgIH0pO1xuICAgIGlmIChvbkVuZEkgIT09IC0xKSB7XG4gICAgICBvYnMub2ZmRW5kKHRoaXMuXyRlbmRIYW5kbGVyc1tvbkVuZEldLmhhbmRsZXIpO1xuICAgICAgdGhpcy5fJGVuZEhhbmRsZXJzLnNwbGljZShvbkVuZEksIDEpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVN1YkFueTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFZBTFVFKSB7XG4gICAgICB0aGlzLl9lbWl0VmFsdWUoZXZlbnQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihldmVudC52YWx1ZSk7XG4gICAgfVxuICB9LFxuICBfcmVtb3ZlUXVldWU6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kKHRoaXMuX3F1ZXVlLCBvYnMpO1xuICAgIHRoaXMuX3F1ZXVlID0gcmVtb3ZlKHRoaXMuX3F1ZXVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuICBfcmVtb3ZlQ3VyOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUob2JzKTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZCh0aGlzLl9jdXJTb3VyY2VzLCBvYnMpO1xuICAgIHRoaXMuX2N1clNvdXJjZXMgPSByZW1vdmUodGhpcy5fY3VyU291cmNlcywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5fcHVsbFF1ZXVlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29uRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuICBfcmVtb3ZlT2xkZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VyKHRoaXMuX2N1clNvdXJjZXNbMF0pO1xuICB9LFxuICBfcHVsbFF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fcXVldWUgPSBjbG9uZUFycmF5KHRoaXMuX3F1ZXVlKTtcbiAgICAgIHRoaXMuX2FkZFRvQ3VyKHRoaXMuX3F1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgfSxcbiAgX29uQWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBzb3VyY2VzID0gdGhpcy5fY3VyU291cmNlczsgaSA8IHNvdXJjZXMubGVuZ3RoICYmIHRoaXMuX2FjdGl2ZTsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmUoc291cmNlc1tpXSk7XG4gICAgfVxuICB9LFxuICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgc291cmNlcyA9IHRoaXMuX2N1clNvdXJjZXM7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZShzb3VyY2VzW2ldKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRseUFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUodGhpcy5fY3VycmVudGx5QWRkaW5nKTtcbiAgICB9XG4gIH0sXG4gIF9pc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1clNvdXJjZXMubGVuZ3RoID09PSAwO1xuICB9LFxuICBfb25FbXB0eTogZnVuY3Rpb24gKCkge30sXG4gIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2NsZWFyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcXVldWUgPSBudWxsO1xuICAgIHRoaXMuX2N1clNvdXJjZXMgPSBudWxsO1xuICAgIHRoaXMuXyRoYW5kbGVTdWJBbnkgPSBudWxsO1xuICAgIHRoaXMuXyRlbmRIYW5kbGVycyA9IG51bGw7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBNZXJnZShzb3VyY2VzKSB7XG4gIEFic3RyYWN0UG9vbC5jYWxsKHRoaXMpO1xuICB0aGlzLl9hZGRBbGwoc291cmNlcyk7XG4gIHRoaXMuX2luaXRpYWxpc2VkID0gdHJ1ZTtcbn1cblxuaW5oZXJpdChNZXJnZSwgQWJzdHJhY3RQb29sLCB7XG4gIF9uYW1lOiAnbWVyZ2UnLFxuXG4gIF9vbkVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpc2VkKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gbWVyZ2Uob2JzZXJ2YWJsZXMpIHtcbiAgcmV0dXJuIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMCA/IG5ldmVyKCkgOiBuZXcgTWVyZ2Uob2JzZXJ2YWJsZXMpO1xufVxuXG5mdW5jdGlvbiBTJDMzKGdlbmVyYXRvcikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuICB0aGlzLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2luTG9vcCA9IGZhbHNlO1xuICB0aGlzLl9pdGVyYXRpb24gPSAwO1xuICB0aGlzLl8kaGFuZGxlQW55ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIF90aGlzLl9oYW5kbGVBbnkoZXZlbnQpO1xuICB9O1xufVxuXG5pbmhlcml0KFMkMzMsIFN0cmVhbSwge1xuICBfbmFtZTogJ3JlcGVhdCcsXG5cbiAgX2hhbmRsZUFueTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX2dldFNvdXJjZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KGV2ZW50LnR5cGUsIGV2ZW50LnZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIF9nZXRTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luTG9vcCkge1xuICAgICAgdGhpcy5faW5Mb29wID0gdHJ1ZTtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3I7XG4gICAgICB3aGlsZSAodGhpcy5fc291cmNlID09PSBudWxsICYmIHRoaXMuX2FsaXZlICYmIHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBnZW5lcmF0b3IodGhpcy5faXRlcmF0aW9uKyspO1xuICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlLm9uQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW5Mb29wID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlLm9uQW55KHRoaXMuXyRoYW5kbGVBbnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZXRTb3VyY2UoKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRlYWN0aXZhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZS5vZmZBbnkodGhpcy5fJGhhbmRsZUFueSk7XG4gICAgfVxuICB9LFxuICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgICB0aGlzLl8kaGFuZGxlQW55ID0gbnVsbDtcbiAgfVxufSk7XG5cbnZhciByZXBlYXQgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUyQzMyhnZW5lcmF0b3IpO1xufTtcblxuZnVuY3Rpb24gY29uY2F0JDEob2JzZXJ2YWJsZXMpIHtcbiAgcmV0dXJuIHJlcGVhdChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZXMubGVuZ3RoID4gaW5kZXggPyBvYnNlcnZhYmxlc1tpbmRleF0gOiBmYWxzZTtcbiAgfSkuc2V0TmFtZSgnY29uY2F0Jyk7XG59XG5cbmZ1bmN0aW9uIFBvb2woKSB7XG4gIEFic3RyYWN0UG9vbC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0KFBvb2wsIEFic3RyYWN0UG9vbCwge1xuICBfbmFtZTogJ3Bvb2wnLFxuXG4gIHBsdWc6IGZ1bmN0aW9uIChvYnMpIHtcbiAgICB0aGlzLl9hZGQob2JzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdW5wbHVnOiBmdW5jdGlvbiAob2JzKSB7XG4gICAgdGhpcy5fcmVtb3ZlKG9icyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBGbGF0TWFwKHNvdXJjZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBBYnN0cmFjdFBvb2wuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB0aGlzLl9mbiA9IGZuO1xuICB0aGlzLl9tYWluRW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5fbGFzdEN1cnJlbnQgPSBudWxsO1xuICB0aGlzLl8kaGFuZGxlTWFpbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBfdGhpcy5faGFuZGxlTWFpbihldmVudCk7XG4gIH07XG59XG5cbmluaGVyaXQoRmxhdE1hcCwgQWJzdHJhY3RQb29sLCB7XG4gIF9vbkFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBBYnN0cmFjdFBvb2wucHJvdG90eXBlLl9vbkFjdGl2YXRpb24uY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub25BbnkodGhpcy5fJGhhbmRsZU1haW4pO1xuICAgIH1cbiAgfSxcbiAgX29uRGVhY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgQWJzdHJhY3RQb29sLnByb3RvdHlwZS5fb25EZWFjdGl2YXRpb24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2Uub2ZmQW55KHRoaXMuXyRoYW5kbGVNYWluKTtcbiAgICB0aGlzLl9oYWROb0V2U2luY2VEZWFjdCA9IHRydWU7XG4gIH0sXG4gIF9oYW5kbGVNYWluOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUpIHtcbiAgICAgIC8vIElzIGxhdGVzdCB2YWx1ZSBiZWZvcmUgZGVhY3RpdmF0aW9uIHN1cnZpdmVkLCBhbmQgbm93IGlzICdjdXJyZW50JyBvbiB0aGlzIGFjdGl2YXRpb24/XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhbmRsZSBzdWNoIHZhbHVlcywgdG8gcHJldmVudCB0byBjb25zdGFudGx5IGFkZFxuICAgICAgLy8gc2FtZSBvYnNlcnZhbGUgb24gZWFjaCBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiB3aGVuIG91ciBtYWluIHNvdXJjZVxuICAgICAgLy8gaXMgYSBgS2VmaXIuY29uYXRhbnQoKWAgZm9yIGV4YW1wbGUuXG4gICAgICB2YXIgc2FtZUN1cnIgPSB0aGlzLl9hY3RpdmF0aW5nICYmIHRoaXMuX2hhZE5vRXZTaW5jZURlYWN0ICYmIHRoaXMuX2xhc3RDdXJyZW50ID09PSBldmVudC52YWx1ZTtcbiAgICAgIGlmICghc2FtZUN1cnIpIHtcbiAgICAgICAgdGhpcy5fYWRkKGV2ZW50LnZhbHVlLCB0aGlzLl9mbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q3VycmVudCA9IGV2ZW50LnZhbHVlO1xuICAgICAgdGhpcy5faGFkTm9FdlNpbmNlRGVhY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gRVJST1IpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihldmVudC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgaWYgKHRoaXMuX2lzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYWluRW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX29uRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbWFpbkVuZGVkKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9LFxuICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBBYnN0cmFjdFBvb2wucHJvdG90eXBlLl9jbGVhci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuXyRoYW5kbGVNYWluID0gbnVsbDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIEZsYXRNYXBFcnJvcnMoc291cmNlLCBmbikge1xuICBGbGF0TWFwLmNhbGwodGhpcywgc291cmNlLCBmbik7XG59XG5cbmluaGVyaXQoRmxhdE1hcEVycm9ycywgRmxhdE1hcCwge1xuICAvLyBTYW1lIGFzIGluIEZsYXRNYXAsIG9ubHkgVkFMVUUvRVJST1IgZmxpcHBlZFxuICBfaGFuZGxlTWFpbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVSUk9SKSB7XG4gICAgICB2YXIgc2FtZUN1cnIgPSB0aGlzLl9hY3RpdmF0aW5nICYmIHRoaXMuX2hhZE5vRXZTaW5jZURlYWN0ICYmIHRoaXMuX2xhc3RDdXJyZW50ID09PSBldmVudC52YWx1ZTtcbiAgICAgIGlmICghc2FtZUN1cnIpIHtcbiAgICAgICAgdGhpcy5fYWRkKGV2ZW50LnZhbHVlLCB0aGlzLl9mbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q3VycmVudCA9IGV2ZW50LnZhbHVlO1xuICAgICAgdGhpcy5faGFkTm9FdlNpbmNlRGVhY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gVkFMVUUpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZShldmVudC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEVORCkge1xuICAgICAgaWYgKHRoaXMuX2lzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYWluRW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0cnVjdG9yJDEoQmFzZUNsYXNzLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBBbm9ueW1vdXNPYnNlcnZhYmxlKHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBCYXNlQ2xhc3MuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICB0aGlzLl9zZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgdGhpcy5fbmFtZSA9IHByaW1hcnkuX25hbWUgKyAnLicgKyBuYW1lO1xuICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSBOT1RISU5HO1xuICAgIHRoaXMuXyRoYW5kbGVTZWNvbmRhcnlBbnkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlU2Vjb25kYXJ5QW55KGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMuXyRoYW5kbGVQcmltYXJ5QW55ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZVByaW1hcnlBbnkoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NNZXRob2RzJDEoQmFzZUNsYXNzKSB7XG4gIHJldHVybiB7XG4gICAgX2luaXQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9mcmVlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBfaGFuZGxlUHJpbWFyeVZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH0sXG4gICAgX2hhbmRsZVByaW1hcnlFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVQcmltYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfSxcbiAgICBfaGFuZGxlU2Vjb25kYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9sYXN0U2Vjb25kYXJ5ID0geDtcbiAgICB9LFxuICAgIF9oYW5kbGVTZWNvbmRhcnlFcnJvcjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB9LFxuICAgIF9oYW5kbGVTZWNvbmRhcnlFbmQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIF9oYW5kbGVQcmltYXJ5QW55OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFZBTFVFOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVQcmltYXJ5VmFsdWUoZXZlbnQudmFsdWUpO1xuICAgICAgICBjYXNlIEVSUk9SOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVQcmltYXJ5RXJyb3IoZXZlbnQudmFsdWUpO1xuICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUHJpbWFyeUVuZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfaGFuZGxlU2Vjb25kYXJ5QW55OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFZBTFVFOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTZWNvbmRhcnlWYWx1ZShldmVudC52YWx1ZSk7XG4gICAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNlY29uZGFyeUVycm9yKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgdGhpcy5faGFuZGxlU2Vjb25kYXJ5RW5kKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTZWNvbmRhcnkoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9yZW1vdmVTZWNvbmRhcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zZWNvbmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9mZkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgICAgdGhpcy5fJGhhbmRsZVNlY29uZGFyeUFueSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fc2Vjb25kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeS5vbkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpbWFyeS5vbkFueSh0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25EZWFjdGl2YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zZWNvbmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9mZkFueSh0aGlzLl8kaGFuZGxlU2Vjb25kYXJ5QW55KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByaW1hcnkub2ZmQW55KHRoaXMuXyRoYW5kbGVQcmltYXJ5QW55KTtcbiAgICB9LFxuICAgIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgQmFzZUNsYXNzLnByb3RvdHlwZS5fY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX3ByaW1hcnkgPSBudWxsO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSBudWxsO1xuICAgICAgdGhpcy5fJGhhbmRsZVNlY29uZGFyeUFueSA9IG51bGw7XG4gICAgICB0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSA9IG51bGw7XG4gICAgICB0aGlzLl9mcmVlKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0kMShuYW1lLCBtaXhpbikge1xuICB2YXIgUyA9IGNyZWF0ZUNvbnN0cnVjdG9yJDEoU3RyZWFtLCBuYW1lKTtcbiAgaW5oZXJpdChTLCBTdHJlYW0sIGNyZWF0ZUNsYXNzTWV0aG9kcyQxKFN0cmVhbSksIG1peGluKTtcbiAgcmV0dXJuIFM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5JDEobmFtZSwgbWl4aW4pIHtcbiAgdmFyIFAgPSBjcmVhdGVDb25zdHJ1Y3RvciQxKFByb3BlcnR5LCBuYW1lKTtcbiAgaW5oZXJpdChQLCBQcm9wZXJ0eSwgY3JlYXRlQ2xhc3NNZXRob2RzJDEoUHJvcGVydHkpLCBtaXhpbik7XG4gIHJldHVybiBQO1xufVxuXG52YXIgbWl4aW4kMjYgPSB7XG4gIF9oYW5kbGVQcmltYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2xhc3RTZWNvbmRhcnkgIT09IE5PVEhJTkcgJiYgdGhpcy5fbGFzdFNlY29uZGFyeSkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVNlY29uZGFyeUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HIHx8ICF0aGlzLl9sYXN0U2Vjb25kYXJ5KSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQzNCA9IGNyZWF0ZVN0cmVhbSQxKCdmaWx0ZXJCeScsIG1peGluJDI2KTtcbnZhciBQJDI5ID0gY3JlYXRlUHJvcGVydHkkMSgnZmlsdGVyQnknLCBtaXhpbiQyNik7XG5cbmZ1bmN0aW9uIGZpbHRlckJ5KHByaW1hcnksIHNlY29uZGFyeSkge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzQsIFAkMjkpKShwcmltYXJ5LCBzZWNvbmRhcnkpO1xufVxuXG52YXIgaWQyID0gZnVuY3Rpb24gKF8sIHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBzYW1wbGVkQnkocGFzc2l2ZSwgYWN0aXZlLCBjb21iaW5hdG9yKSB7XG4gIHZhciBfY29tYmluYXRvciA9IGNvbWJpbmF0b3IgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21iaW5hdG9yKGIsIGEpO1xuICB9IDogaWQyO1xuICByZXR1cm4gY29tYmluZShbYWN0aXZlXSwgW3Bhc3NpdmVdLCBfY29tYmluYXRvcikuc2V0TmFtZShwYXNzaXZlLCAnc2FtcGxlZEJ5Jyk7XG59XG5cbnZhciBtaXhpbiQyNyA9IHtcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy5fbGFzdFNlY29uZGFyeSAhPT0gTk9USElORykge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHgpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVNlY29uZGFyeUVuZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQzNSA9IGNyZWF0ZVN0cmVhbSQxKCdza2lwVW50aWxCeScsIG1peGluJDI3KTtcbnZhciBQJDMwID0gY3JlYXRlUHJvcGVydHkkMSgnc2tpcFVudGlsQnknLCBtaXhpbiQyNyk7XG5cbmZ1bmN0aW9uIHNraXBVbnRpbEJ5KHByaW1hcnksIHNlY29uZGFyeSkge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzUsIFAkMzApKShwcmltYXJ5LCBzZWNvbmRhcnkpO1xufVxuXG52YXIgbWl4aW4kMjggPSB7XG4gIF9oYW5kbGVTZWNvbmRhcnlWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfVxufTtcblxudmFyIFMkMzYgPSBjcmVhdGVTdHJlYW0kMSgndGFrZVVudGlsQnknLCBtaXhpbiQyOCk7XG52YXIgUCQzMSA9IGNyZWF0ZVByb3BlcnR5JDEoJ3Rha2VVbnRpbEJ5JywgbWl4aW4kMjgpO1xuXG5mdW5jdGlvbiB0YWtlVW50aWxCeShwcmltYXJ5LCBzZWNvbmRhcnkpIHtcbiAgcmV0dXJuIG5ldyAocHJpbWFyeS5fb2ZTYW1lVHlwZShTJDM2LCBQJDMxKSkocHJpbWFyeSwgc2Vjb25kYXJ5KTtcbn1cblxudmFyIG1peGluJDI5ID0ge1xuICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRmbHVzaE9uRW5kID0gX3JlZi5mbHVzaE9uRW5kLFxuICAgICAgICBmbHVzaE9uRW5kID0gX3JlZiRmbHVzaE9uRW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRmbHVzaE9uRW5kO1xuXG4gICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIHRoaXMuX2ZsdXNoT25FbmQgPSBmbHVzaE9uRW5kO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2J1ZmYgPSBudWxsO1xuICB9LFxuICBfZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYnVmZiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdFZhbHVlKHRoaXMuX2J1ZmYpO1xuICAgICAgdGhpcy5fYnVmZiA9IFtdO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hPbkVuZCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEVuZCgpO1xuICB9LFxuICBfb25BY3RpdmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJpbWFyeS5vbkFueSh0aGlzLl8kaGFuZGxlUHJpbWFyeUFueSk7XG4gICAgaWYgKHRoaXMuX2FsaXZlICYmIHRoaXMuX3NlY29uZGFyeSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5Lm9uQW55KHRoaXMuXyRoYW5kbGVTZWNvbmRhcnlBbnkpO1xuICAgIH1cbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmLnB1c2goeCk7XG4gIH0sXG4gIF9oYW5kbGVTZWNvbmRhcnlWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZsdXNoKCk7XG4gIH0sXG4gIF9oYW5kbGVTZWNvbmRhcnlFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDM3ID0gY3JlYXRlU3RyZWFtJDEoJ2J1ZmZlckJ5JywgbWl4aW4kMjkpO1xudmFyIFAkMzIgPSBjcmVhdGVQcm9wZXJ0eSQxKCdidWZmZXJCeScsIG1peGluJDI5KTtcblxuZnVuY3Rpb24gYnVmZmVyQnkocHJpbWFyeSwgc2Vjb25kYXJ5LCBvcHRpb25zIC8qIG9wdGlvbmFsICovKSB7XG4gIHJldHVybiBuZXcgKHByaW1hcnkuX29mU2FtZVR5cGUoUyQzNywgUCQzMikpKHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucyk7XG59XG5cbnZhciBtaXhpbiQzMCA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkZmx1c2hPbkVuZCA9IF9yZWYuZmx1c2hPbkVuZCxcbiAgICAgICAgZmx1c2hPbkVuZCA9IF9yZWYkZmx1c2hPbkVuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkZmx1c2hPbkVuZCxcbiAgICAgICAgX3JlZiRmbHVzaE9uQ2hhbmdlID0gX3JlZi5mbHVzaE9uQ2hhbmdlLFxuICAgICAgICBmbHVzaE9uQ2hhbmdlID0gX3JlZiRmbHVzaE9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkZmx1c2hPbkNoYW5nZTtcblxuICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgICB0aGlzLl9mbHVzaE9uRW5kID0gZmx1c2hPbkVuZDtcbiAgICB0aGlzLl9mbHVzaE9uQ2hhbmdlID0gZmx1c2hPbkNoYW5nZTtcbiAgfSxcbiAgX2ZyZWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9idWZmID0gbnVsbDtcbiAgfSxcbiAgX2ZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmYgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh0aGlzLl9idWZmKTtcbiAgICAgIHRoaXMuX2J1ZmYgPSBbXTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVQcmltYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25FbmQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXRFbmQoKTtcbiAgfSxcbiAgX2hhbmRsZVByaW1hcnlWYWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9idWZmLnB1c2goeCk7XG4gICAgaWYgKHRoaXMuX2xhc3RTZWNvbmRhcnkgIT09IE5PVEhJTkcgJiYgIXRoaXMuX2xhc3RTZWNvbmRhcnkpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlU2Vjb25kYXJ5RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9mbHVzaE9uRW5kICYmICh0aGlzLl9sYXN0U2Vjb25kYXJ5ID09PSBOT1RISU5HIHx8IHRoaXMuX2xhc3RTZWNvbmRhcnkpKSB7XG4gICAgICB0aGlzLl9lbWl0RW5kKCk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlU2Vjb25kYXJ5VmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoT25DaGFuZ2UgJiYgIXgpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZnJvbSBkZWZhdWx0IF9oYW5kbGVTZWNvbmRhcnlWYWx1ZVxuICAgIHRoaXMuX2xhc3RTZWNvbmRhcnkgPSB4O1xuICB9XG59O1xuXG52YXIgUyQzOCA9IGNyZWF0ZVN0cmVhbSQxKCdidWZmZXJXaGlsZUJ5JywgbWl4aW4kMzApO1xudmFyIFAkMzMgPSBjcmVhdGVQcm9wZXJ0eSQxKCdidWZmZXJXaGlsZUJ5JywgbWl4aW4kMzApO1xuXG5mdW5jdGlvbiBidWZmZXJXaGlsZUJ5KHByaW1hcnksIHNlY29uZGFyeSwgb3B0aW9ucyAvKiBvcHRpb25hbCAqLykge1xuICByZXR1cm4gbmV3IChwcmltYXJ5Ll9vZlNhbWVUeXBlKFMkMzgsIFAkMzMpKShwcmltYXJ5LCBzZWNvbmRhcnksIG9wdGlvbnMpO1xufVxuXG52YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGF3YWl0aW5nKGEsIGIpIHtcbiAgdmFyIHJlc3VsdCA9IG1lcmdlKFttYXAkMShhLCB0KSwgbWFwJDEoYiwgZildKTtcbiAgcmVzdWx0ID0gc2tpcER1cGxpY2F0ZXMocmVzdWx0KTtcbiAgcmVzdWx0ID0gdG9Qcm9wZXJ0eShyZXN1bHQsIGYpO1xuICByZXR1cm4gcmVzdWx0LnNldE5hbWUoYSwgJ2F3YWl0aW5nJyk7XG59XG5cbnZhciBtaXhpbiQzMSA9IHtcbiAgX2luaXQ6IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGZuID0gX3JlZi5mbjtcblxuICAgIHRoaXMuX2ZuID0gZm47XG4gIH0sXG4gIF9mcmVlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICB9LFxuICBfaGFuZGxlVmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGZuID0gdGhpcy5fZm47XG4gICAgdmFyIHJlc3VsdCA9IGZuKHgpO1xuICAgIGlmIChyZXN1bHQuY29udmVydCkge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZSh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTJDM5ID0gY3JlYXRlU3RyZWFtKCd2YWx1ZXNUb0Vycm9ycycsIG1peGluJDMxKTtcbnZhciBQJDM0ID0gY3JlYXRlUHJvcGVydHkoJ3ZhbHVlc1RvRXJyb3JzJywgbWl4aW4kMzEpO1xuXG52YXIgZGVmRm4gPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geyBjb252ZXJ0OiB0cnVlLCBlcnJvcjogeCB9O1xufTtcblxuZnVuY3Rpb24gdmFsdWVzVG9FcnJvcnMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmRm47XG5cbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkMzksIFAkMzQpKShvYnMsIHsgZm46IGZuIH0pO1xufVxuXG52YXIgbWl4aW4kMzIgPSB7XG4gIF9pbml0OiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBmbiA9IF9yZWYuZm47XG5cbiAgICB0aGlzLl9mbiA9IGZuO1xuICB9LFxuICBfZnJlZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZuID0gbnVsbDtcbiAgfSxcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgIHZhciByZXN1bHQgPSBmbih4KTtcbiAgICBpZiAocmVzdWx0LmNvbnZlcnQpIHtcbiAgICAgIHRoaXMuX2VtaXRWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IoeCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUyQ0MCA9IGNyZWF0ZVN0cmVhbSgnZXJyb3JzVG9WYWx1ZXMnLCBtaXhpbiQzMik7XG52YXIgUCQzNSA9IGNyZWF0ZVByb3BlcnR5KCdlcnJvcnNUb1ZhbHVlcycsIG1peGluJDMyKTtcblxudmFyIGRlZkZuJDEgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geyBjb252ZXJ0OiB0cnVlLCB2YWx1ZTogeCB9O1xufTtcblxuZnVuY3Rpb24gZXJyb3JzVG9WYWx1ZXMob2JzKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmRm4kMTtcblxuICByZXR1cm4gbmV3IChvYnMuX29mU2FtZVR5cGUoUyQ0MCwgUCQzNSkpKG9icywgeyBmbjogZm4gfSk7XG59XG5cbnZhciBtaXhpbiQzMyA9IHtcbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX2VtaXRFcnJvcih4KTtcbiAgICB0aGlzLl9lbWl0RW5kKCk7XG4gIH1cbn07XG5cbnZhciBTJDQxID0gY3JlYXRlU3RyZWFtKCdlbmRPbkVycm9yJywgbWl4aW4kMzMpO1xudmFyIFAkMzYgPSBjcmVhdGVQcm9wZXJ0eSgnZW5kT25FcnJvcicsIG1peGluJDMzKTtcblxuZnVuY3Rpb24gZW5kT25FcnJvcihvYnMpIHtcbiAgcmV0dXJuIG5ldyAob2JzLl9vZlNhbWVUeXBlKFMkNDEsIFAkMzYpKShvYnMpO1xufVxuXG4vLyBDcmVhdGUgYSBzdHJlYW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vICgpIC0+IFN0cmVhbVxuLy8gKG51bWJlciwgYW55KSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIGFueSkgLT4gU3RyZWFtXG4vLyAobnVtYmVyLCBBcnJheTxhbnk+KSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIChudW1iZXIsIEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIChGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyAoRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gVGFyZ2V0ID0ge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9fHthZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXJ9fHtvbiwgb2ZmfVxuLy8gKFRhcmdldCwgc3RyaW5nLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKEZ1bmN0aW9uKSAtPiBTdHJlYW1cbi8vIENyZWF0ZSBhIHByb3BlcnR5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoYW55KSAtPiBQcm9wZXJ0eVxuLy8gKGFueSkgLT4gUHJvcGVydHlcbi8vIENvbnZlcnQgb2JzZXJ2YWJsZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvcGVydHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHRvUHJvcGVydHkodGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSkgLT4gU3RyZWFtXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2hhbmdlcyh0aGlzKTtcbn07XG5cbi8vIEludGVyb3BlcmF0aW9uIHdpdGggb3RoZXIgaW1wbGltZW50YXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoUHJvbWlzZSkgLT4gUHJvcGVydHlcbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvbWlzZVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKFByb21pc2UpIHtcbiAgcmV0dXJuIHRvUHJvbWlzZSh0aGlzLCBQcm9taXNlKTtcbn07XG5cbi8vIChFU09ic2VydmFibGUpIC0+IFN0cmVhbVxuLy8gKFN0cmVhbXxQcm9wZXJ0eSkgLT4gRVM3IE9ic2VydmFibGVcbk9ic2VydmFibGUucHJvdG90eXBlLnRvRVNPYnNlcnZhYmxlID0gdG9FU09ic2VydmFibGU7XG5PYnNlcnZhYmxlLnByb3RvdHlwZVskJG9ic2VydmFibGVdID0gdG9FU09ic2VydmFibGU7XG5cbi8vIE1vZGlmeSBhbiBvYnNlcnZhYmxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG1hcCQxKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZmlsdGVyKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gdGFrZSh0aGlzLCBuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2VFcnJvcnMgPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gdGFrZUVycm9ycyh0aGlzLCBuKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gdGFrZVdoaWxlKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGxhc3QodGhpcyk7XG59O1xuXG4vLyAoU3RyZWFtLCBudW1iZXIpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIHNraXAodGhpcywgbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwV2hpbGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHNraXBXaGlsZSh0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwRHVwbGljYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gc2tpcER1cGxpY2F0ZXModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258ZmFsc2V5LCBhbnl8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258ZmFsc2V5LCBhbnl8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChmbiwgc2VlZCkge1xuICByZXR1cm4gZGlmZih0aGlzLCBmbiwgc2VlZCk7XG59O1xuXG4vLyAoU3RyZWFtfFByb3BlcnR5LCBGdW5jdGlvbiwgYW55fHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiAoZm4sIHNlZWQpIHtcbiAgcmV0dXJuIHNjYW4odGhpcywgZm4sIHNlZWQpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZmxhdHRlbih0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBudW1iZXIpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh3YWl0KSB7XG4gIHJldHVybiBkZWxheSh0aGlzLCB3YWl0KTtcbn07XG5cbi8vIE9wdGlvbnMgPSB7bGVhZGluZzogYm9vbGVhbnx1bmRlZmluZWQsIHRyYWlsaW5nOiBib29sZWFufHVuZGVmaW5lZH1cbi8vIChTdHJlYW0sIG51bWJlciwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGhyb3R0bGUgPSBmdW5jdGlvbiAod2FpdCwgb3B0aW9ucykge1xuICByZXR1cm4gdGhyb3R0bGUodGhpcywgd2FpdCwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ltbWVkaWF0ZTogYm9vbGVhbnx1bmRlZmluZWR9XG4vLyAoU3RyZWFtLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgbnVtYmVyLCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlID0gZnVuY3Rpb24gKHdhaXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlYm91bmNlKHRoaXMsIHdhaXQsIG9wdGlvbnMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBtYXBFcnJvcnModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmaWx0ZXJFcnJvcnModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5pZ25vcmVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpZ25vcmVWYWx1ZXModGhpcyk7XG59O1xuXG4vLyAoU3RyZWFtKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmlnbm9yZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlnbm9yZUVycm9ycyh0aGlzKTtcbn07XG5cbi8vIChTdHJlYW0pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuaWdub3JlRW5kID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaWdub3JlRW5kKHRoaXMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJlZm9yZUVuZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gYmVmb3JlRW5kKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlciwgbnVtYmVyfHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlciwgbnVtYmVyfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnNsaWRpbmdXaW5kb3cgPSBmdW5jdGlvbiAobWF4LCBtaW4pIHtcbiAgcmV0dXJuIHNsaWRpbmdXaW5kb3codGhpcywgbWF4LCBtaW4pO1xufTtcblxuLy8gT3B0aW9ucyA9IHtmbHVzaE9uRW5kOiBib29sZWFufHVuZGVmaW5lZH1cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufGZhbHNleSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnxmYWxzZXksIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyV2hpbGUgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1ZmZlcldoaWxlKHRoaXMsIGZuLCBvcHRpb25zKTtcbn07XG5cbi8vIChTdHJlYW0sIG51bWJlcikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIG51bWJlcikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlcldpdGhDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgb3B0aW9ucykge1xuICByZXR1cm4gYnVmZmVyV2hpbGUkMSh0aGlzLCBjb3VudCwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ZsdXNoT25FbmQ6IGJvb2xlYW58dW5kZWZpbmVkfVxuLy8gKFN0cmVhbSwgbnVtYmVyLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgbnVtYmVyLCBudW1iZXIsIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyV2l0aFRpbWVPckNvdW50ID0gZnVuY3Rpb24gKHdhaXQsIGNvdW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJXaXRoVGltZU9yQ291bnQodGhpcywgd2FpdCwgY291bnQsIG9wdGlvbnMpO1xufTtcblxuLy8gKFN0cmVhbSwgRnVuY3Rpb24pIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbikgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnRyYW5zZHVjZSA9IGZ1bmN0aW9uICh0cmFuc2R1Y2VyKSB7XG4gIHJldHVybiB0cmFuc2R1Y2UodGhpcywgdHJhbnNkdWNlcik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9uKSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHdpdGhIYW5kbGVyKHRoaXMsIGZuKTtcbn07XG5cbi8vIChTdHJlYW0sIFN0cmVhbSAtPiBhKSAtPiBhXG4vLyAoUHJvcGVydHksIFByb3BlcnR5IC0+IGEpIC0+IGFcbk9ic2VydmFibGUucHJvdG90eXBlLnRocnUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuKHRoaXMpO1xufTtcblxuLy8gQ29tYmluZSBvYnNlcnZhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4sIEZ1bmN0aW9ufHVuZGVmaWVuZCkgLT4gU3RyZWFtXG4vLyAoQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXIsIGNvbWJpbmF0b3IpIHtcbiAgcmV0dXJuIGNvbWJpbmUoW3RoaXMsIG90aGVyXSwgY29tYmluYXRvcik7XG59O1xuXG4vLyAoQXJyYXk8U3RyZWFtfFByb3BlcnR5PiwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLnppcCA9IGZ1bmN0aW9uIChvdGhlciwgY29tYmluYXRvcikge1xuICByZXR1cm4gemlwKFt0aGlzLCBvdGhlcl0sIGNvbWJpbmF0b3IpO1xufTtcblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4pIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIG1lcmdlKFt0aGlzLCBvdGhlcl0pO1xufTtcblxuLy8gKEFycmF5PFN0cmVhbXxQcm9wZXJ0eT4pIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiBjb25jYXQkMShbdGhpcywgb3RoZXJdKTtcbn07XG5cbi8vICgpIC0+IFBvb2xcbnZhciBwb29sID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvb2woKTtcbn07XG5cbi8vIChGdW5jdGlvbikgLT4gU3RyZWFtXG4vLyBPcHRpb25zID0ge2NvbmN1ckxpbTogbnVtYmVyfHVuZGVmaW5lZCwgcXVldWVMaW06IG51bWJlcnx1bmRlZmluZWQsIGRyb3A6ICdvbGQnfCduZXcnfHVuZGVmaWVuZH1cbi8vIChTdHJlYW18UHJvcGVydHksIEZ1bmN0aW9ufGZhbHNleSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFN0cmVhbVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gbmV3IEZsYXRNYXAodGhpcywgZm4pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXAnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwTGF0ZXN0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBuZXcgRmxhdE1hcCh0aGlzLCBmbiwgeyBjb25jdXJMaW06IDEsIGRyb3A6ICdvbGQnIH0pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXBMYXRlc3QnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwRmlyc3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5ldyBGbGF0TWFwKHRoaXMsIGZuLCB7IGNvbmN1ckxpbTogMSB9KS5zZXROYW1lKHRoaXMsICdmbGF0TWFwRmlyc3QnKTtcbn07XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwQ29uY2F0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBuZXcgRmxhdE1hcCh0aGlzLCBmbiwgeyBxdWV1ZUxpbTogLTEsIGNvbmN1ckxpbTogMSB9KS5zZXROYW1lKHRoaXMsICdmbGF0TWFwQ29uY2F0Jyk7XG59O1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcENvbmN1ckxpbWl0ID0gZnVuY3Rpb24gKGZuLCBsaW1pdCkge1xuICByZXR1cm4gbmV3IEZsYXRNYXAodGhpcywgZm4sIHsgcXVldWVMaW06IC0xLCBjb25jdXJMaW06IGxpbWl0IH0pLnNldE5hbWUodGhpcywgJ2ZsYXRNYXBDb25jdXJMaW1pdCcpO1xufTtcblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSwgRnVuY3Rpb258ZmFsc2V5KSAtPiBTdHJlYW1cbk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXBFcnJvcnMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIG5ldyBGbGF0TWFwRXJyb3JzKHRoaXMsIGZuKS5zZXROYW1lKHRoaXMsICdmbGF0TWFwRXJyb3JzJyk7XG59O1xuXG4vLyBDb21iaW5lIHR3byBvYnNlcnZhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5KSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyQnkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIGZpbHRlckJ5KHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIChTdHJlYW0sIFN0cmVhbXxQcm9wZXJ0eSwgRnVuY3Rpb258dW5kZWZpZW5kKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmllbmQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGVkQnkgPSBmdW5jdGlvbiAob3RoZXIsIGNvbWJpbmF0b3IpIHtcbiAgcmV0dXJuIHNhbXBsZWRCeSh0aGlzLCBvdGhlciwgY29tYmluYXRvcik7XG59O1xuXG4vLyAoU3RyZWFtLCBTdHJlYW18UHJvcGVydHkpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBTdHJlYW18UHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwVW50aWxCeSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gc2tpcFVudGlsQnkodGhpcywgb3RoZXIpO1xufTtcblxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5KSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsQnkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIHRha2VVbnRpbEJ5KHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIE9wdGlvbnMgPSB7Zmx1c2hPbkVuZDogYm9vbGVhbnx1bmRlZmluZWR9XG4vLyAoU3RyZWFtLCBTdHJlYW18UHJvcGVydHksIE9wdGlvbnN8dW5kZWZpbmVkKSAtPiBTdHJlYW1cbi8vIChQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5LCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlckJ5ID0gZnVuY3Rpb24gKG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJCeSh0aGlzLCBvdGhlciwgb3B0aW9ucyk7XG59O1xuXG4vLyBPcHRpb25zID0ge2ZsdXNoT25FbmQ6IGJvb2xlYW58dW5kZWZpbmVkfVxuLy8gKFN0cmVhbSwgU3RyZWFtfFByb3BlcnR5LCBPcHRpb25zfHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIFN0cmVhbXxQcm9wZXJ0eSwgT3B0aW9uc3x1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXJXaGlsZUJ5ID0gZnVuY3Rpb24gKG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWZmZXJXaGlsZUJ5KHRoaXMsIG90aGVyLCBvcHRpb25zKTtcbn07XG5cbi8vIERlcHJlY2F0ZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBERVBSRUNBVElPTl9XQVJOSU5HUyA9IHRydWU7XG5mdW5jdGlvbiBkaXNzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoKSB7XG4gIERFUFJFQ0FUSU9OX1dBUk5JTkdTID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmIChERVBSRUNBVElPTl9XQVJOSU5HUyAmJiBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgbXNnMiA9ICdcXG5IZXJlIGlzIGFuIEVycm9yIG9iamVjdCBmb3IgeW91IGNvbnRhaW5pbmcgdGhlIGNhbGwgc3RhY2s6JztcbiAgICBjb25zb2xlLndhcm4obXNnLCBtc2cyLCBuZXcgRXJyb3IoKSk7XG4gIH1cbn1cblxuLy8gKFN0cmVhbXxQcm9wZXJ0eSwgU3RyZWFtfFByb3BlcnR5KSAtPiBQcm9wZXJ0eVxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYXdhaXRpbmcgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgd2FybignWW91IGFyZSB1c2luZyBkZXByZWNhdGVkIC5hd2FpdGluZygpIG1ldGhvZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWZpcmpzL2tlZmlyL2lzc3Vlcy8xNDUnKTtcbiAgcmV0dXJuIGF3YWl0aW5nKHRoaXMsIG90aGVyKTtcbn07XG5cbi8vIChTdHJlYW0sIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHksIEZ1bmN0aW9ufHVuZGVmaW5lZCkgLT4gUHJvcGVydHlcbk9ic2VydmFibGUucHJvdG90eXBlLnZhbHVlc1RvRXJyb3JzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHdhcm4oJ1lvdSBhcmUgdXNpbmcgZGVwcmVjYXRlZCAudmFsdWVzVG9FcnJvcnMoKSBtZXRob2QsIHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvMTQ5Jyk7XG4gIHJldHVybiB2YWx1ZXNUb0Vycm9ycyh0aGlzLCBmbik7XG59O1xuXG4vLyAoU3RyZWFtLCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFN0cmVhbVxuLy8gKFByb3BlcnR5LCBGdW5jdGlvbnx1bmRlZmluZWQpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5lcnJvcnNUb1ZhbHVlcyA9IGZ1bmN0aW9uIChmbikge1xuICB3YXJuKCdZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgLmVycm9yc1RvVmFsdWVzKCkgbWV0aG9kLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tlZmlyanMva2VmaXIvaXNzdWVzLzE0OScpO1xuICByZXR1cm4gZXJyb3JzVG9WYWx1ZXModGhpcywgZm4pO1xufTtcblxuLy8gKFN0cmVhbSkgLT4gU3RyZWFtXG4vLyAoUHJvcGVydHkpIC0+IFByb3BlcnR5XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5lbmRPbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICB3YXJuKCdZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgLmVuZE9uRXJyb3IoKSBtZXRob2QsIHNlZSBodHRwczovL2dpdGh1Yi5jb20va2VmaXJqcy9rZWZpci9pc3N1ZXMvMTUwJyk7XG4gIHJldHVybiBlbmRPbkVycm9yKHRoaXMpO1xufTtcblxuLy8gRXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIEtlZmlyID0ge1xuICBPYnNlcnZhYmxlOiBPYnNlcnZhYmxlLFxuICBTdHJlYW06IFN0cmVhbSxcbiAgUHJvcGVydHk6IFByb3BlcnR5LFxuICBuZXZlcjogbmV2ZXIsXG4gIGxhdGVyOiBsYXRlcixcbiAgaW50ZXJ2YWw6IGludGVydmFsLFxuICBzZXF1ZW50aWFsbHk6IHNlcXVlbnRpYWxseSxcbiAgZnJvbVBvbGw6IGZyb21Qb2xsLFxuICB3aXRoSW50ZXJ2YWw6IHdpdGhJbnRlcnZhbCxcbiAgZnJvbUNhbGxiYWNrOiBmcm9tQ2FsbGJhY2ssXG4gIGZyb21Ob2RlQ2FsbGJhY2s6IGZyb21Ob2RlQ2FsbGJhY2ssXG4gIGZyb21FdmVudHM6IGZyb21FdmVudHMsXG4gIHN0cmVhbTogc3RyZWFtLFxuICBjb25zdGFudDogY29uc3RhbnQsXG4gIGNvbnN0YW50RXJyb3I6IGNvbnN0YW50RXJyb3IsXG4gIGZyb21Qcm9taXNlOiBmcm9tUHJvbWlzZSxcbiAgZnJvbUVTT2JzZXJ2YWJsZTogZnJvbUVTT2JzZXJ2YWJsZSxcbiAgY29tYmluZTogY29tYmluZSxcbiAgemlwOiB6aXAsXG4gIG1lcmdlOiBtZXJnZSxcbiAgY29uY2F0OiBjb25jYXQkMSxcbiAgUG9vbDogUG9vbCxcbiAgcG9vbDogcG9vbCxcbiAgcmVwZWF0OiByZXBlYXQsXG4gIHN0YXRpY0xhbmQ6IHN0YXRpY0xhbmRcbn07XG5cbktlZmlyLktlZmlyID0gS2VmaXI7XG5cbmV4cG9ydCB7IGRpc3NhYmxlRGVwcmVjYXRpb25XYXJuaW5ncywgS2VmaXIsIE9ic2VydmFibGUsIFN0cmVhbSwgUHJvcGVydHksIG5ldmVyLCBsYXRlciwgaW50ZXJ2YWwsIHNlcXVlbnRpYWxseSwgZnJvbVBvbGwsIHdpdGhJbnRlcnZhbCwgZnJvbUNhbGxiYWNrLCBmcm9tTm9kZUNhbGxiYWNrLCBmcm9tRXZlbnRzLCBzdHJlYW0sIGNvbnN0YW50LCBjb25zdGFudEVycm9yLCBmcm9tUHJvbWlzZSwgZnJvbUVTT2JzZXJ2YWJsZSwgY29tYmluZSwgemlwLCBtZXJnZSwgY29uY2F0JDEgYXMgY29uY2F0LCBQb29sLCBwb29sLCByZXBlYXQsIHN0YXRpY0xhbmQgfTtleHBvcnQgZGVmYXVsdCBLZWZpcjtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgfVxuICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xhbXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbHRlcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgfVxuICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cbiAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoIShzZWVuXG4gICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICkpIHtcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUludGVyc2VjdGlvbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgYmFzZVNvcnRCeSA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0QnknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjb21wYXJlTXVsdGlwbGUgPSByZXF1aXJlKCcuL19jb21wYXJlTXVsdGlwbGUnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gIH1cblxuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU9yZGVyQnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eU9mO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZSgnLi9fdHJpbW1lZEVuZEluZGV4Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVHJpbTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEFycmF5TGlrZU9iamVjdDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVBc2NlbmRpbmc7XG4iLCJ2YXIgY29tcGFyZUFzY2VuZGluZyA9IHJlcXVpcmUoJy4vX2NvbXBhcmVBc2NlbmRpbmcnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTXVsdGlwbGU7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsInZhciBiYXNlUHJvcGVydHlPZiA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eU9mJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUh0bWxDaGFyO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAqL1xuZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgbiA9IHRvSW50ZWdlcihuKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmVmb3JlO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZXNjYXBlSHRtbENoYXIgPSByZXF1aXJlKCcuL19lc2NhcGVIdG1sQ2hhcicpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZTtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgYmFzZUZpbHRlciA9IHJlcXVpcmUoJy4vX2Jhc2VGaWx0ZXInKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgY3JlYXRlRmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUZpbmQnKSxcbiAgICBmaW5kSW5kZXggPSByZXF1aXJlKCcuL2ZpbmRJbmRleCcpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhcyA9IHJlcXVpcmUoJy4vX2Jhc2VIYXMnKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXM7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKSxcbiAgICB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5jbHVkZXM7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL19iYXNlSW50ZXJzZWN0aW9uJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGNhc3RBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL19jYXN0QXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gKiAvLyA9PiBbMl1cbiAqL1xudmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgOiBbXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdGlvbjtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIGJlZm9yZSA9IHJlcXVpcmUoJy4vYmVmb3JlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gKiBpbml0aWFsaXplKCk7XG4gKiBpbml0aWFsaXplKCk7XG4gKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICovXG5mdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmNlO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlT3JkZXJCeSA9IHJlcXVpcmUoJy4vX2Jhc2VPcmRlckJ5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuIiwidmFyIGJhc2VDbGFtcCA9IHJlcXVpcmUoJy4vX2Jhc2VDbGFtcCcpLFxuICAgIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgID8gMFxuICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFydHNXaXRoO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgYmFzZVRyaW0gPSByZXF1aXJlKCcuL19iYXNlVHJpbScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoO1xudmFyIHByb3RvID0gZ2xvYmFsLkVsZW1lbnQgJiYgZ2xvYmFsLkVsZW1lbnQucHJvdG90eXBlO1xudmFyIHZlbmRvciA9IHByb3RvICYmIChwcm90by5tYXRjaGVzIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvciB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3IpO1xuXG5mdW5jdGlvbiBtYXRjaChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIHZhciBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcblxuICBpZiAocGFyZW50Tm9kZSAmJiB0eXBlb2YgcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChub2Rlc1tpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2V3lKd2NtOTBieUlzSW1kc2IySmhiQ0lzSWtWc1pXMWxiblFpTENKd2NtOTBiM1I1Y0dVaUxDSjJaVzVrYjNJaUxDSnRZWFJqYUdWeklpd2liV0YwWTJobGMxTmxiR1ZqZEc5eUlpd2lkMlZpYTJsMFRXRjBZMmhsYzFObGJHVmpkRzl5SWl3aWJXOTZUV0YwWTJobGMxTmxiR1ZqZEc5eUlpd2liWE5OWVhSamFHVnpVMlZzWldOMGIzSWlMQ0p2VFdGMFkyaGxjMU5sYkdWamRHOXlJaXdpYldGMFkyZ2lMQ0psYkNJc0luTmxiR1ZqZEc5eUlpd2lZMkZzYkNJc0luQmhjbVZ1ZEU1dlpHVWlMQ0p4ZFdWeWVWTmxiR1ZqZEc5eVFXeHNJaXdpYm05a1pYTWlMQ0pwSWl3aWJHVnVaM1JvSWwwc0ltMWhjSEJwYm1keklqb2lPenM3TzBGQlJVRXNTVUZCVFVFc1MwRkJTeXhIUVVGSFF5eE5RVUZOTEVOQlFVTkRMRTlCUVZBc1NVRkJhMEpFTEUxQlFVMHNRMEZCUTBNc1QwRkJVQ3hEUVVGbFF5eFRRVUV2UXp0QlFVTkJMRWxCUVUxRExFMUJRVTBzUjBGQlIwb3NTMEZCU3l4TFFVRkxRU3hMUVVGTExFTkJRVU5MTEU5QlFVNHNTVUZEY0VKTUxFdEJRVXNzUTBGQlEwMHNaVUZFWXl4SlFVVndRazRzUzBGQlN5eERRVUZEVHl4eFFrRkdZeXhKUVVkd1FsQXNTMEZCU3l4RFFVRkRVU3hyUWtGSVl5eEpRVWx3UWxJc1MwRkJTeXhEUVVGRFV5eHBRa0ZLWXl4SlFVdHdRbFFzUzBGQlN5eERRVUZEVlN4blFrRk1VeXhEUVVGd1FqczdRVUZQWlN4VFFVRlRReXhMUVVGVUxFTkJRV1ZETEVWQlFXWXNSVUZCWjBORExGRkJRV2hETEVWQlFUSkVPMEZCUTNoRkxFMUJRVWxVTEUxQlFVb3NSVUZCV1N4UFFVRlBRU3hOUVVGTkxFTkJRVU5WTEVsQlFWQXNRMEZCV1VZc1JVRkJXaXhGUVVGblFrTXNVVUZCYUVJc1EwRkJVRHRCUVVRMFJDeE5RVVZxUlVVc1ZVRkdhVVVzUjBGRmJrUklMRVZCUm0xRUxFTkJSV3BGUnl4VlFVWnBSVHM3UVVGSGVFVXNUVUZCU1VFc1ZVRkJWU3hKUVVGSkxFOUJRVkZCTEZWQlFVUXNRMEZCYVVKRExHZENRVUY0UWl4TFFVRTJReXhWUVVFdlJDeEZRVUV5UlR0QlFVTjZSU3hSUVVGTlF5eExRVUZMTEVkQlFVbEdMRlZCUVVRc1EwRkJhVUpETEdkQ1FVRnFRaXhEUVVGclEwZ3NVVUZCYkVNc1EwRkJaRHM3UVVGRFFTeFRRVUZMTEVsQlFVbExMRU5CUVVNc1IwRkJSeXhEUVVGaUxFVkJRV2RDUVN4RFFVRkRMRWRCUVVkRUxFdEJRVXNzUTBGQlEwVXNUVUZCTVVJc1JVRkJhME5FTEVOQlFVTXNSVUZCYmtNc1JVRkJkVU03UVVGRGNrTXNWVUZCU1VRc1MwRkJTeXhEUVVGRFF5eERRVUZFTEVOQlFVd3NTMEZCWVU0c1JVRkJha0lzUlVGQmNVSXNUMEZCVHl4SlFVRlFPMEZCUTNSQ08wRkJRMFk3TzBGQlEwUXNVMEZCVHl4TFFVRlFPMEZCUTBRaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaUJBWm14dmR5QXFMMXh1WEc1amIyNXpkQ0J3Y205MGJ5QTlJR2RzYjJKaGJDNUZiR1Z0Wlc1MElDWW1JR2RzYjJKaGJDNUZiR1Z0Wlc1MExuQnliM1J2ZEhsd1pUdGNibU52Ym5OMElIWmxibVJ2Y2lBOUlIQnliM1J2SUNZbUlDaHdjbTkwYnk1dFlYUmphR1Z6WEc0Z0lIeDhJSEJ5YjNSdkxtMWhkR05vWlhOVFpXeGxZM1J2Y2x4dUlDQjhmQ0J3Y205MGJ5NTNaV0pyYVhSTllYUmphR1Z6VTJWc1pXTjBiM0pjYmlBZ2ZId2djSEp2ZEc4dWJXOTZUV0YwWTJobGMxTmxiR1ZqZEc5eVhHNGdJSHg4SUhCeWIzUnZMbTF6VFdGMFkyaGxjMU5sYkdWamRHOXlYRzRnSUh4OElIQnliM1J2TG05TllYUmphR1Z6VTJWc1pXTjBiM0lwTzF4dVhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCbWRXNWpkR2x2YmlCdFlYUmphQ2hsYkRvZ1NGUk5URVZzWlcxbGJuUXNJSE5sYkdWamRHOXlPaUJ6ZEhKcGJtY3BPaUJpYjI5c1pXRnVJSHRjYmlBZ2FXWWdLSFpsYm1SdmNpa2djbVYwZFhKdUlIWmxibVJ2Y2k1allXeHNLR1ZzTENCelpXeGxZM1J2Y2lrN1hHNGdJR052Ym5OMElIdHdZWEpsYm5ST2IyUmxmU0E5SUdWc08xeHVJQ0JwWmlBb2NHRnlaVzUwVG05a1pTQW1KaUIwZVhCbGIyWWdLSEJoY21WdWRFNXZaR1U2WVc1NUtTNXhkV1Z5ZVZObGJHVmpkRzl5UVd4c0lEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnWTI5dWMzUWdibTlrWlhNZ1BTQW9jR0Z5Wlc1MFRtOWtaVHBoYm5rcExuRjFaWEo1VTJWc1pXTjBiM0pCYkd3b2MyVnNaV04wYjNJcE8xeHVJQ0FnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2JtOWtaWE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHbG1JQ2h1YjJSbGMxdHBYU0E5UFQwZ1pXd3BJSEpsZEhWeWJpQjBjblZsTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNTlYRzRpWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVsYXk7XG5cbmZ1bmN0aW9uIGRlbGF5KHRpbWUsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2V3lKa1pXeGhlU0lzSW5ScGJXVWlMQ0oyWVd4MVpTSXNJbEJ5YjIxcGMyVWlMQ0p5WlhOdmJIWmxJaXdpYzJWMFZHbHRaVzkxZENKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096dEJRVVZsTEZOQlFWTkJMRXRCUVZRc1EwRkJhMEpETEVsQlFXeENMRVZCUVdkRFF5eExRVUZvUXl4RlFVRnRSVHRCUVVOb1JpeFRRVUZQTEVsQlFVbERMRTlCUVVvc1EwRkJXU3hWUVVGQlF5eFBRVUZQTEVWQlFVazdRVUZETlVKRExFbEJRVUZCTEZWQlFWVXNRMEZCUXl4WlFVRk5PMEZCUTJaRUxFMUJRVUZCTEU5QlFVOHNRMEZCUTBZc1MwRkJSQ3hEUVVGUU8wRkJRMFFzUzBGR1V5eEZRVVZRUkN4SlFVWlBMRU5CUVZZN1FVRkhSQ3hIUVVwTkxFTkJRVkE3UVVGTFJDSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxSUVCbWJHOTNJQ292WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdaMWJtTjBhVzl1SUdSbGJHRjVQRlErS0hScGJXVTZJRzUxYldKbGNpd2dkbUZzZFdVNklGQnliMjFwYzJVOFZENGdmQ0JVS1RvZ1VISnZiV2x6WlR4VVBpQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1VISnZiV2x6WlNoeVpYTnZiSFpsSUQwK0lIdGNiaUFnSUNCelpYUlVhVzFsYjNWMEtDZ3BJRDArSUh0Y2JpQWdJQ0FnSUhKbGMyOXNkbVVvZG1Gc2RXVXBPMXh1SUNBZ0lIMHNJSFJwYldVcE8xeHVJQ0I5S1R0Y2JuMWNiaUpkZlE9PSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiXG4vLyBiYXNpYyBwcm90b2NvbCBoZWxwZXJzXG5cbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIHByb3RvY29scyA9IHtcbiAgaXRlcmF0b3I6IHN5bWJvbEV4aXN0cyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJ1xufTtcblxuZnVuY3Rpb24gdGhyb3dQcm90b2NvbEVycm9yKG5hbWUsIGNvbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiZG9uJ3Qga25vdyBob3cgdG8gXCIgKyBuYW1lICsgXCIgY29sbGVjdGlvbjogXCIgK1xuICAgICAgICAgICAgICAgICAgY29sbCk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGxzUHJvdG9jb2wob2JqLCBuYW1lKSB7XG4gIGlmKG5hbWUgPT09ICdpdGVyYXRvcicpIHtcbiAgICAvLyBBY2NlcHQgaWxsLWZvcm1lZCBpdGVyYXRvcnMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZVxuICAgIC8vIHByb3RvY29sIGJ5IGFjY2VwdGluZyBqdXN0IG5leHQoKVxuICAgIHJldHVybiBvYmpbcHJvdG9jb2xzLml0ZXJhdG9yXSB8fCBvYmoubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvYmpbcHJvdG9jb2xzW25hbWVdXTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG9jb2xQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgcmV0dXJuIG9ialtwcm90b2NvbHNbbmFtZV1dO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRvcihjb2xsKSB7XG4gIHZhciBpdGVyID0gZ2V0UHJvdG9jb2xQcm9wZXJ0eShjb2xsLCAnaXRlcmF0b3InKTtcbiAgaWYoaXRlcikge1xuICAgIHJldHVybiBpdGVyLmNhbGwoY29sbCk7XG4gIH1cbiAgZWxzZSBpZihjb2xsLm5leHQpIHtcbiAgICAvLyBCYXNpYyBkdWNrIHR5cGluZyB0byBhY2NlcHQgYW4gaWxsLWZvcm1lZCBpdGVyYXRvciB0aGF0IGRvZXNuJ3RcbiAgICAvLyBjb25mb3JtIHRvIHRoZSBpdGVyYXRvciBwcm90b2NvbCAoYWxsIGl0ZXJhdG9ycyBzaG91bGQgaGF2ZSB0aGVcbiAgICAvLyBAQGl0ZXJhdG9yIG1ldGhvZCBhbmQgcmV0dXJuIHRoZW1zZWx2ZXMsIGJ1dCBzb21lIGVuZ2luZXMgZG9uJ3RcbiAgICAvLyBoYXZlIHRoYXQgb24gZ2VuZXJhdG9ycyBsaWtlIG9sZGVyIHY4KVxuICAgIHJldHVybiBjb2xsO1xuICB9XG4gIGVsc2UgaWYoaXNBcnJheShjb2xsKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihjb2xsKTtcbiAgfVxuICBlbHNlIGlmKGlzT2JqZWN0KGNvbGwpKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RJdGVyYXRvcihjb2xsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBBcnJheUl0ZXJhdG9yKGFycikge1xuICB0aGlzLmFyciA9IGFycjtcbiAgdGhpcy5pbmRleCA9IDA7XG59XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5pbmRleCA8IHRoaXMuYXJyLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdGhpcy5hcnJbdGhpcy5pbmRleCsrXSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHRydWVcbiAgfVxufTtcblxuZnVuY3Rpb24gT2JqZWN0SXRlcmF0b3Iob2JqKSB7XG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLmtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB0aGlzLmluZGV4ID0gMDtcbn1cblxuT2JqZWN0SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5pbmRleCA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICB2YXIgayA9IHRoaXMua2V5c1t0aGlzLmluZGV4KytdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogW2ssIHRoaXMub2JqW2tdXSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHRydWVcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBSZWR1Y2VkKHZhbHVlKSB7XG4gIHRoaXNbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPSB0cnVlO1xuICB0aGlzWydAQHRyYW5zZHVjZXIvdmFsdWUnXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1JlZHVjZWQoeCkge1xuICByZXR1cm4gKHggaW5zdGFuY2VvZiBSZWR1Y2VkKSB8fCAoeCAmJiB4WydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKTtcbn1cblxuZnVuY3Rpb24gZGVyZWYoeCkge1xuICByZXR1cm4geFsnQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG59XG5cbi8qKlxuICogVGhpcyBpcyBmb3IgdHJhbnNmb3JtcyB0aGF0IG1heSBjYWxsIHRoZWlyIG5lc3RlZCB0cmFuc2Zvcm1zIGJlZm9yZVxuICogUmVkdWNlZC13cmFwcGluZyB0aGUgcmVzdWx0IChlLmcuIFwidGFrZVwiKSwgdG8gYXZvaWQgbmVzdGVkIFJlZHVjZWQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVJlZHVjZWQodmFsKSB7XG4gIGlmKGlzUmVkdWNlZCh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFJlZHVjZWQodmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgZm9yIHRyYW5mb3JtcyB0aGF0IGNhbGwgdGhlaXIgbmVzdGVkIHRyYW5zZm9ybXMgd2hlblxuICogcGVyZm9ybWluZyBjb21wbGV0aW9uIChsaWtlIFwicGFydGl0aW9uXCIpLCB0byBhdm9pZCBzaWduYWxpbmdcbiAqIHRlcm1pbmF0aW9uIGFmdGVyIGFscmVhZHkgY29tcGxldGluZy5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlVW5yZWR1Y2VkKHYpIHtcbiAgaWYoaXNSZWR1Y2VkKHYpKSB7XG4gICAgcmV0dXJuIGRlcmVmKHYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShjb2xsLCB4Zm9ybSwgaW5pdCkge1xuICBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluaXQ7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgIHdoaWxlKCsraW5kZXggPCBsZW4pIHtcbiAgICAgIHJlc3VsdCA9IHhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgY29sbFtpbmRleF0pO1xuICAgICAgaWYoaXNSZWR1Y2VkKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZGVyZWYocmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH1cbiAgZWxzZSBpZihpc09iamVjdChjb2xsKSB8fCBmdWxmaWxsc1Byb3RvY29sKGNvbGwsICdpdGVyYXRvcicpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluaXQ7XG4gICAgdmFyIGl0ZXIgPSBpdGVyYXRvcihjb2xsKTtcbiAgICB2YXIgdmFsID0gaXRlci5uZXh0KCk7XG4gICAgd2hpbGUoIXZhbC5kb25lKSB7XG4gICAgICByZXN1bHQgPSB4Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZhbC52YWx1ZSk7XG4gICAgICBpZihpc1JlZHVjZWQocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBkZXJlZihyZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbCA9IGl0ZXIubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4geGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9XG4gIHRocm93UHJvdG9jb2xFcnJvcignaXRlcmF0ZScsIGNvbGwpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIHJlZHVjZXIsIGluaXQpIHtcbiAgeGZvcm0gPSB4Zm9ybShyZWR1Y2VyKTtcbiAgaWYoaW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdCA9IHhmb3JtWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gIH1cbiAgcmV0dXJuIHJlZHVjZShjb2xsLCB4Zm9ybSwgaW5pdCk7XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIHZhciBmdW5jcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHZhbHVlID0gcjtcbiAgICBmb3IodmFyIGk9ZnVuY3MubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgdmFsdWUgPSBmdW5jc1tpXSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm1hdGlvbnNcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoZikge1xuICB2YXIgdCA9IHt9O1xuICB0WydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IHZhbHVlIHVuYXZhaWxhYmxlJyk7XG4gIH07XG4gIHRbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcbiAgdFsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGY7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBib3VuZChmLCBjdHgsIGNvdW50KSB7XG4gIGNvdW50ID0gY291bnQgIT0gbnVsbCA/IGNvdW50IDogMTtcblxuICBpZighY3R4KSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZWxzZSB7XG4gICAgc3dpdGNoKGNvdW50KSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGYuY2FsbChjdHgsIHgpO1xuICAgICAgfVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBmLmNhbGwoY3R4LCB4LCB5KTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGYuYmluZChjdHgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheU1hcChhcnIsIGYsIGN0eCkge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICBmID0gYm91bmQoZiwgY3R4LCAyKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBmKGFycltpbmRleF0sIGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnIsIGYsIGN0eCkge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmID0gYm91bmQoZiwgY3R4LCAyKTtcblxuICBmb3IodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgIGlmKGYoYXJyW2ldLCBpKSkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gTWFwKGYsIHhmb3JtKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5mID0gZjtcbn1cblxuTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xufTtcblxuTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHYpO1xufTtcblxuTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlcywgaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzLCB0aGlzLmYoaW5wdXQpKTtcbn07XG5cbmZ1bmN0aW9uIG1hcChjb2xsLCBmLCBjdHgpIHtcbiAgaWYoaXNGdW5jdGlvbihjb2xsKSkgeyBjdHggPSBmOyBmID0gY29sbDsgY29sbCA9IG51bGw7IH1cbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG5cbiAgaWYoY29sbCkge1xuICAgIGlmKGlzQXJyYXkoY29sbCkpIHtcbiAgICAgIHJldHVybiBhcnJheU1hcChjb2xsLCBmLCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VxKGNvbGwsIG1hcChmKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IE1hcChmLCB4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gRmlsdGVyKGYsIHhmb3JtKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5mID0gZjtcbn1cblxuRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHYpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlcywgaW5wdXQpIHtcbiAgaWYodGhpcy5mKGlucHV0KSkge1xuICAgIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlcywgaW5wdXQpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIoY29sbCwgZiwgY3R4KSB7XG4gIGlmKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuXG4gIGlmKGNvbGwpIHtcbiAgICBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIoY29sbCwgZiwgY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcShjb2xsLCBmaWx0ZXIoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZiwgeGZvcm0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZW1vdmUoY29sbCwgZiwgY3R4KSB7XG4gIGlmKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuICByZXR1cm4gZmlsdGVyKGNvbGwsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFmKHgpOyB9KTtcbn1cblxuZnVuY3Rpb24ga2VlcChjb2xsKSB7XG4gIHJldHVybiBmaWx0ZXIoY29sbCwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCAhPSBudWxsIH0pO1xufVxuXG5mdW5jdGlvbiBEZWR1cGUoeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLmxhc3QgPSB1bmRlZmluZWQ7XG59XG5cbkRlZHVwZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cbkRlZHVwZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cbkRlZHVwZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKGlucHV0ICE9PSB0aGlzLmxhc3QpIHtcbiAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZGVkdXBlKGNvbGwpIHtcbiAgaWYoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgZGVkdXBlKCkpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBEZWR1cGUoeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRha2VXaGlsZShmLCB4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMuZiA9IGY7XG59XG5cblRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cblRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cblRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKHRoaXMuZihpbnB1dCkpIHtcbiAgICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZHVjZWQocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIHRha2VXaGlsZShjb2xsLCBmLCBjdHgpIHtcbiAgaWYoaXNGdW5jdGlvbihjb2xsKSkgeyBjdHggPSBmOyBmID0gY29sbDsgY29sbCA9IG51bGw7IH1cbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG5cbiAgaWYoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgdGFrZVdoaWxlKGYpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgVGFrZVdoaWxlKGYsIHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUYWtlKG4sIHhmb3JtKSB7XG4gIHRoaXMubiA9IG47XG4gIHRoaXMuaSA9IDA7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbn1cblxuVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cblRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odik7XG59O1xuXG5UYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgaWYgKHRoaXMuaSA8IHRoaXMubikge1xuICAgIHJlc3VsdCA9IHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgaWYodGhpcy5pICsgMSA+PSB0aGlzLm4pIHtcbiAgICAgIC8vIEZpbmlzaCByZWR1Y2luZyBvbiB0aGUgc2FtZSBzdGVwIGFzIHRoZSBmaW5hbCB2YWx1ZS4gVE9ETzpcbiAgICAgIC8vIGRvdWJsZS1jaGVjayB0aGF0IHRoaXMgZG9lc24ndCBicmVhayBhbnkgc2VtYW50aWNzXG4gICAgICByZXN1bHQgPSBlbnN1cmVSZWR1Y2VkKHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIHRoaXMuaSsrO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdGFrZShjb2xsLCBuKSB7XG4gIGlmKGlzTnVtYmVyKGNvbGwpKSB7IG4gPSBjb2xsOyBjb2xsID0gbnVsbCB9XG5cbiAgaWYoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgdGFrZShuKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IFRha2UobiwgeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIERyb3AobiwgeGZvcm0pIHtcbiAgdGhpcy5uID0gbjtcbiAgdGhpcy5pID0gMDtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xufVxuXG5Ecm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xufTtcblxuRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cbkRyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICBpZih0aGlzLmkrKyA8IHRoaXMubikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG59O1xuXG5mdW5jdGlvbiBkcm9wKGNvbGwsIG4pIHtcbiAgaWYoaXNOdW1iZXIoY29sbCkpIHsgbiA9IGNvbGw7IGNvbGwgPSBudWxsIH1cblxuICBpZihjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBkcm9wKG4pKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgRHJvcChuLCB4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gRHJvcFdoaWxlKGYsIHhmb3JtKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5mID0gZjtcbiAgdGhpcy5kcm9wcGluZyA9IHRydWU7XG59XG5cbkRyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cbkRyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cbkRyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKHRoaXMuZHJvcHBpbmcpIHtcbiAgICBpZih0aGlzLmYoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZHJvcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG59O1xuXG5mdW5jdGlvbiBkcm9wV2hpbGUoY29sbCwgZiwgY3R4KSB7XG4gIGlmKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuXG4gIGlmKGNvbGwpIHtcbiAgICByZXR1cm4gc2VxKGNvbGwsIGRyb3BXaGlsZShmKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IERyb3BXaGlsZShmLCB4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUGFydGl0aW9uKG4sIHhmb3JtKSB7XG4gIHRoaXMubiA9IG47XG4gIHRoaXMuaSA9IDA7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5wYXJ0ID0gbmV3IEFycmF5KG4pO1xufVxuXG5QYXJ0aXRpb24ucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG59O1xuXG5QYXJ0aXRpb24ucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLmkgPiAwKSB7XG4gICAgcmV0dXJuIGVuc3VyZVVucmVkdWNlZCh0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHYsIHRoaXMucGFydC5zbGljZSgwLCB0aGlzLmkpKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cblBhcnRpdGlvbi5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIHRoaXMucGFydFt0aGlzLmldID0gaW5wdXQ7XG4gIHRoaXMuaSArPSAxO1xuICBpZiAodGhpcy5pID09PSB0aGlzLm4pIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5wYXJ0LnNsaWNlKDAsIHRoaXMubik7XG4gICAgdGhpcy5wYXJ0ID0gbmV3IEFycmF5KHRoaXMubik7XG4gICAgdGhpcy5pID0gMDtcbiAgICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIG91dCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihjb2xsLCBuKSB7XG4gIGlmIChpc051bWJlcihjb2xsKSkge1xuICAgIG4gPSBjb2xsOyBjb2xsID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBwYXJ0aXRpb24obikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aXRpb24obiwgeGZvcm0pO1xuICB9O1xufVxuXG52YXIgTk9USElORyA9IHt9O1xuXG5mdW5jdGlvbiBQYXJ0aXRpb25CeShmLCB4Zm9ybSkge1xuICAvLyBUT0RPOiB0YWtlIGFuIFwib3B0c1wiIG9iamVjdCB0aGF0IGFsbG93cyB0aGUgdXNlciB0byBzcGVjaWZ5XG4gIC8vIGVxdWFsaXR5XG4gIHRoaXMuZiA9IGY7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5wYXJ0ID0gW107XG4gIHRoaXMubGFzdCA9IE5PVEhJTkc7XG59XG5cblBhcnRpdGlvbkJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xufTtcblxuUGFydGl0aW9uQnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIHZhciBsID0gdGhpcy5wYXJ0Lmxlbmd0aDtcbiAgaWYgKGwgPiAwKSB7XG4gICAgcmV0dXJuIGVuc3VyZVVucmVkdWNlZCh0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHYsIHRoaXMucGFydC5zbGljZSgwLCBsKSkpO1xuICB9XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odik7XG59O1xuXG5QYXJ0aXRpb25CeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5mKGlucHV0KTtcbiAgaWYgKGN1cnJlbnQgPT09IHRoaXMubGFzdCB8fCB0aGlzLmxhc3QgPT09IE5PVEhJTkcpIHtcbiAgICB0aGlzLnBhcnQucHVzaChpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMucGFydCk7XG4gICAgdGhpcy5wYXJ0ID0gW2lucHV0XTtcbiAgfVxuICB0aGlzLmxhc3QgPSBjdXJyZW50O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gcGFydGl0aW9uQnkoY29sbCwgZiwgY3R4KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZiAoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgcGFydGl0aW9uQnkoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aXRpb25CeShmLCB4Zm9ybSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEludGVycG9zZShzZXAsIHhmb3JtKSB7XG4gIHRoaXMuc2VwID0gc2VwO1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xufVxuXG5JbnRlcnBvc2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG59O1xuXG5JbnRlcnBvc2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odik7XG59O1xuXG5JbnRlcnBvc2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgdmFyIHdpdGhTZXAgPSB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5zZXApO1xuICAgIGlmIChpc1JlZHVjZWQod2l0aFNlcCkpIHtcbiAgICAgIHJldHVybiB3aXRoU2VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSh3aXRoU2VwLCBpbnB1dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgZWxlbWVudHMgb2YgdGhlIGdpdmVuXG4gKiBjb2xsZWN0aW9uLCBzZXBhcmF0ZWQgYnkgdGhlIHNwZWNpZmllZCBzZXBhcmF0b3IuIFJldHVybnMgYVxuICogdHJhbnNkdWNlciBpZiBhIGNvbGxlY3Rpb24gaXMgbm90IHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvc2UoY29sbCwgc2VwYXJhdG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgc2VwYXJhdG9yID0gY29sbDtcbiAgICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJwb3NlKHNlcGFyYXRvciwgeGZvcm0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlcShjb2xsLCBpbnRlcnBvc2Uoc2VwYXJhdG9yKSk7XG59XG5cbmZ1bmN0aW9uIFJlcGVhdChuLCB4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMubiA9IG47XG59XG5cblJlcGVhdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cblJlcGVhdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh2KTtcbn07XG5cblJlcGVhdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgciA9IHJlc3VsdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByID0gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyLCBpbnB1dCk7XG4gICAgaWYgKGlzUmVkdWNlZChyKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbGxlY3Rpb24gY29udGFpbmluZyBlbGVtZW50cyBvZiB0aGUgZ2l2ZW5cbiAqIGNvbGxlY3Rpb24sIGVhY2ggcmVwZWF0ZWQgbiB0aW1lcy4gUmV0dXJucyBhIHRyYW5zZHVjZXIgaWYgYVxuICogY29sbGVjdGlvbiBpcyBub3QgcHJvdmlkZWQuXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdChjb2xsLCBuKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgbiA9IGNvbGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGVhdChuLCB4Zm9ybSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2VxKGNvbGwsIHJlcGVhdChuKSk7XG59XG5cbmZ1bmN0aW9uIFRha2VOdGgobiwgeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLm4gPSBuO1xuICB0aGlzLmkgPSAtMTtcbn1cblxuVGFrZU50aC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbn07XG5cblRha2VOdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odik7XG59O1xuXG5UYWtlTnRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgdGhpcy5pICs9IDE7XG4gIGlmICh0aGlzLmkgJSB0aGlzLm4gPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbGxlY3Rpb24gb2YgZXZlcnkgbnRoIGVsZW1lbnQgb2YgdGhlIGdpdmVuXG4gKiBjb2xsZWN0aW9uLiBSZXR1cm5zIGEgdHJhbnNkdWNlciBpZiBhIGNvbGxlY3Rpb24gaXMgbm90IHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiB0YWtlTnRoKGNvbGwsIG50aCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIG50aCA9IGNvbGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgICByZXR1cm4gbmV3IFRha2VOdGgobnRoLCB4Zm9ybSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2VxKGNvbGwsIHRha2VOdGgobnRoKSk7XG59XG5cbi8vIHB1cmUgdHJhbnNkdWNlcnMgKGNhbm5vdCB0YWtlIGNvbGxlY3Rpb25zKVxuXG5mdW5jdGlvbiBDYXQoeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xufVxuXG5DYXQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG59O1xuXG5DYXQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odik7XG59O1xuXG5DYXQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICB2YXIgeGZvcm0gPSB0aGlzLnhmb3JtO1xuICB2YXIgbmV3eGZvcm0gPSB7fTtcbiAgbmV3eGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geGZvcm1bJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbiAgfTtcbiAgbmV3eGZvcm1bJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcbiAgbmV3eGZvcm1bJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgdmFyIHZhbCA9IHhmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgIHJldHVybiBpc1JlZHVjZWQodmFsKSA/IGRlcmVmKHZhbCkgOiB2YWw7XG4gIH07XG5cbiAgcmV0dXJuIHJlZHVjZShpbnB1dCwgbmV3eGZvcm0sIHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBjYXQoeGZvcm0pIHtcbiAgcmV0dXJuIG5ldyBDYXQoeGZvcm0pO1xufVxuXG5mdW5jdGlvbiBtYXBjYXQoZiwgY3R4KSB7XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuICByZXR1cm4gY29tcG9zZShtYXAoZiksIGNhdCk7XG59XG5cbi8vIGNvbGxlY3Rpb24gaGVscGVyc1xuXG5mdW5jdGlvbiBwdXNoKGFyciwgeCkge1xuICBhcnIucHVzaCh4KTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gbWVyZ2Uob2JqLCB4KSB7XG4gIGlmKGlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIpIHtcbiAgICBvYmpbeFswXV0gPSB4WzFdO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoeCk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBvYmpba2V5c1tpXV0gPSB4W2tleXNbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgYXJyYXlSZWR1Y2VyID0ge307XG5hcnJheVJlZHVjZXJbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdO1xufTtcbmFycmF5UmVkdWNlclsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdjtcbn07XG5hcnJheVJlZHVjZXJbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBwdXNoO1xuXG52YXIgb2JqUmVkdWNlciA9IHt9O1xub2JqUmVkdWNlclsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge307XG59O1xub2JqUmVkdWNlclsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdjtcbn07XG5vYmpSZWR1Y2VyWydAQHRyYW5zZHVjZXIvc3RlcCddID0gbWVyZ2U7XG5cbi8vIGJ1aWxkaW5nIG5ldyBjb2xsZWN0aW9uc1xuXG5mdW5jdGlvbiB0b0FycmF5KGNvbGwsIHhmb3JtKSB7XG4gIGlmKCF4Zm9ybSkge1xuICAgIHJldHVybiByZWR1Y2UoY29sbCwgYXJyYXlSZWR1Y2VyLCBbXSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgYXJyYXlSZWR1Y2VyLCBbXSk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqKGNvbGwsIHhmb3JtKSB7XG4gIGlmKCF4Zm9ybSkge1xuICAgIHJldHVybiByZWR1Y2UoY29sbCwgb2JqUmVkdWNlciwge30pO1xuICB9XG4gIHJldHVybiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIG9ialJlZHVjZXIsIHt9KTtcbn1cblxuZnVuY3Rpb24gdG9JdGVyKGNvbGwsIHhmb3JtKSB7XG4gIGlmKCF4Zm9ybSkge1xuICAgIHJldHVybiBpdGVyYXRvcihjb2xsKTtcbiAgfVxuICByZXR1cm4gbmV3IExhenlUcmFuc2Zvcm1lcih4Zm9ybSwgY29sbCk7XG59XG5cbmZ1bmN0aW9uIHNlcShjb2xsLCB4Zm9ybSkge1xuICBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgYXJyYXlSZWR1Y2VyLCBbXSk7XG4gIH1cbiAgZWxzZSBpZihpc09iamVjdChjb2xsKSkge1xuICAgIHJldHVybiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIG9ialJlZHVjZXIsIHt9KTtcbiAgfVxuICBlbHNlIGlmKGNvbGxbJ0BAdHJhbnNkdWNlci9zdGVwJ10pIHtcbiAgICB2YXIgaW5pdDtcbiAgICBpZihjb2xsWydAQHRyYW5zZHVjZXIvaW5pdCddKSB7XG4gICAgICBpbml0ID0gY29sbFsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGluaXQgPSBuZXcgY29sbC5jb25zdHJ1Y3RvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIGNvbGwsIGluaXQpO1xuICB9XG4gIGVsc2UgaWYoZnVsZmlsbHNQcm90b2NvbChjb2xsLCAnaXRlcmF0b3InKSkge1xuICAgIHJldHVybiBuZXcgTGF6eVRyYW5zZm9ybWVyKHhmb3JtLCBjb2xsKTtcbiAgfVxuICB0aHJvd1Byb3RvY29sRXJyb3IoJ3NlcXVlbmNlJywgY29sbCk7XG59XG5cbmZ1bmN0aW9uIGludG8odG8sIHhmb3JtLCBmcm9tKSB7XG4gIGlmKGlzQXJyYXkodG8pKSB7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShmcm9tLCB4Zm9ybSwgYXJyYXlSZWR1Y2VyLCB0byk7XG4gIH1cbiAgZWxzZSBpZihpc09iamVjdCh0bykpIHtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGZyb20sIHhmb3JtLCBvYmpSZWR1Y2VyLCB0byk7XG4gIH1cbiAgZWxzZSBpZih0b1snQEB0cmFuc2R1Y2VyL3N0ZXAnXSkge1xuICAgIHJldHVybiB0cmFuc2R1Y2UoZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgIHhmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICB0byk7XG4gIH1cbiAgdGhyb3dQcm90b2NvbEVycm9yKCdpbnRvJywgdG8pO1xufVxuXG4vLyBsYXppbmVzc1xuXG52YXIgc3RlcHBlciA9IHt9O1xuc3RlcHBlclsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gaXNSZWR1Y2VkKHYpID8gZGVyZWYodikgOiB2O1xufTtcbnN0ZXBwZXJbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihsdCwgeCkge1xuICBsdC5pdGVtcy5wdXNoKHgpO1xuICByZXR1cm4gbHQucmVzdDtcbn07XG5cbmZ1bmN0aW9uIFN0ZXBwZXIoeGZvcm0sIGl0ZXIpIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtKHN0ZXBwZXIpO1xuICB0aGlzLml0ZXIgPSBpdGVyO1xufVxuXG5TdGVwcGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKGx0KSB7XG4gIHZhciBsZW4gPSBsdC5pdGVtcy5sZW5ndGg7XG4gIHdoaWxlKGx0Lml0ZW1zLmxlbmd0aCA9PT0gbGVuKSB7XG4gICAgdmFyIG4gPSB0aGlzLml0ZXIubmV4dCgpO1xuICAgIGlmKG4uZG9uZSB8fCBpc1JlZHVjZWQobi52YWx1ZSkpIHtcbiAgICAgIC8vIGZpbmFsaXplXG4gICAgICB0aGlzLnhmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBzdGVwXG4gICAgdGhpcy54Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShsdCwgbi52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTGF6eVRyYW5zZm9ybWVyKHhmb3JtLCBjb2xsKSB7XG4gIHRoaXMuaXRlciA9IGl0ZXJhdG9yKGNvbGwpO1xuICB0aGlzLml0ZW1zID0gW107XG4gIHRoaXMuc3RlcHBlciA9IG5ldyBTdGVwcGVyKHhmb3JtLCBpdGVyYXRvcihjb2xsKSk7XG59XG5cbkxhenlUcmFuc2Zvcm1lci5wcm90b3R5cGVbcHJvdG9jb2xzLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuTGF6eVRyYW5zZm9ybWVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXNbJ0BAdHJhbnNkdWNlci9zdGVwJ10oKTtcblxuICBpZih0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdGhpcy5pdGVtcy5wb3AoKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgfVxufTtcblxuTGF6eVRyYW5zZm9ybWVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICB0aGlzLnN0ZXBwZXJbJ0BAdHJhbnNkdWNlci9zdGVwJ10odGhpcyk7XG4gIH1cbn1cblxuLy8gdXRpbFxuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG4gIGZvcih2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IGk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZHVjZTogcmVkdWNlLFxuICB0cmFuc2Zvcm1lcjogdHJhbnNmb3JtZXIsXG4gIFJlZHVjZWQ6IFJlZHVjZWQsXG4gIGlzUmVkdWNlZDogaXNSZWR1Y2VkLFxuICBpdGVyYXRvcjogaXRlcmF0b3IsXG4gIHB1c2g6IHB1c2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgdHJhbnNkdWNlOiB0cmFuc2R1Y2UsXG4gIHNlcTogc2VxLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICB0b09iajogdG9PYmosXG4gIHRvSXRlcjogdG9JdGVyLFxuICBpbnRvOiBpbnRvLFxuICBjb21wb3NlOiBjb21wb3NlLFxuICBtYXA6IG1hcCxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIHJlbW92ZTogcmVtb3ZlLFxuICBjYXQ6IGNhdCxcbiAgbWFwY2F0OiBtYXBjYXQsXG4gIGtlZXA6IGtlZXAsXG4gIGRlZHVwZTogZGVkdXBlLFxuICB0YWtlOiB0YWtlLFxuICB0YWtlV2hpbGU6IHRha2VXaGlsZSxcbiAgdGFrZU50aDogdGFrZU50aCxcbiAgZHJvcDogZHJvcCxcbiAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICBwYXJ0aXRpb25CeTogcGFydGl0aW9uQnksXG4gIGludGVycG9zZTogaW50ZXJwb3NlLFxuICByZXBlYXQ6IHJlcGVhdCxcbiAgcmFuZ2U6IHJhbmdlLFxuXG4gIExhenlUcmFuc2Zvcm1lcjogTGF6eVRyYW5zZm9ybWVyXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZm4gPSBkZWZuO1xuZXhwb3J0cy5kZWZvYmogPSBkZWZvYmo7XG5leHBvcnRzLmRlZm9uY2UgPSBkZWZvbmNlO1xuZXhwb3J0cy5tYXJrUmVsb2FkYWJsZSA9IG1hcmtSZWxvYWRhYmxlO1xudmFyIHJhbmdlID0gcmVxdWlyZSgnYXJyYXktcmFuZ2UnKTtcbnZhciB6aXBPYmplY3QgPSByZXF1aXJlKCd6aXAtb2JqZWN0Jyk7XG52YXIgbW9kdWxlVXNlZFVkS2V5cyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtYXJrUmVsb2FkYWJsZShtb2R1bGUpIHtcbiAgaWYgKG1vZHVsZS5ob3QpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZvbmNlKG1vZHVsZSwgZm4pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gIG1hcmtSZWxvYWRhYmxlKG1vZHVsZSk7XG4gIHZhciB1c2VkS2V5cyA9IG1vZHVsZVVzZWRVZEtleXMuZ2V0KG1vZHVsZSk7XG4gIGlmICghdXNlZEtleXMpIHtcbiAgICB1c2VkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBtb2R1bGVVc2VkVWRLZXlzLnNldChtb2R1bGUsIHVzZWRLZXlzKTtcbiAgfVxuICBpZiAodXNlZEtleXMuaGFzKGtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VkIGZ1bmN0aW9ucyBjYW4gb25seSBiZSB1c2VkIG9uY2UgcGVyIG1vZHVsZSB3aXRoIGEgZ2l2ZW4ga2V5Jyk7XG4gIH1cbiAgdXNlZEtleXMuYWRkKGtleSk7XG4gIHZhciB2YWx1ZVdhc1NldCA9IGZhbHNlO1xuICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIGlmIChtb2R1bGUuaG90KSB7XG4gICAgaWYgKG1vZHVsZS5ob3QuZGF0YSAmJiBtb2R1bGUuaG90LmRhdGEuX191ZF9fICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2R1bGUuaG90LmRhdGEuX191ZF9fLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG1vZHVsZS5ob3QuZGF0YS5fX3VkX19ba2V5XTtcbiAgICAgIHZhbHVlV2FzU2V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEuX191ZF9fKSBkYXRhLl9fdWRfXyA9IHt9O1xuICAgICAgZGF0YS5fX3VkX19ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGlmICghdmFsdWVXYXNTZXQpIHZhbHVlID0gZm4oKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVmb2JqKG1vZHVsZSwgb2JqZWN0KSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICB2YXIgc2hhcmVkT2JqZWN0ID0gZGVmb25jZShtb2R1bGUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LCAnLS1kZWZvYmotJyArIGtleSk7XG4gIGlmIChzaGFyZWRPYmplY3QgIT09IG9iamVjdCkge1xuICAgIGNsb25lT250b1RhcmdldChzaGFyZWRPYmplY3QsIG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHNoYXJlZE9iamVjdDtcbn1cblxuLy8gQXNzaWducyBhbGwgcHJvcGVydGllcyBvZiBvYmplY3Qgb250byB0YXJnZXQsIGFuZCBkZWxldGVzIGFueSBwcm9wZXJ0aWVzXG4vLyBmcm9tIHRhcmdldCB0aGF0IGRvbid0IGV4aXN0IG9uIG9iamVjdC4gVGhlIG9wdGlvbmFsIGJsYWNrbGlzdCBhcmd1bWVudFxuLy8gc3BlY2lmaWVzIHByb3BlcnRpZXMgdG8gbm90IGFzc2lnbiBvbiB0YXJnZXQuXG5mdW5jdGlvbiBjbG9uZU9udG9UYXJnZXQodGFyZ2V0LCBvYmplY3QpIHtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIHRhcmdldFtuYW1lXTtcbiAgfSk7XG4gIHZhciBuZXdQcm9wc0NoYWluID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB6aXBPYmplY3QobmV3UHJvcHNDaGFpbiwgbmV3UHJvcHNDaGFpbi5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIG5hbWUpO1xuICB9KS5maWx0ZXIoQm9vbGVhbikubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIGVudW1lcmFibGUgPSBfcmVmLmVudW1lcmFibGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH07XG4gIH0pKSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBkZWZuKG1vZHVsZSwgZm4pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gIHZhciBzaGFyZWQgPSBkZWZvbmNlKG1vZHVsZSwgZnVuY3Rpb24gKCkge1xuICAgIGlmICghbW9kdWxlLmhvdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm46IG51bGwsXG4gICAgICAgIHdyYXBwZXI6IGZuXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgc2hhcmVkID0ge1xuICAgICAgZm46IG51bGwsXG4gICAgICB3cmFwcGVyOiBudWxsXG4gICAgfTtcbiAgICB2YXIgcGFyYW1zTGlzdCA9IHJhbmdlKGZuLmxlbmd0aCkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gJ2EnICsgeDtcbiAgICB9KS5qb2luKCcsJyk7XG4gICAgc2hhcmVkLndyYXBwZXIgPSBuZXcgRnVuY3Rpb24oJ3NoYXJlZCcsIFwiXFxuICAgICAgJ3VzZSBzdHJpY3QnO1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBcIi5jb25jYXQoZm4ubmFtZSwgXCJfX3VkX3dyYXBwZXIoXCIpLmNvbmNhdChwYXJhbXNMaXN0LCBcIikge1xcbiAgICAgICAgaWYgKG5ldy50YXJnZXQpIHtcXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KHNoYXJlZC5mbiwgYXJndW1lbnRzLCBuZXcudGFyZ2V0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBzaGFyZWQuZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFwiKSkoc2hhcmVkKTtcbiAgICBpZiAoZm4ucHJvdG90eXBlKSB7XG4gICAgICBzaGFyZWQud3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZuLnByb3RvdHlwZSk7XG4gICAgICBzaGFyZWQud3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzaGFyZWQud3JhcHBlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcmVkLndyYXBwZXIucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xuICB9LCAnLS1kZWZuLXNoYXJlZC0nICsga2V5KTtcbiAgc2hhcmVkLmZuID0gZm47XG4gIGlmIChtb2R1bGUuaG90KSB7XG4gICAgaWYgKGZuLnByb3RvdHlwZSAmJiBzaGFyZWQud3JhcHBlci5wcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNoYXJlZC53cmFwcGVyLnByb3RvdHlwZSkgIT09IGZuLnByb3RvdHlwZSkge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHNoYXJlZC53cmFwcGVyLnByb3RvdHlwZSwgZm4ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHNoYXJlZC53cmFwcGVyLCBmbik7XG4gIH1cbiAgcmV0dXJuIHNoYXJlZC53cmFwcGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p1WVcxbGN5STZXeUp5WVc1blpTSXNJbkpsY1hWcGNtVWlMQ0o2YVhCUFltcGxZM1FpTENKdGIyUjFiR1ZWYzJWa1ZXUkxaWGx6SWl3aVYyVmhhMDFoY0NJc0ltMWhjbXRTWld4dllXUmhZbXhsSWl3aWJXOWtkV3hsSWl3aWFHOTBJaXdpWVdOalpYQjBJaXdpWkdWbWIyNWpaU0lzSW1adUlpd2lhMlY1SWl3aWRYTmxaRXRsZVhNaUxDSm5aWFFpTENKVFpYUWlMQ0p6WlhRaUxDSm9ZWE1pTENKRmNuSnZjaUlzSW1Ga1pDSXNJblpoYkhWbFYyRnpVMlYwSWl3aWRtRnNkV1VpTENKMWJtUmxabWx1WldRaUxDSmtZWFJoSWl3aVgxOTFaRjlmSWl3aVQySnFaV04wSWl3aWNISnZkRzkwZVhCbElpd2lhR0Z6VDNkdVVISnZjR1Z5ZEhraUxDSmpZV3hzSWl3aVpHbHpjRzl6WlNJc0ltUmxabTlpYWlJc0ltOWlhbVZqZENJc0luTm9ZWEpsWkU5aWFtVmpkQ0lzSW1Oc2IyNWxUMjUwYjFSaGNtZGxkQ0lzSW5SaGNtZGxkQ0lzSW1kbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhNaUxDSm1hV3gwWlhJaUxDSnVZVzFsSWl3aVptOXlSV0ZqYUNJc0ltNWxkMUJ5YjNCelEyaGhhVzRpTENKa1pXWnBibVZRY205d1pYSjBhV1Z6SWl3aWJXRndJaXdpWjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXlJaXdpUW05dmJHVmhiaUlzSW1WdWRXMWxjbUZpYkdVaUxDSjNjbWwwWVdKc1pTSXNJbU52Ym1acFozVnlZV0pzWlNJc0ltUmxabTRpTENKemFHRnlaV1FpTENKM2NtRndjR1Z5SWl3aWNHRnlZVzF6VEdsemRDSXNJbXhsYm1kMGFDSXNJbmdpTENKcWIybHVJaXdpUm5WdVkzUnBiMjRpTENKamNtVmhkR1VpTENKamIyNXpkSEoxWTNSdmNpSXNJbWRsZEZCeWIzUnZkSGx3WlU5bUlpd2ljMlYwVUhKdmRHOTBlWEJsVDJZaVhTd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZhVzVrWlhndWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHlvZ1FHWnNiM2NnS2k5Y2JseHVZMjl1YzNRZ2NtRnVaMlVnUFNCeVpYRjFhWEpsS0NkaGNuSmhlUzF5WVc1blpTY3BPMXh1WTI5dWMzUWdlbWx3VDJKcVpXTjBJRDBnY21WeGRXbHlaU2duZW1sd0xXOWlhbVZqZENjcE8xeHVZMjl1YzNRZ2JXOWtkV3hsVlhObFpGVmtTMlY1Y3pvZ1YyVmhhMDFoY0R4MGVYQmxiMllnYlc5a2RXeGxMQ0JUWlhROGMzUnlhVzVuUGo0Z1BTQnVaWGNnVjJWaGEwMWhjQ2dwTzF4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2JXRnlhMUpsYkc5aFpHRmliR1VvYlc5a2RXeGxPaUIwZVhCbGIyWWdiVzlrZFd4bEtTQjdYRzRnSUdsbUlDZ29iVzlrZFd4bE9tRnVlU2t1YUc5MEtTQjdYRzRnSUNBZ0tHMXZaSFZzWlRwaGJua3BMbWh2ZEM1aFkyTmxjSFFvS1R0Y2JpQWdmVnh1ZlZ4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1pHVm1iMjVqWlR4VVBpaHRiMlIxYkdVNklIUjVjR1Z2WmlCdGIyUjFiR1VzSUdadU9pQW9LVDArVkN3Z2EyVjVQenB6ZEhKcGJtYzlKeWNwT2lCVUlIdGNiaUFnYldGeWExSmxiRzloWkdGaWJHVW9iVzlrZFd4bEtUdGNiaUFnYkdWMElIVnpaV1JMWlhseklEMGdiVzlrZFd4bFZYTmxaRlZrUzJWNWN5NW5aWFFvYlc5a2RXeGxLVHRjYmlBZ2FXWWdLQ0YxYzJWa1MyVjVjeWtnZTF4dUlDQWdJSFZ6WldSTFpYbHpJRDBnYm1WM0lGTmxkQ2dwTzF4dUlDQWdJRzF2WkhWc1pWVnpaV1JWWkV0bGVYTXVjMlYwS0cxdlpIVnNaU3dnZFhObFpFdGxlWE1wTzF4dUlDQjlYRzRnSUdsbUlDaDFjMlZrUzJWNWN5NW9ZWE1vYTJWNUtTa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnbmRXUWdablZ1WTNScGIyNXpJR05oYmlCdmJteDVJR0psSUhWelpXUWdiMjVqWlNCd1pYSWdiVzlrZFd4bElIZHBkR2dnWVNCbmFYWmxiaUJyWlhrbktUdGNiaUFnZlZ4dUlDQjFjMlZrUzJWNWN5NWhaR1FvYTJWNUtUdGNiaUFnYkdWMElIWmhiSFZsVjJGelUyVjBJRDBnWm1Gc2MyVTdYRzRnSUd4bGRDQjJZV3gxWlRvZ1lXNTVJRDBnZFc1a1pXWnBibVZrTzF4dUlDQnBaaUFvS0cxdlpIVnNaVHBoYm5rcExtaHZkQ2tnZTF4dUlDQWdJR2xtSUNoY2JpQWdJQ0FnSUNodGIyUjFiR1U2WVc1NUtTNW9iM1F1WkdGMFlTQW1KbHh1SUNBZ0lDQWdLRzF2WkhWc1pUcGhibmtwTG1odmRDNWtZWFJoTGw5ZmRXUmZYeUFtSmx4dUlDQWdJQ0FnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzVvWVhOUGQyNVFjbTl3WlhKMGVTNWpZV3hzS0NodGIyUjFiR1U2WVc1NUtTNW9iM1F1WkdGMFlTNWZYM1ZrWDE4c0lHdGxlU2xjYmlBZ0lDQXBJSHRjYmlBZ0lDQWdJSFpoYkhWbElEMGdLRzF2WkhWc1pUcGhibmtwTG1odmRDNWtZWFJoTGw5ZmRXUmZYMXRyWlhsZE8xeHVJQ0FnSUNBZ2RtRnNkV1ZYWVhOVFpYUWdQU0IwY25WbE8xeHVJQ0FnSUgxY2JpQWdJQ0FvYlc5a2RXeGxPbUZ1ZVNrdWFHOTBMbVJwYzNCdmMyVW9aR0YwWVNBOVBpQjdYRzRnSUNBZ0lDQnBaaUFvSVdSaGRHRXVYMTkxWkY5ZktWeHVJQ0FnSUNBZ0lDQmtZWFJoTGw5ZmRXUmZYeUE5SUh0OU8xeHVJQ0FnSUNBZ1pHRjBZUzVmWDNWa1gxOWJhMlY1WFNBOUlIWmhiSFZsTzF4dUlDQWdJSDBwTzF4dUlDQjlYRzRnSUdsbUlDZ2hkbUZzZFdWWFlYTlRaWFFwWEc0Z0lDQWdkbUZzZFdVZ1BTQm1iaWdwTzF4dUlDQnlaWFIxY200Z2RtRnNkV1U3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmtaV1p2WW1vOFZEb2dUMkpxWldOMFBpaHRiMlIxYkdVNklIUjVjR1Z2WmlCdGIyUjFiR1VzSUc5aWFtVmpkRG9nVkN3Z2EyVjVQenB6ZEhKcGJtYzlKeWNwT2lCVUlIdGNiaUFnWTI5dWMzUWdjMmhoY21Wa1QySnFaV04wSUQwZ1pHVm1iMjVqWlNodGIyUjFiR1VzSUNncFBUNXZZbXBsWTNRc0lDY3RMV1JsWm05aWFpMG5LMnRsZVNrN1hHNGdJR2xtSUNoemFHRnlaV1JQWW1wbFkzUWdJVDA5SUc5aWFtVmpkQ2tnZTF4dUlDQWdJR05zYjI1bFQyNTBiMVJoY21kbGRDaHphR0Z5WldSUFltcGxZM1FzSUc5aWFtVmpkQ2s3WEc0Z0lIMWNiaUFnY21WMGRYSnVJSE5vWVhKbFpFOWlhbVZqZER0Y2JuMWNibHh1THk4Z1FYTnphV2R1Y3lCaGJHd2djSEp2Y0dWeWRHbGxjeUJ2WmlCdlltcGxZM1FnYjI1MGJ5QjBZWEpuWlhRc0lHRnVaQ0JrWld4bGRHVnpJR0Z1ZVNCd2NtOXdaWEowYVdWelhHNHZMeUJtY205dElIUmhjbWRsZENCMGFHRjBJR1J2YmlkMElHVjRhWE4wSUc5dUlHOWlhbVZqZEM0Z1ZHaGxJRzl3ZEdsdmJtRnNJR0pzWVdOcmJHbHpkQ0JoY21kMWJXVnVkRnh1THk4Z2MzQmxZMmxtYVdWeklIQnliM0JsY25ScFpYTWdkRzhnYm05MElHRnpjMmxuYmlCdmJpQjBZWEpuWlhRdVhHNW1kVzVqZEdsdmJpQmpiRzl1WlU5dWRHOVVZWEpuWlhROFZEb2dUMkpxWldOMFBpaDBZWEpuWlhRNklGUXNJRzlpYW1WamREb2dUMkpxWldOMEtUb2dWQ0I3WEc0Z0lFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVTVoYldWektIUmhjbWRsZENsY2JpQWdJQ0F1Wm1sc2RHVnlLRzVoYldVZ1BUNGdJVTlpYW1WamRDNXdjbTkwYjNSNWNHVXVhR0Z6VDNkdVVISnZjR1Z5ZEhrdVkyRnNiQ2h2WW1wbFkzUXNJRzVoYldVcEtWeHVJQ0FnSUM1bWIzSkZZV05vS0c1aGJXVWdQVDRnZTF4dUlDQWdJQ0FnWkdWc1pYUmxJSFJoY21kbGRGdHVZVzFsWFR0Y2JpQWdJQ0I5S1R0Y2JpQWdZMjl1YzNRZ2JtVjNVSEp2Y0hORGFHRnBiaUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0c5aWFtVmpkQ2s3WEc0Z0lFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBhV1Z6S0Z4dUlDQWdJSFJoY21kbGRDeGNiaUFnSUNCNmFYQlBZbXBsWTNRb2JtVjNVSEp2Y0hORGFHRnBiaXdnYm1WM1VISnZjSE5EYUdGcGJseHVJQ0FnSUNBZ0xtMWhjQ2h1WVcxbElEMCtJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNJb2IySnFaV04wTENCdVlXMWxLU2xjYmlBZ0lDQWdJQzVtYVd4MFpYSW9RbTl2YkdWaGJpbGNiaUFnSUNBZ0lDNXRZWEFvS0h0MllXeDFaU3hsYm5WdFpYSmhZbXhsZlNrZ1BUNWNiaUFnSUNBZ0lDQWdLSHQyWVd4MVpTeGxiblZ0WlhKaFlteGxMSGR5YVhSaFlteGxPblJ5ZFdVc1kyOXVabWxuZFhKaFlteGxPblJ5ZFdWOUtWeHVJQ0FnSUNBZ0tWeHVJQ0FnSUNsY2JpQWdLVHRjYmlBZ2NtVjBkWEp1SUhSaGNtZGxkRHRjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHUmxabTQ4VkRvZ1JuVnVZM1JwYjI0K0tHMXZaSFZzWlRvZ2RIbHdaVzltSUcxdlpIVnNaU3dnWm00NklGUXNJR3RsZVQ4NmMzUnlhVzVuUFNjbktUb2dWQ0I3WEc0Z0lHTnZibk4wSUhOb1lYSmxaQ0E5SUdSbFptOXVZMlVvYlc5a2RXeGxMQ0FvS1QwK2UxeHVJQ0FnSUdsbUlDZ2hLRzF2WkhWc1pUcGhibmtwTG1odmRDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIdG1iam9nS0c1MWJHdzZJRDlVS1N3Z2QzSmhjSEJsY2pvZ1ptNTlPMXh1SUNBZ0lIMWNiaUFnSUNCamIyNXpkQ0J6YUdGeVpXUTZJRTlpYW1WamRDQTlJSHRtYmpvZ2JuVnNiQ3dnZDNKaGNIQmxjam9nYm5Wc2JIMDdYRzRnSUNBZ1kyOXVjM1FnY0dGeVlXMXpUR2x6ZENBOUlISmhibWRsS0dadUxteGxibWQwYUNrdWJXRndLSGdnUFQ0Z0oyRW5LM2dwTG1wdmFXNG9KeXduS1R0Y2JpQWdJQ0J6YUdGeVpXUXVkM0poY0hCbGNpQTlJQ2h1WlhjZ1JuVnVZM1JwYjI0b1hHNGdJQ0FnSUNBbmMyaGhjbVZrSnl4Y2JpQWdJQ0FnSUdCY2JpQWdJQ0FnSUNkMWMyVWdjM1J5YVdOMEp6dGNiaUFnSUNBZ0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlBa2UyWnVMbTVoYldWOVgxOTFaRjkzY21Gd2NHVnlLQ1I3Y0dGeVlXMXpUR2x6ZEgwcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0c1bGR5NTBZWEpuWlhRcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdVbVZtYkdWamRDNWpiMjV6ZEhKMVkzUW9jMmhoY21Wa0xtWnVMQ0JoY21kMWJXVnVkSE1zSUc1bGR5NTBZWEpuWlhRcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnphR0Z5WldRdVptNHVZWEJ3Ykhrb2RHaHBjeXdnWVhKbmRXMWxiblJ6S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lHQmNiaUFnSUNBcE9pQmhibmtwS0hOb1lYSmxaQ2s3WEc0Z0lDQWdhV1lnS0dadUxuQnliM1J2ZEhsd1pTa2dlMXh1SUNBZ0lDQWdLSE5vWVhKbFpDNTNjbUZ3Y0dWeU9tRnVlU2t1Y0hKdmRHOTBlWEJsSUQwZ1QySnFaV04wTG1OeVpXRjBaU2htYmk1d2NtOTBiM1I1Y0dVcE8xeHVJQ0FnSUNBZ0tITm9ZWEpsWkM1M2NtRndjR1Z5T21GdWVTa3VjSEp2ZEc5MGVYQmxMbU52Ym5OMGNuVmpkRzl5SUQwZ2MyaGhjbVZrTG5keVlYQndaWEk3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDaHphR0Z5WldRdWQzSmhjSEJsY2pwaGJua3BMbkJ5YjNSdmRIbHdaU0E5SUdadUxuQnliM1J2ZEhsd1pUdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJSE5vWVhKbFpEdGNiaUFnZlN3Z0p5MHRaR1ZtYmkxemFHRnlaV1F0Snl0clpYa3BPMXh1SUNCemFHRnlaV1F1Wm00Z1BTQm1ianRjYmlBZ2FXWWdLQ2h0YjJSMWJHVTZZVzU1S1M1b2IzUXBJSHRjYmlBZ0lDQnBaaUFvWm00dWNISnZkRzkwZVhCbElDWW1JQ2h6YUdGeVpXUXVkM0poY0hCbGNqcGhibmtwTG5CeWIzUnZkSGx3WlNBbUppQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvS0hOb1lYSmxaQzUzY21Gd2NHVnlPbUZ1ZVNrdWNISnZkRzkwZVhCbEtTQWhQVDBnWm00dWNISnZkRzkwZVhCbEtTQjdYRzRnSUNBZ0lDQW9UMkpxWldOME9pQmhibmtwTG5ObGRGQnliM1J2ZEhsd1pVOW1LQ2h6YUdGeVpXUXVkM0poY0hCbGNqcGhibmtwTG5CeWIzUnZkSGx3WlN3Z1ptNHVjSEp2ZEc5MGVYQmxLVHRjYmlBZ0lDQjlYRzRnSUNBZ0tFOWlhbVZqZERvZ1lXNTVLUzV6WlhSUWNtOTBiM1I1Y0dWUFppaHphR0Z5WldRdWQzSmhjSEJsY2l3Z1ptNHBPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnphR0Z5WldRdWQzSmhjSEJsY2p0Y2JuMWNiaUpkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN08wRkJSVUVzU1VGQlRVRXNTMEZCU3l4SFFVRkhReXhQUVVGUExFTkJRVU1zWVVGQllTeERRVUZETzBGQlEzQkRMRWxCUVUxRExGTkJRVk1zUjBGQlIwUXNUMEZCVHl4RFFVRkRMRmxCUVZrc1EwRkJRenRCUVVOMlF5eEpRVUZOUlN4blFrRkJjVVFzUjBGQlJ5eEpRVUZKUXl4UFFVRlBMRVZCUVVVN1FVRkZjRVVzVTBGQlUwTXNZMEZCWXl4RFFVRkRReXhOUVVGeFFpeEZRVUZGTzBWQlEzQkVMRWxCUVV0QkxFMUJRVTBzUTBGQlRVTXNSMEZCUnl4RlFVRkZPMGxCUTI1Q1JDeE5RVUZOTEVOQlFVMURMRWRCUVVjc1EwRkJRME1zVFVGQlRTeEZRVUZGTzBWQlF6TkNPMEZCUTBZN1FVRkZUeXhUUVVGVFF5eFBRVUZQTEVOQlFVbElMRTFCUVhGQ0xFVkJRVVZKTEVWQlFWTXNSVUZCY1VJN1JVRkJRU3hKUVVGdVFrTXNSMEZCVnl4MVJVRkJReXhGUVVGRk8wVkJRM3BGVGl4alFVRmpMRU5CUVVORExFMUJRVTBzUTBGQlF6dEZRVU4wUWl4SlFVRkpUU3hSUVVGUkxFZEJRVWRVTEdkQ1FVRm5RaXhEUVVGRFZTeEhRVUZITEVOQlFVTlFMRTFCUVUwc1EwRkJRenRGUVVNelF5eEpRVUZKTEVOQlFVTk5MRkZCUVZFc1JVRkJSVHRKUVVOaVFTeFJRVUZSTEVkQlFVY3NTVUZCU1VVc1IwRkJSeXhGUVVGRk8wbEJRM0JDV0N4blFrRkJaMElzUTBGQlExa3NSMEZCUnl4RFFVRkRWQ3hOUVVGTkxFVkJRVVZOTEZGQlFWRXNRMEZCUXp0RlFVTjRRenRGUVVOQkxFbEJRVWxCTEZGQlFWRXNRMEZCUTBrc1IwRkJSeXhEUVVGRFRDeEhRVUZITEVOQlFVTXNSVUZCUlR0SlFVTnlRaXhOUVVGTkxFbEJRVWxOTEV0QlFVc3NRMEZCUXl4blJVRkJaMFVzUTBGQlF6dEZRVU51Ump0RlFVTkJUQ3hSUVVGUkxFTkJRVU5OTEVkQlFVY3NRMEZCUTFBc1IwRkJSeXhEUVVGRE8wVkJRMnBDTEVsQlFVbFJMRmRCUVZjc1IwRkJSeXhMUVVGTE8wVkJRM1pDTEVsQlFVbERMRXRCUVZVc1IwRkJSME1zVTBGQlV6dEZRVU14UWl4SlFVRkxaaXhOUVVGTkxFTkJRVTFETEVkQlFVY3NSVUZCUlR0SlFVTndRaXhKUVVOSFJDeE5RVUZOTEVOQlFVMURMRWRCUVVjc1EwRkJRMlVzU1VGQlNTeEpRVU53UW1oQ0xFMUJRVTBzUTBGQlRVTXNSMEZCUnl4RFFVRkRaU3hKUVVGSkxFTkJRVU5ETEUxQlFVMHNTVUZETlVKRExFMUJRVTBzUTBGQlEwTXNVMEZCVXl4RFFVRkRReXhqUVVGakxFTkJRVU5ETEVsQlFVa3NRMEZCUlhKQ0xFMUJRVTBzUTBGQlRVTXNSMEZCUnl4RFFVRkRaU3hKUVVGSkxFTkJRVU5ETEUxQlFVMHNSVUZCUlZvc1IwRkJSeXhEUVVGRExFVkJRM1pGTzAxQlEwRlRMRXRCUVVzc1IwRkJTV1FzVFVGQlRTeERRVUZOUXl4SFFVRkhMRU5CUVVObExFbEJRVWtzUTBGQlEwTXNUVUZCVFN4RFFVRkRXaXhIUVVGSExFTkJRVU03VFVGRGVrTlJMRmRCUVZjc1IwRkJSeXhKUVVGSk8wbEJRM0JDTzBsQlEwTmlMRTFCUVUwc1EwRkJUVU1zUjBGQlJ5eERRVUZEY1VJc1QwRkJUeXhEUVVGRExGVkJRVUZPTEVsQlFVa3NSVUZCU1R0TlFVTXZRaXhKUVVGSkxFTkJRVU5CTEVsQlFVa3NRMEZCUTBNc1RVRkJUU3hGUVVOa1JDeEpRVUZKTEVOQlFVTkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03VFVGRGJFSkVMRWxCUVVrc1EwRkJRME1zVFVGQlRTeERRVUZEV2l4SFFVRkhMRU5CUVVNc1IwRkJSMU1zUzBGQlN6dEpRVU14UWl4RFFVRkRMRU5CUVVNN1JVRkRTanRGUVVOQkxFbEJRVWtzUTBGQlEwUXNWMEZCVnl4RlFVTmtReXhMUVVGTExFZEJRVWRXTEVWQlFVVXNSVUZCUlR0RlFVTmtMRTlCUVU5VkxFdEJRVXM3UVVGRFpEdEJRVVZQTEZOQlFWTlRMRTFCUVUwc1EwRkJXWFpDTEUxQlFYRkNMRVZCUVVWM1FpeE5RVUZUTEVWQlFYRkNPMFZCUVVFc1NVRkJia0p1UWl4SFFVRlhMSFZGUVVGRExFVkJRVVU3UlVGRGFFWXNTVUZCVFc5Q0xGbEJRVmtzUjBGQlIzUkNMRTlCUVU4c1EwRkJRMGdzVFVGQlRTeEZRVUZGTzBsQlFVRXNUMEZCU1hkQ0xFMUJRVTA3UlVGQlFTeEhRVUZGTEZkQlFWY3NSMEZCUTI1Q0xFZEJRVWNzUTBGQlF6dEZRVU5xUlN4SlFVRkpiMElzV1VGQldTeExRVUZMUkN4TlFVRk5MRVZCUVVVN1NVRkRNMEpGTEdWQlFXVXNRMEZCUTBRc1dVRkJXU3hGUVVGRlJDeE5RVUZOTEVOQlFVTTdSVUZEZGtNN1JVRkRRU3hQUVVGUFF5eFpRVUZaTzBGQlEzSkNPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTkRMR1ZCUVdVc1EwRkJXVU1zVFVGQlV5eEZRVUZGU0N4TlFVRmpMRVZCUVVzN1JVRkRhRVZPTEUxQlFVMHNRMEZCUTFVc2JVSkJRVzFDTEVOQlFVTkVMRTFCUVUwc1EwRkJReXhEUVVNdlFrVXNUVUZCVFN4RFFVRkRMRlZCUVVGRExFbEJRVWs3U1VGQlFTeFBRVUZKTEVOQlFVTmFMRTFCUVUwc1EwRkJRME1zVTBGQlV5eERRVUZEUXl4alFVRmpMRU5CUVVORExFbEJRVWtzUTBGQlEwY3NUVUZCVFN4RlFVRkZUU3hKUVVGSkxFTkJRVU03UlVGQlFTeEZRVUZETEVOQlEyNUZReXhQUVVGUExFTkJRVU1zVlVGQlFVUXNTVUZCU1N4RlFVRkpPMGxCUTJZc1QwRkJUMGdzVFVGQlRTeERRVUZEUnl4SlFVRkpMRU5CUVVNN1JVRkRja0lzUTBGQlF5eERRVUZETzBWQlEwb3NTVUZCVFVVc1lVRkJZU3hIUVVGSFpDeE5RVUZOTEVOQlFVTlZMRzFDUVVGdFFpeERRVUZEU2l4TlFVRk5MRU5CUVVNN1JVRkRlRVJPTEUxQlFVMHNRMEZCUTJVc1owSkJRV2RDTEVOQlEzSkNUaXhOUVVGTkxFVkJRMDR2UWl4VFFVRlRMRU5CUVVOdlF5eGhRVUZoTEVWQlFVVkJMR0ZCUVdFc1EwRkRia05GTEVkQlFVY3NRMEZCUXl4VlFVRkJTaXhKUVVGSk8wbEJRVUVzVDBGQlNWb3NUVUZCVFN4RFFVRkRhVUlzZDBKQlFYZENMRU5CUVVOWUxFMUJRVTBzUlVGQlJVMHNTVUZCU1N4RFFVRkRPMFZCUVVFc1JVRkJReXhEUVVNeFJFUXNUVUZCVFN4RFFVRkRUeXhQUVVGUExFTkJRVU1zUTBGRFprWXNSMEZCUnl4RFFVRkRPMGxCUVVFc1NVRkJSWEJDTEV0QlFVc3NVVUZCVEVFc1MwRkJTenROUVVGRGRVSXNWVUZCVlN4UlFVRldRU3hWUVVGVk8wbEJRVUVzVDBGRGNFSTdUVUZCUTNaQ0xFdEJRVXNzUlVGQlRFRXNTMEZCU3p0TlFVRkRkVUlzVlVGQlZTeEZRVUZXUVN4VlFVRlZPMDFCUVVORExGRkJRVkVzUlVGQlF5eEpRVUZKTzAxQlFVTkRMRmxCUVZrc1JVRkJRenRKUVVGSkxFTkJRVU03UlVGQlFTeERRVUZETEVOQlEzSkVMRU5CUTBZc1EwRkRSanRGUVVORUxFOUJRVTlhTEUxQlFVMDdRVUZEWmp0QlFVVlBMRk5CUVZOaExFbEJRVWtzUTBGQlkzaERMRTFCUVhGQ0xFVkJRVVZKTEVWQlFVc3NSVUZCY1VJN1JVRkJRU3hKUVVGdVFrTXNSMEZCVnl4MVJVRkJReXhGUVVGRk8wVkJRelZGTEVsQlFVMXZReXhOUVVGTkxFZEJRVWQwUXl4UFFVRlBMRU5CUVVOSUxFMUJRVTBzUlVGQlJTeFpRVUZKTzBsQlEycERMRWxCUVVrc1EwRkJSVUVzVFVGQlRTeERRVUZOUXl4SFFVRkhMRVZCUVVVN1RVRkRja0lzVDBGQlR6dFJRVUZEUnl4RlFVRkZMRVZCUVVjc1NVRkJVenRSUVVGRmMwTXNUMEZCVHl4RlFVRkZkRU03VFVGQlJTeERRVUZETzBsQlEzUkRPMGxCUTBFc1NVRkJUWEZETEUxQlFXTXNSMEZCUnp0TlFVRkRja01zUlVGQlJTeEZRVUZGTEVsQlFVazdUVUZCUlhORExFOUJRVThzUlVGQlJUdEpRVUZKTEVOQlFVTTdTVUZEYUVRc1NVRkJUVU1zVlVGQlZTeEhRVUZIYWtRc1MwRkJTeXhEUVVGRFZTeEZRVUZGTEVOQlFVTjNReXhOUVVGTkxFTkJRVU1zUTBGQlExWXNSMEZCUnl4RFFVRkRMRlZCUVVGWExFTkJRVU03VFVGQlFTeFBRVUZKTEVkQlFVY3NSMEZCUTBFc1EwRkJRenRKUVVGQkxFVkJRVU1zUTBGQlEwTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJRenRKUVVNM1JFd3NUVUZCVFN4RFFVRkRReXhQUVVGUExFZEJRVWtzU1VGQlNVc3NVVUZCVVN4RFFVTTFRaXhSUVVGUkxIbEVRVWRWTTBNc1JVRkJSU3hEUVVGRE1FSXNTVUZCU1N3d1FrRkJaMEpoTEZWQlFWVXNPRTFCVVhCRUxFTkJRVTlHTEUxQlFVMHNRMEZCUXp0SlFVTm1MRWxCUVVseVF5eEZRVUZGTEVOQlFVTmxMRk5CUVZNc1JVRkJSVHROUVVObWMwSXNUVUZCVFN4RFFVRkRReXhQUVVGUExFTkJRVTEyUWl4VFFVRlRMRWRCUVVkRUxFMUJRVTBzUTBGQlF6aENMRTFCUVUwc1EwRkJRelZETEVWQlFVVXNRMEZCUTJVc1UwRkJVeXhEUVVGRE8wMUJRek5FYzBJc1RVRkJUU3hEUVVGRFF5eFBRVUZQTEVOQlFVMTJRaXhUUVVGVExFTkJRVU00UWl4WFFVRlhMRWRCUVVkU0xFMUJRVTBzUTBGQlEwTXNUMEZCVHp0SlFVTTNSQ3hEUVVGRExFMUJRVTA3VFVGRFNrUXNUVUZCVFN4RFFVRkRReXhQUVVGUExFTkJRVTEyUWl4VFFVRlRMRWRCUVVkbUxFVkJRVVVzUTBGQlEyVXNVMEZCVXp0SlFVTXZRenRKUVVOQkxFOUJRVTl6UWl4TlFVRk5PMFZCUTJZc1EwRkJReXhGUVVGRkxHZENRVUZuUWl4SFFVRkRjRU1zUjBGQlJ5eERRVUZETzBWQlEzaENiME1zVFVGQlRTeERRVUZEY2tNc1JVRkJSU3hIUVVGSFFTeEZRVUZGTzBWQlEyUXNTVUZCUzBvc1RVRkJUU3hEUVVGTlF5eEhRVUZITEVWQlFVVTdTVUZEY0VJc1NVRkJTVWNzUlVGQlJTeERRVUZEWlN4VFFVRlRMRWxCUVV0elFpeE5RVUZOTEVOQlFVTkRMRTlCUVU4c1EwRkJUWFpDTEZOQlFWTXNTVUZCU1VRc1RVRkJUU3hEUVVGRFowTXNZMEZCWXl4RFFVRkZWQ3hOUVVGTkxFTkJRVU5ETEU5QlFVOHNRMEZCVFhaQ0xGTkJRVk1zUTBGQlF5eExRVUZMWml4RlFVRkZMRU5CUVVObExGTkJRVk1zUlVGQlJUdE5RVU16U0VRc1RVRkJUU3hEUVVGUGFVTXNZMEZCWXl4RFFVRkZWaXhOUVVGTkxFTkJRVU5ETEU5QlFVOHNRMEZCVFhaQ0xGTkJRVk1zUlVGQlJXWXNSVUZCUlN4RFFVRkRaU3hUUVVGVExFTkJRVU03U1VGRE5VVTdTVUZEUTBRc1RVRkJUU3hEUVVGUGFVTXNZMEZCWXl4RFFVRkRWaXhOUVVGTkxFTkJRVU5ETEU5QlFVOHNSVUZCUlhSRExFVkJRVVVzUTBGQlF6dEZRVU5zUkR0RlFVTkJMRTlCUVU5eFF5eE5RVUZOTEVOQlFVTkRMRTlCUVU4N1FVRkRka0lpZlE9PSIsInZhciB6aXBPYmplY3QgPSBmdW5jdGlvbiAoa2V5cywgdmFsdWVzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICB2YWx1ZXMgPSBrZXlzWzFdO1xuICAgIGtleXMgPSBrZXlzWzBdO1xuICB9XG4gICAgXG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGkgPSAwO1xuICBcbiAgZm9yIChpOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHJlc3VsdFtrZXlzW2ldXSA9IHZhbHVlc1tpXTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gemlwT2JqZWN0OyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZEQgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0Jyk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kTyA9IHt9OyIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmhtZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlID0gT2JqZWN0LmNyZWF0ZShtb2R1bGUpO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0c2V0OiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VTIE1vZHVsZXMgbWF5IG5vdCBhc3NpZ24gbW9kdWxlLmV4cG9ydHMgb3IgZXhwb3J0cy4qLCBVc2UgRVNNIGV4cG9ydCBzeW50YXgsIGluc3RlYWQ6ICcgKyBtb2R1bGUuaWQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlcyAqL1xuZGVjbGFyZSBsZXQgZGVmaW5lOiBhbnk7XG5cbmlmICghKGdsb2JhbCBhcyBhbnkpLl9fSW5ib3hTREtJbmplY3RlZCkge1xuICAoZ2xvYmFsIGFzIGFueSkuX19JbmJveFNES0luamVjdGVkID0gdHJ1ZTtcblxuICBjb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL2luamVjdGVkLWxvZ2dlcicpO1xuXG4gIGxldCBvbGREZWZpbmU7XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIC8vIHdvcmsgYXJvdW5kIGFtZCBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL2luYm94c2RrL1VfYnE4MkV4bXdjL0kzaUlpbnh4Q0FBSlxuICAgICAgb2xkRGVmaW5lID0gZGVmaW5lO1xuICAgICAgZGVmaW5lID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBleHRDb3JiV29ya2Fyb3VuZFBhZ2VXb3JsZCA9IHJlcXVpcmUoJ2V4dC1jb3JiLXdvcmthcm91bmQvZGlzdC9zcmMvcGFnZVdvcmxkJyk7XG5cbiAgICBjb25zdCB4aHJIZWxwZXIgPSByZXF1aXJlKCcuL3hoci1oZWxwZXInKS5kZWZhdWx0O1xuXG4gICAgY29uc3Qgc2V0dXBEYXRhRXhwb3NlciA9IHJlcXVpcmUoJy4vc2V0dXAtZGF0YS1leHBvc2VyJykuZGVmYXVsdDtcblxuICAgIGNvbnN0IHNldHVwRXZlbnRSZWVtaXR0ZXIgPSByZXF1aXJlKCcuL3NldHVwLWV2ZW50LXJlZW1pdHRlcicpLmRlZmF1bHQ7XG5cbiAgICBjb25zdCBzZXR1cEVycm9yU2lsZW5jZXIgPSByZXF1aXJlKCcuL3NldHVwLWVycm9yLXNpbGVuY2VyJykuZGVmYXVsdDtcblxuICAgIGNvbnN0IHNldHVwQ3VzdG9tVmlld0V2ZW50QXNzYXNzaW4gPVxuICAgICAgcmVxdWlyZSgnLi9zZXR1cEN1c3RvbVZpZXdFdmVudEFzc2Fzc2luJykuZGVmYXVsdDtcblxuICAgIGNvbnN0IHNldHVwUHVzaFN0YXRlTGlzdGVuZXIgPSByZXF1aXJlKCcuL3NldHVwUHVzaFN0YXRlTGlzdGVuZXInKS5kZWZhdWx0O1xuXG4gICAgY29uc3Qgc2V0dXBJbmJveEN1c3RvbVZpZXdMaW5rRml4ZXIgPVxuICAgICAgcmVxdWlyZSgnLi9zZXR1cEluYm94Q3VzdG9tVmlld0xpbmtGaXhlcicpLmRlZmF1bHQ7XG5cbiAgICBjb25zdCBnbWFpbEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9nbWFpbC9zZXR1cC1nbWFpbC1pbnRlcmNlcHRvcicpLmRlZmF1bHQ7XG5cbiAgICBjb25zdCBzZXR1cEdtb25rZXlIYW5kbGVyID1cbiAgICAgIHJlcXVpcmUoJy4vZ21haWwvc2V0dXAtZ21vbmtleS1oYW5kbGVyJykuZGVmYXVsdDtcblxuICAgIGNvbnN0IHBhZ2VPcmlnaW46IHN0cmluZyA9XG4gICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyAmJiBnbG9iYWwuX190ZXN0X29yaWdpbikgfHxcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbjtcblxuICAgIGlmIChwYWdlT3JpZ2luID09PSAnaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20nKSB7XG4gICAgICBnbWFpbEludGVyY2VwdG9yKCk7XG4gICAgICBzZXR1cEdtb25rZXlIYW5kbGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBoYXBwZW4nKTtcbiAgICB9XG5cbiAgICBleHRDb3JiV29ya2Fyb3VuZFBhZ2VXb3JsZC5pbml0KCk7XG4gICAgeGhySGVscGVyKCk7XG4gICAgc2V0dXBEYXRhRXhwb3NlcigpO1xuICAgIHNldHVwRXZlbnRSZWVtaXR0ZXIoKTtcbiAgICBzZXR1cEVycm9yU2lsZW5jZXIoKTtcbiAgICBzZXR1cEN1c3RvbVZpZXdFdmVudEFzc2Fzc2luKCk7XG4gICAgc2V0dXBQdXNoU3RhdGVMaXN0ZW5lcigpO1xuICAgIHNldHVwSW5ib3hDdXN0b21WaWV3TGlua0ZpeGVyKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvbGREZWZpbmUpIHtcbiAgICAgIGRlZmluZSA9IG9sZERlZmluZTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyIiwibm9uY2UiLCJEYXRlIiwibm93IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicG93IiwiY2FjaGVidXN0VXJsIiwidXJsIiwidGVzdCIsInJlcGxhY2UiLCJxdWVyeXN0cmluZyIsImRlbGF5IiwiTUFYX1RJTUVPVVQiLCJNQVhfUkVUUklFUyIsInNlcnZlcnNUb0lnbm9yZSIsImFqYXgiLCJvcHRzIiwiRXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm1ldGhvZCIsInN0cmluZ0RhdGEiLCJkYXRhIiwic3RyaW5naWZ5IiwiY2FuUmV0cnkiLCJtYXRjaCIsInNlcnZlciIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNhY2hlYnVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwid2luZG93IiwieGhyIiwiYXNzaWduIiwieGhyRmllbGRzIiwib25lcnJvciIsImV2ZW50IiwicmV0cnlOdW0iLCJzdGF0dXMiLCJfcmV0cnkiLCJlcnIiLCJvbmxvYWQiLCJ0ZXh0IiwicmVzcG9uc2VUZXh0Iiwib3BlbiIsImhlYWRlcnMiLCJrZXlzIiwiZm9yRWFjaCIsIm5hbWUiLCJ2YWx1ZSIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwicmV0cnlUaW1lb3V0IiwibWluIiwidGhlbiIsIkFzc2VydGlvbkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiaHRtbFRvVGV4dCIsImh0bWwiLCJkaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsImVzY2FwZSIsImF1dG9IdG1sIiwiZGVmbiIsIkdSUCIsIm1vZGlmeVN1Z2dlc3Rpb25zIiwibW9kaWZpY2F0aW9ucyIsInBhcnNlZCIsIm9wdGlvbnMiLCJkZXNlcmlhbGl6ZSIsInF1ZXJ5IiwibW9kaWZpY2F0aW9uIiwibmFtZUhUTUwiLCJkZXNjcmlwdGlvbiIsImRlc2NyaXB0aW9uSFRNTCIsImlkIiwicm91dGVOYW1lIiwicm91dGVQYXJhbXMiLCJleHRlcm5hbFVSTCIsIkpTT04iLCJpY29uSFRNTCIsIm5ld0l0ZW0iLCJzZWFyY2hUZXJtIiwicHJvdmlkZXJJZCIsImljb25DbGFzcyIsImljb25VcmwiLCJwdXNoIiwic2VyaWFsaXplIiwibW9kdWxlIiwiaGFzIiwibm9vcCIsImVhY2giLCJmaWx0ZXIiLCJpbmNsdWRlcyIsIm9uY2UiLCJFdmVudEVtaXR0ZXIiLCJwYXJzZSIsImRlcGFyYW0iLCJXQVJOSU5HX1RJTUVPVVQiLCJYSFJQcm94eUZhY3RvcnkiLCJYSFIiLCJ3cmFwcGVycyIsImxvZ0Vycm9yIiwiZXJyb3IiLCJzZXRUaW1lb3V0IiwidHJhbnNmb3JtRXZlbnQiLCJvbGRUYXJnZXQiLCJuZXdUYXJnZXQiLCJuZXdFdmVudCIsImNvbmNhdCIsImJpbmQiLCJ3cmFwRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZmluZEFwcGxpY2FibGVXcmFwcGVycyIsImNvbm5lY3Rpb24iLCJ3cmFwcGVyIiwiaXNSZWxldmFudFRvIiwiZSIsIlhIUlByb3h5IiwiX3dyYXBwZXJzIiwiX2xpc3RlbmVycyIsIl9ib3VuZExpc3RlbmVycyIsIl9ldmVudHMiLCJfb3BlblN0YXRlIiwiYXBwbHkiLCJfcmVhbHhociIsImFyZ3VtZW50cyIsInNlbGYiLCJ0cmlnZ2VyRXZlbnRMaXN0ZW5lcnMiLCJib3VuZExpc3RlbmVyIiwicnVuUnNjTGlzdGVuZXJzIiwiX2Zha2VSc2NFdmVudCIsImZyZWV6ZSIsImJ1YmJsZXMiLCJjYW5jZWxCdWJibGUiLCJjYW5jZWxhYmxlIiwiZGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwidHlwZSIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJzcmNFbGVtZW50IiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwiZXZlbnRQaGFzZSIsImRlbGl2ZXJGaW5hbFJzYyIsInJlYWR5U3RhdGUiLCJ3YXNTdWNjZXNzIiwicHJvZ3Jlc3NFdmVudCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJ0b3RhbCIsInN1cHBvcnRzUmVzcG9uc2VUZXh0IiwicmVzcG9uc2VUeXBlIiwiX2FjdGl2ZVdyYXBwZXJzIiwiZmluYWxSZXNwb25zZVRleHRMb2dnZXIiLCJfY29ubmVjdGlvbiIsImFmdGVyTGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwib3JpZ2luYWxSZXNwb25zZVRleHRMb2dnZXIiLCJvcmlnaW5hbFJlc3BvbnNlVGV4dCIsImZpbmlzaCIsImFzeW5jIiwic3RhcnRDb25uZWN0aW9uIiwibW9kaWZpZWRSZXNwb25zZVRleHQiLCJyZXNwb25zZVRleHRDaGFuZ2VyIiwiX3Jlc3BvbnNlVGV4dENoYW5nZXJzIiwibG9uZ1J1bldhcm5pbmdUaW1lciIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYXJUaW1lb3V0IiwiY2F0Y2giLCJsZW5ndGgiLCJwcm9wIiwiZ2V0Iiwic2V0IiwidiIsInJlc3BvbnNlIiwiYWJvcnQiLCJfY2xpZW50U3RhcnRlZFNlbmQiLCJfcmVhbFN0YXJ0ZWRTZW5kIiwiX3JlcXVlc3RDaGFuZ2VycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpIiwiaW5kZXhPZiIsInNwbGljZSIsInBhcmFtcyIsInNwbGl0IiwibWFwIiwiQm9vbGVhbiIsInJlcXVlc3RDaGFuZ2VyIiwiYm9keSIsIm9yaWdpbmFsU2VuZEJvZHlMb2dnZXIiLCJyZXF1ZXN0IiwibW9kaWZpZWRSZXF1ZXN0IiwiZW1pdCIsIm9iaiIsIlVOU0VOVCIsIk9QRU5FRCIsIkhFQURFUlNfUkVDRUlWRUQiLCJMT0FESU5HIiwiRE9ORSIsImludGVyc2VjdGlvbiIsImxvZ2dlciIsImNsZWFudXBQZW9wbGVMaW5lIiwiVGhyZWFkUm93QWQiLCJTeW1ib2wiLCJleHRyYWN0TWV0YWRhdGFGcm9tVGhyZWFkUm93IiwidGhyZWFkUm93IiwidGltZVNwYW4iLCJzdWJqZWN0U3BhbiIsInBlb3BsZURpdiIsImhhc0F0dHJpYnV0ZSIsImVycm9ycyIsInRocmVhZFJvd0lzVmVydGljYWwiLCJBcnJheSIsImZyb20iLCJjbGFzc0xpc3QiLCJpc1RocmVhZFJvd0FkIiwicXVlcnlTZWxlY3RvciIsInRocmVhZFJvdzIiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJ0aHJlYWRSb3czIiwiY29udGFpbnMiLCJzdWJqZWN0QXJlYURpdiIsImNoaWxkcmVuIiwidGltZVN0cmluZyIsImdldEF0dHJpYnV0ZSIsInN1YmplY3QiLCJwZW9wbGVIdG1sIiwiY29uc3RhbnQiLCJpZ25vcmVFcnJvcnMiLCJnZXRJZk93biIsIm9iamVjdCIsImNsaWNrQW5kR2V0UG9wdXBVcmwiLCJlbGVtZW50IiwiY3JlYXRlRXZlbnQiLCJidXR0b24iLCJwb2ludGVyWCIsInBvaW50ZXJZIiwiY3RybEtleSIsImFsdEtleSIsInNoaWZ0S2V5IiwibWV0YUtleSIsImluaXRNb3VzZUV2ZW50IiwiZGVmYXVsdFZpZXciLCJvbGRXaW5kb3dPcGVuIiwib2xkV2luZG93T25lcnJvciIsIm9sZEZvY3VzIiwiSFRNTEVsZW1lbnQiLCJvbGRCbHVyIiwiZm9jdXMiLCJibHVyIiwibmV3T3BlbiIsIl91cmwiLCJfdGl0bGUiLCJfb3B0aW9ucyIsIm5ld1dpbiIsImNsb3NlZCIsImRpc3BhdGNoRXZlbnQiLCJmaW5kUGFyZW50IiwiZWwiLCJjYiIsImNhbmRpZGF0ZSIsInBhcmVudEVsZW1lbnQiLCJDdXN0b21Eb21FdmVudCIsInRlbGxNZVRoaXNUaHJlYWRJZEJ5RGF0YWJhc2UiLCJ0ZWxsTWVUaGlzVGhyZWFkSWRCeUNsaWNrIiwiZmluZCIsIkdtYWlsUmVzcG9uc2VQcm9jZXNzb3IiLCJ0aHJlYWRSb3dQYXJzZXIiLCJzZXR1cCIsInByb2Nlc3NQcmVsb2FkZWRUaHJlYWRzIiwidGhyZWFkSWQiLCJnZXRHbWFpbFRocmVhZElkRm9yVGhyZWFkUm93QnlEYXRhYmFzZSIsInNldEF0dHJpYnV0ZSIsImdldEdtYWlsVGhyZWFkSWRGb3JUaHJlYWRSb3dCeUNsaWNrIiwicHJvY2Vzc1RocmVhZExpc3RSZXNwb25zZSIsInRocmVhZExpc3RSZXNwb25zZSIsInByb2Nlc3NUaHJlYWRzIiwiZXh0cmFjdFRocmVhZHMiLCJ0aHJlYWRzIiwic3RvcmVUaHJlYWRNZXRhZGF0YSIsIkFNQklHVU9VUyIsInRocmVhZElkc0J5S2V5IiwiTWFwIiwidGhyZWFkTWV0YWRhdGEiLCJrZXkiLCJ0aHJlYWRNZXRhZGF0YUtleSIsImdtYWlsVGhyZWFkSWQiLCJ0aHJlYWRSb3dNZXRhZGF0YSIsInRyaW0iLCJwcmVsb2FkU2NyaXB0IiwicXVlcnlTZWxlY3RvckFsbCIsInNjcmlwdCIsInNsaWNlIiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJsYXN0SW5kZXhPZiIsInZpZXdEYXRhU3RyaW5nIiwiZXh0cmFjdFRocmVhZHNGcm9tRGVzZXJpYWxpemVkIiwiZGVzZXJpYWxpemVBcnJheSIsImdldFRocmVhZElkRnJvbVVybCIsInRpZCIsInRoIiwidXJsSGFzaE1hdGNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZG9tUm93TWV0YWRhdGEiLCJwYXJlbnQiLCJub2RlTmFtZSIsImN1cnJlbnRSb3dTZWxlY3Rpb24iLCJpc05vdE5pbCIsIkJpZ051bWJlciIsImV4dHJhY3RUaHJlYWRzRnJvbVNlYXJjaFJlc3BvbnNlIiwicGFyc2VkUmVzcG9uc2UiLCJpc0FycmF5IiwiZXh0cmFjdFRocmVhZHNGcm9tU2VhcmNoUmVzcG9uc2VfMjAyMjA5MDkiLCJ0aHJlYWREZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JXcmFwcGVyIiwiaW5kZXgiLCJkZXNjcmlwdG9yIiwic25pcHBldCIsInN5bmNUaHJlYWRJRCIsIm9sZEdtYWlsVGhyZWFkSUQiLCJ0b1N0cmluZyIsInJhd1Jlc3BvbnNlIiwiZXh0cmFNZXRhRGF0YSIsInN5bmNNZXNzYWdlRGF0YSIsIm1kIiwic3luY01lc3NhZ2VJRCIsIm9sZE1lc3NhZ2VJRCIsImRhdGUiLCJleHRyYWN0VGhyZWFkc0Zyb21UaHJlYWRSZXNwb25zZSIsImV4dHJhY3RUaHJlYWRzRnJvbVRocmVhZFJlc3BvbnNlXzIwMjIwOTA5IiwidW5kZWZpbmVkIiwicmVjaXBpZW50cyIsImdldFJlY2lwaWVudHNGcm9tTWVzc2FnZURlc2NyaXB0b3IiLCJ0aHJlYWREZXNjcmlwdG9yIiwiZnVsbE1lc3NhZ2VEZXNjcmlwdG9ycyIsIm1lc3NhZ2VEZXNjcmlwdG9ycyIsInN5bmNNZXNzYWdlSWQiLCJnZXRSZWNpcGllbnRzRnJvbU1lc3NhZ2VEZXNjcmlwdG9yXzIwMjIwOTA5IiwibWVzc2FnZURlc2NyaXB0b3IiLCJ0byIsImNjIiwiYmNjIiwicmVjaXBpZW50RGVzY3JpcHRvciIsImVtYWlsQWRkcmVzcyIsInJlcGxhY2VUaHJlYWRzSW5TZWFyY2hSZXNwb25zZSIsInJlcGxhY2VtZW50VGhyZWFkcyIsIl91bnVzZWQiLCJyZXBsYWNlVGhyZWFkc0luU2VhcmNoUmVzcG9uc2VfMjAyMjA5MDkiLCJfcmVmIiwiX3JlZjIiLCJfcmVmMyIsIl9yZWY0IiwiX3JlZjUiLCJyZXMiLCJfcmVmNiIsIl9yZWY3IiwiX3JlZjgiLCJfcmVmOSIsImdtYWlsQWpheCIsImdldEFjY291bnRVcmxQYXJ0IiwiZ2V0VGhyZWFkRnJvbVN5bmNUaHJlYWRJZCIsImRyaXZlciIsInN5bmNUaHJlYWRJZCIsImJ0YWlIZWFkZXIiLCJ4c3JmVG9rZW4iLCJhbGwiLCJnZXRQYWdlQ29tbXVuaWNhdG9yIiwiZ2V0QnRhaUhlYWRlciIsImdldFhzcmZUb2tlbiIsImdldFRocmVhZEZyb21TeW5jVGhyZWFkSWRVc2luZ0hlYWRlcnMiLCJ0aHJlYWQiLCJzdGFydHNXaXRoIiwiZXh0cmFjdE1lc3NhZ2VzIiwicmVxdWVzdEdtYWlsVGhyZWFkIiwidGhyZWFkSWRUb01lc3NhZ2VzIiwiZXhwb3NlTWV0YWRhdGEiLCJtIiwiYXR0cmlidXRlIiwicHJvY2Vzc29yIiwiZGV0YWlsIiwiaWtWYWx1ZSIsIm1lc3NhZ2VJbmRleCIsImdldE1lc3NhZ2UiLCJhZGREYXRhRm9yVGhyZWFkIiwibWVzc2FnZXMiLCJhZGQiLCJncm91cGVkTWVzc2FnZXMiLCJncm91cCIsInRocmVhZElEIiwiYWN0aXZlVGhyZWFkUmVxdWVzdFByb21pc2VzIiwiZXhpc3RpbmdSZXF1ZXN0UHJvbWlzZSIsIm5ld1Byb21pc2UiLCJzeW5jVGhyZWFkIiwic3luY01lc3NhZ2UiLCJkZWxldGUiLCJxdW90ZWRTcGxpdCIsInMiLCJsYXN0RW5kIiwicXVvdGVSZSIsImV4ZWMiLCJzdWJzdHJpbmciLCJkZWZlciIsInByb21pc2UiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJTRU5EX0FDVElPTlMiLCJEUkFGVF9TQVZJTkdfQUNUSU9OUyIsInNvcnRCeSIsIkFDVElPTl9UWVBFX1BSSU9SSVRZX1JBTksiLCJwYXJzZUNvbXBvc2VSZXF1ZXN0Qm9keV8yMDIyXzA5XzA5IiwicGFyc2VDcmVhdGVVcGRhdGVTZW5kRHJhZnRSZXF1ZXN0Qm9keSIsInBhcnNlQ29tcG9zZVJlc3BvbnNlQm9keV8yMDIyXzA5XzA5IiwicGFyc2VDcmVhdGVVcGRhdGVTZW5kRHJhZnRSZXNwb25zZUJvZHkiLCJyZXBsYWNlQm9keUNvbnRlbnRJbkNvbXBvc2VTZW5kUmVxdWVzdEJvZHlfMjAyMl8wOV8wOSIsIm5ld0JvZHlIdG1sQ29udGVudCIsInJlcGxhY2VCb2R5Q29udGVudEluU2VuZFJlcXVlc3RCb2R5IiwidXBkYXRlTGlzdCIsInBhcnNlZE1lc3NhZ2VzIiwicGFyc2VSZXF1ZXN0VGhyZWFkIiwic29ydGVkIiwicGFyc2VSZXNwb25zZVRocmVhZCIsImZsYXRNYXAiLCJwYXJzZWRUaHJlYWQiLCJvbGRUaHJlYWRJZCIsInBhcnNlZE1lc3NhZ2UiLCJtZXNzYWdlSWQiLCJhY3Rpb25zIiwicmZjSUQiLCJvbGRNZXNzYWdlSWQiLCJhY3Rpb25UeXBlIiwiYWN0aW9uc1RvQ29tcG9zZVJlcXVlc3RUeXBlIiwicmVwbGFjZUJvZHlJblRoaXNNZXNzYWdlSWQiLCJ0aHJlYWRXcmFwcGVyIiwicGFyc2VUaHJlYWRJZCIsInBhcnNlUmVzdWx0IiwiZmluZEFuZFBhcnNlUmVxdWVzdE1lc3NhZ2UiLCJwYXJzZWRNc2ciLCJyZXBsYWNlQm9keUluUmVxdWVzdE1zZyIsIm9yaWdpbmFsTXNnIiwicGFyc2VNc2dJZCIsInBhcnNlQ29udGFjdHMiLCJjb250YWN0cyIsImMiLCJvcmlnaW5hbE1zZ3MiLCJwYXJzZVJlcXVlc3RNc2ciLCJtc2ciLCJ0aHJlYWRJbm5lciIsInBhcnNlUmVzcG9uc2VNc2ciLCJnZXREZXRhaWxzT2ZDb21wb3NlUmVxdWVzdCIsIm1lc3NhZ2VVcGRhdGVzIiwidXBkYXRlIiwidXBkYXRlV3JhcHBlciIsInNlbmRVcGRhdGVNYXRjaCIsInNlbmRVcGRhdGVXcmFwcGVyIiwic2VuZFVwZGF0ZSIsImdldENvbXBvc2VSZXF1ZXN0RnJvbVVwZGF0ZSIsImZpcnN0TWVzc2FnZVVwZGF0ZSIsImRyYWZ0SUQiLCJyZXBsYWNlRW1haWxCb2R5Rm9yU2VuZFJlcXVlc3QiLCJuZXdCb2R5IiwicGFyc2VDb21wb3NlUmVxdWVzdEJvZHkiLCJyZXF1ZXN0UGFyc2VkIiwiZXZlbnRTZGtQYXNzaXZlIiwicmVxdWVzdFBhcnNlRXJyb3IiLCJwYXJzZUNvbXBvc2VSZXNwb25zZUJvZHkiLCJyZXNwb25zZVBhcnNlZCIsInJlcGxhY2VCb2R5Q29udGVudEluQ29tcG9zZVNlbmRSZXF1ZXN0Qm9keSIsInJlcGxhY2VkUmVxdWVzdE9iaiIsInJlcGxhY2VCb2R5RmFpbGVkIiwiY2xvbmUiLCJmbGF0dGVuIiwiS2VmaXIiLCJ0aHJlYWRJZGVudGlmaWVyIiwibWVzc2FnZU1ldGFkYXRhSG9sZGVyIiwiR21haWxTeW5jUmVzcG9uc2VQcm9jZXNzb3IiLCJsb2dFcnJvckV4Y2VwdEV2ZW50TGlzdGVuZXJzIiwiZGV0YWlscyIsInNldHVwR21haWxJbnRlcmNlcHRvciIsImpzRnJhbWUiLCJqc19mcmFtZV9lbGVtZW50IiwidG9wIiwiZ2V0RWxlbWVudEJ5SWQiLCJjb250ZW50RG9jdW1lbnQiLCJzZXR1cEdtYWlsSW50ZXJjZXB0b3JPbkZyYW1lcyIsIm1haW5GcmFtZSIsIm1haW5fd3JhcHBlcnMiLCJqc19mcmFtZV93cmFwcGVycyIsIm1haW5fb3JpZ2luYWxYSFIiLCJqc19mcmFtZV9vcmlnaW5hbFhIUiIsIm1vZGlmaWVycyIsImZyb21FdmVudHMiLCJvblZhbHVlIiwia2V5SWQiLCJjb21wb3NlaWQiLCJtb2RpZmllcklkIiwiaXRlbSIsImFjdCIsInRyaWdnZXJFdmVudCIsImNvbXBvc2VQYXJhbXMiLCJjb21wb3NlTW9kaWZpZXJJZHMiLCJpaSIsIm1vZGlmaWNhdGlvblByb21pc2UiLCJ0YWtlIiwidG9Qcm9taXNlIiwiaXNQbGFpblRleHQiLCJpc2h0bWwiLCJuZXdDb21wb3NlUGFyYW1zIiwic3RyaW5naWZ5Q29tcG9zZVBhcmFtcyIsIm9yaWdpbmFsU2VuZEJvZHkiLCJjb25uZWN0aW9uRGV0YWlscyIsImN1cnJlbnRTZW5kQ29ubmVjdGlvbklEcyIsIldlYWtNYXAiLCJjdXJyZW50RHJhZnRTYXZlQ29ubmVjdGlvbklEcyIsImN1cnJlbnRGaXJzdERyYWZ0U2F2ZUNvbm5lY3Rpb25JRHMiLCJjb21wb3NlUmVxdWVzdERldGFpbHMiLCJuZXdFbWFpbEJvZHkiLCJzZW5kRmFpbGVkIiwicmVzcG9uc2VzUGFyc2VkIiwiZW5kc1dpdGgiLCJtZXNzYWdlSUQiLCJvbGRUaHJlYWRJRCIsInJlc3BvbnNlUGFyc2VFcnJvciIsIm9yaWdpbmFsUmVzcG9uc2UiLCJ0aHJlYWRVcGRhdGUiLCJtZXNzYWdlVXBkYXRlIiwib2xkV3JhcHBlciIsInNhdmVVcGRhdGUiLCJtaW5pbWFsU2VuZFVwZGF0ZXMiLCJpc0VtYWlsU2VudFJlc3BvbnNlIiwic2VhcmNoIiwidmlldyIsInByb3ZpZGVycyIsImNyZWF0ZSIsImN1cnJlbnRRdWVyeSIsInN1Z2dlc3Rpb25Nb2RpZmljYXRpb25zIiwiY3VycmVudFF1ZXJ5RGVmZXIiLCJwcm92aWRlcklEIiwicG9zaXRpb24iLCJwcm92aWRlciIsInN1Z2dlc3Rpb25zIiwiY2xpZW50IiwiZ3NfcmkiLCJwYXJzZWRCb2R5IiwiX2RlZmVyIiwiY3VzdG9tU2VhcmNoVGVybXMiLCJxdWVyeVJlcGxhY2VtZW50IiwidGVybSIsIm5ld1F1ZXJ5IiwiY3VzdG9tU2VhcmNoVGVybSIsInEiLCJzdGFydCIsIl9xdWVyeVJlcGxhY2VtZW50IiwibmV3UGFyYW1zIiwibmV3Rm9ybWF0IiwicGF5bG9hZCIsInNlYXJjaFN0cmluZyIsInBhZ2VPZmZzZXQiLCJpc1N5bmNBUElTZWFyY2hXaXRoQ3VzdG9tVGVybSIsImN1c3RvbVNlYXJjaFF1ZXJpZXMiLCJjdXN0b21MaXN0Sm9iIiwibmV3U3RhcnQiLCJuZXdSZXF1ZXN0UGFyYW1zIiwibmV3UmVzdWx0cyIsIngiLCJfY3VzdG9tTGlzdEpvYiIsInNlYXJjaFF1ZXJ5IiwiX3JlZjEwIiwic2F2ZUJUQUlIZWFkZXIiLCJoZWFkZXIiLCJoZWFkIiwic2F2ZVhzcmZUb2tlbkhlYWRlciIsImdvb2dsZUFwaUtleSIsImF1dGhvcml6YXRpb25IZWFkZXIiLCJnYXBpIiwiYXV0aCIsImdldEF1dGhIZWFkZXJWYWx1ZUZvckZpcnN0UGFydHkiLCJhdXRob3JpemF0aW9uIiwiVVJMIiwiaG9zdG5hbWUiLCJDdXN0b21FdmVudCIsImluQ29tcG9zZVBhcmFtcyIsInN0cmluZyIsInN0cmluZ2lmeUNvbXBvc2VSZWNpcGllbnRQYXJhbSIsInBhcmFtVHlwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNldHVwR21vbmtleUhhbmRsZXIiLCJnbW9ua2V5UHJvbWlzZSIsInNldHVwR21vbmtleSIsImdtb25rZXkiLCJhbnN3ZXIiLCJpc0NvbnZlcnNhdGlvblZpZXdEaXNhYmxlZCIsImluaXRDdXN0b21FdmVudCIsImlzUHJldmlld2VkVGhyZWFkIiwicm93cyIsImVsZW1lbnRXaXRoSWQiLCJyb3ciLCJ2MiIsImdldEN1cnJlbnRUaHJlYWQiLCJnZXRUaHJlYWRJZCIsImNoZWNrIiwibG9hZCIsImVycm9yUHJvcGVydGllcyIsInN0YWNrIiwic2Vuc2l0aXZlIiwiV2FpdEZvckVycm9yIiwid2FpdEZvciIsInRpbWVvdXQiLCJzdGVwdGltZSIsInRpbWVvdXRFcnJvciIsIndhaXRlZCIsInN0ZXAiLCJyZXN1bHQiLCJzdHVwaWRUb0Jvb2wiLCJzdHVwaWQiLCJnZXRTZXR0aW5nVmFsdWUiLCJzZXR0aW5ncyIsImVudHJ5Iiwic2V0dGluZyIsImdldENvbnRleHQiLCJjb250ZXh0IiwiZ2xvYmFsIiwiR0xPQkFMUyIsIm9wZW5lciIsImxvY2F0aW9uIiwiaHJlZiIsInNldHVwRGF0YUV4cG9zZXIiLCJnYmFyIiwidXNlckVtYWlsIiwiX0NPTkZJRyIsInVzZXJMYW5ndWFnZSIsIkdNX1NQVF9FTkFCTEVEIiwiR01fQUNUSU9OX1RPS0VOIiwiZ2xvYmFsU2V0dGluZ3NIb2xkZXIiLCJnbG9iYWxTZXR0aW5ncyIsInByZXZpZXdQYW5lTGFiRW5hYmxlZCIsInByZXZpZXdQYW5lRW5hYmxlZCIsInByZXZpZXdQYW5lVmVydGljYWwiLCJwcmV2aWV3UGFuZU1vZGUiLCJwcmVsb2FkRGF0YVNlYXJjaFN0cmluZyIsInByZWxvYWREYXRhIiwiZ2V0U3RhdHVzIiwiaGFzR0xPQkFMUyIsImhhc0diYXIiLCJzdGFydFN0YXR1cyIsIndhaXRUaW1lIiwibGF0ZXJTdGF0dXMiLCJzZXR1cEVycm9yU2lsZW5jZXIiLCJvbGRFcnJvckhhbmRsZXJzIiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwicG9wIiwic2V0dXBFdmVudFJlZW1pdHRlciIsImluaXRFdmVudCIsInByb3BzIiwiZGF0YVRyYW5zZmVyIiwiZmlsZXMiLCJmaWxlTmFtZXMiLCJmaWxlTmFtZSIsImZpbGUiLCJkcm9wRWZmZWN0IiwiZWZmZWN0QWxsb3dlZCIsIml0ZW1zIiwia2luZCIsImdldEFzRmlsZSIsImdldEFzU3RyaW5nIiwidHlwZXMiLCJnZXREYXRhIiwic2V0RGF0YSIsInNldERyYWdJbWFnZSIsImNsb3Nlc3QiLCJibG9ja2VkQW55TW9kS2V5cyIsImJsb2NrZWRLZXlJZGVudGlmaWVycyIsImJsb2NrZWRBbnlNb2RDaGFyYWN0ZXJzIiwiYmxvY2tlZE5vTW9kQ2hhcmFjdGVycyIsImJsb2NrZWRTaGlmdENoYXJhY3RlcnMiLCJzaG91bGRCbG9ja0V2ZW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwid2hpY2giLCJrZXlDb2RlIiwia2V5SWRlbnRpZmllciIsInRvTG93ZXJDYXNlIiwiaGFuZGxlciIsImRlZmluZVByb3BlcnRpZXMiLCJjaGFyQ29kZSIsImNvZGUiLCJzZXR1cEN1c3RvbVZpZXdFdmVudEFzc2Fzc2luIiwic2V0dXBJbmJveEN1c3RvbVZpZXdMaW5rRml4ZXIiLCJhbGxvd2VkU3RhcnRUZXJtcyIsIlNldCIsImFuY2hvciIsIkhUTUxBbmNob3JFbGVtZW50Iiwic3RhcnRUZXJtIiwic2V0dXBQdXNoU3RhdGVMaXN0ZW5lciIsIm9yaWdQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwicmV0IiwieGhySGVscGVyIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInJlc3BvbnNlVVJMIiwibGFzdCIsInQiLCJtYXBJbmRleGVkIiwiaW50ZXJwcmV0U2VudEVtYWlsUmVzcG9uc2UiLCJyZXNwb25zZVN0cmluZyIsImVtYWlsU2VudEFycmF5IiwiZ21haWxNZXNzYWdlSWQiLCJleHRyYWN0R21haWxNZXNzYWdlSWRGcm9tU2VudEVtYWlsIiwiZXh0cmFjdEdtYWlsVGhyZWFkSWRGcm9tU2VudEVtYWlsIiwibWVzc2FnZUlkQXJyYXlNYXJrZXIiLCJtZXNzYWdlSWRBcnJheSIsIl9zZWFyY2hBcnJheSIsIm1hcmtlckFycmF5IiwidGhyZWFkSWRBcnJheU1hcmtlciIsInRocmVhZElkQXJyYXkiLCJleHRyYWN0R21haWxUaHJlYWRJZEZyb21NZXNzYWdlSWRTZWFyY2giLCJ0aHJlYWRSZXNwb25zZUFycmF5IiwicmV3cml0ZVNpbmdsZVF1b3RlcyIsInJlc3VsdFBhcnRzIiwibmV4dFF1b3RlSW5kZXgiLCJmaW5kTmV4dFF1b3RlIiwic3Vic3RyIiwibmV4dERvdWJsZVF1b3RlSW5kZXgiLCJmaW5kTmV4dFVuZXNjYXBlZENoYXJhY3RlciIsIm5leHRTaW5nbGVRdW90ZUluZGV4IiwicGFydCIsImpvaW4iLCJsZW4iLCJjaGFyIiwidGhyZWFkUmVzcG9uc2VTdHJpbmciLCJpbmNsdWRlTGVuZ3RocyIsInN1Z2dlc3Rpb25Nb2RlIiwibm9BcnJheU5ld0xpbmVzIiwiaW5jbHVkZUV4cGxpY2l0TnVsbHMiLCJwb3MiLCJsaW5lRW5kIiwibGluZSIsImRhdGFMaW5lIiwidHJhbnNmb3JtVW5xdW90ZWRTZWN0aW9ucyIsInN0ciIsInBhcnRzIiwibmV4dFF1b3RlIiwiaW5TdHJpbmciLCJrIiwic3VnZ2VzdGlvblNlcmlhbGl6ZSIsInRocmVhZExpc3RTZXJpYWxpemUiLCJhcnJheVNlY3Rpb24iLCJhcnJheVNlY3Rpb25TdHJpbmciLCJzZXJpYWxpemVBcnJheSIsImxpbmVzIiwiZmlyc3RMaW5lcyIsImxhc3RMaW5lcyIsInN1Z2dlc3Rpb25zQXJyYXkiLCJhcnJheSIsImFkZGl0aW9uIiwicmVhZERyYWZ0SWQiLCJkZWNvZGVkIiwibXNnQSIsInRvQXJyYXkiLCJjb21wb3NlIiwiY2F0IiwicmVwbGFjZVRocmVhZHNJblJlc3BvbnNlIiwiYWN0aW9uUmVzcG9uc2VNb2RlIiwidGhyZWFkVmFsdWUiLCJwcmVUYkdyb3VwcyIsInBvc3RUYkdyb3VwcyIsInByZVRiSXRlbXMiLCJwb3N0VGJJdGVtcyIsImhhc1NlZW5UYiIsInRiU2VlbkluVGhpc0dyb3VwIiwicHJlVGJHcm91cCIsInBvc3RUYkdyb3VwIiwibmV3VGJzIiwiX3RocmVhZHNUb1RiR3JvdXBzIiwicGFyc2VkTmV3IiwiYWxsU2VjdGlvbnMiLCJlbmRTZWN0aW9uIiwiZnVsbE5ldyIsIl9leHRyYWN0VGhyZWFkQXJyYXlzRnJvbVJlc3BvbnNlQXJyYXkiLCJzaG9ydERhdGUiLCJ0aW1lc3RhbXAiLCJpc1VucmVhZCIsImxhc3RFbWFpbEFkZHJlc3MiLCJib2R5UHJldmlld0h0bWwiLCJzb21lR21haWxNZXNzYWdlSWRzIiwiX2V4dHJhY3RNZXNzYWdlSWRzRnJvbVRocmVhZEJhdGNoUmVxdWVzdFhmIiwiZXh0cmFjdE1lc3NhZ2VJZHNGcm9tVGhyZWFkQmF0Y2hSZXF1ZXN0IiwidG9PYmoiLCJfZXh0cmFjdFRocmVhZEFycmF5c0Zyb21SZXNwb25zZUFycmF5WGYiLCJfZXh0cmFjdFRocmVhZHNGcm9tQ29udmVyc2F0aW9uVmlld1Jlc3BvbnNlQXJyYXlYZiIsIm1lc3NhZ2VJRHMiLCJfZXh0cmFjdE1lc3NhZ2VzRnJvbVJlc3BvbnNlQXJyYXlYZiIsIm1lc3NhZ2VNYXAiLCJfdGhyZWFkc1RvVGJHcm91cHNYZiIsIl9vcmlnaW5hbEdtYWlsRm9ybWF0IiwicGFydGl0aW9uIiwidGhyZWFkc0NodW5rIiwicmVzcG9uc2VBcnJheSIsIm1hcmtlciIsIm1hcmtlckFycmF5VmFsaWRhdG9yIiwicGF0aEFycmF5IiwiX3NlYXJjaE9iamVjdCIsInBhdGhUb01hcmtlckFycmF5IiwicGF0aCIsIl9nZXRBcnJheVZhbHVlRnJvbVBhdGgiLCJtYXhEZXB0aCIsInJldFZhbCIsImluaXRpYWxOb2RlIiwibm9kZUxpc3QiLCJub2RlIiwibmV3Tm9kZSIsImN1cnJlbnRBcnJheSIsImRlbGVnYXRlZEFjY291bnRNYXRjaCIsInBhdGhuYW1lIiwiZGVsZWdhdGVkQWNjb3VudElkIiwiZGVsZWdhdGVkQWNjb3VudE51bWJlciIsImFjY291bnRQYXJhbU1hdGNoIiwiYWNjb3VudFBhcmFtIiwiaW1hZ2VSZXF1ZXN0IiwiaW1nIiwiSW1hZ2UiLCJzcmMiLCJyYXRlTGltaXRRdWV1ZXIiLCJmbiIsInBlcmlvZCIsImNvdW50IiwiY2FsbFRpbWVzdGFtcHMiLCJxdWV1ZSIsInJ1bm5pbmdRdWV1ZSIsInJ1bkpvYiIsImpvYiIsInNoaWZ0IiwicnVuUXVldWUiLCJ0aW1lVG9XYWl0IiwiZ2V0VGltZVRvVW5xdWV1ZUl0ZW0iLCJwZXJpb2RBZ28iLCJ0aW1lIiwiYXR0ZW1wdCIsIklNQUdFX1JFUVVFU1RfVElNRU9VVCIsImxpbWl0ZWRBamF4Iiwib3JpZ2luIiwiZnJvbVByb21pc2UiLCJtZXJnZSIsImxhdGVyIiwidGFrZUVycm9ycyIsInF1ZXJ5UGFyYW1ldGVycyIsInVpIiwiaWsiLCJwY2QiLCJtYiIsInJ0IiwiX19JbmJveFNES0luamVjdGVkIiwicmVxdWlyZSIsIm9sZERlZmluZSIsImRlZmluZSIsImFtZCIsImV4dENvcmJXb3JrYXJvdW5kUGFnZVdvcmxkIiwiZGVmYXVsdCIsImdtYWlsSW50ZXJjZXB0b3IiLCJwYWdlT3JpZ2luIiwiX190ZXN0X29yaWdpbiIsImluaXQiXSwic291cmNlUm9vdCI6IiJ9